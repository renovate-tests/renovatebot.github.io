{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Renovate Documentation These Renovate docs are built from Renovate's open source repos to provide a convenient way to browse and search help topics.","title":"Home"},{"location":"#renovate-documentation","text":"These Renovate docs are built from Renovate's open source repos to provide a convenient way to browse and search help topics.","title":"Renovate Documentation"},{"location":"automerge-configuration/","text":"Introduction Automerging is a Renovate feature that can enable you to fully automate upgrading of certain dependencies. When enabled, it means Renovate will attempt to merge the proposed update once it has passed tests. As a general guide, it is recommended that you enable automerge for any types of dependency updates where you would just click Merge anyway. If there are updates for which you prefer to manually review release notes or code before merging, even when they pass tests, then do not enable automerge for those. Automerge works particularly well for devDependencies as well as for production dependencies in projects which have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests... automerge them! If you have a linter like eslint or tslint and its update passes... automerge them! If you have an API with 100% test coverage and express is updated... automerge it! Configuration examples Automerge lock file maintenance The lowest risk type of update to automerge is probably lockFileMaintenance . When Renovate performs lock file maintenance, it leaves the project dependency definitions unchanged, but refreshes the lock file completely so that the latest versions according to the package file constraints are installed. Here is an example of automerging lock file maintenance: { \"lockFileMaintenance\": { \"enabled\": true, \"automerge\": true } } Automerge lint tool updates Automerging lint tool updates can be a real time-saver. Sometimes an update to a lint tool or plugin definition can cause tests to fail, and that is usually deliberate/intentional because the lint authors have added a new rule that you need to adhere to. However, in many cases the new version(s) will pass tests, and if so then there's really nothing else to consider before merging, so they may as well be automerged: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchPackagePatterns\": [\"lint\", \"prettier\"], \"automerge\": true } ] } Automerge non-major updates Non-major updates in SemVer ecosystems shouldn't have breaking changes (if they follow the spec), therefore many users enable automerge for these too: { \"packageRules\": [ { \"matchUpdateTypes\": [\"minor\", \"patch\"], \"matchCurrentVersion\": \"!/^0/\", \"automerge\": true } ] } The matchCurrentVersion setting above is a rule to exclude any dependencies which are pre-1.0.0 because those can make breaking changes at any time according to the SemVer spec. Automerging and scheduling Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to master The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Branch vs PR automerging Even if you automerge PRs, you are likely to still get notification noise - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review Add the renovate/** branch to your testing workflow files, or Renovate will not work properly with the automergeType=branch setting. The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your master branch. If you have enabled branch protection which prevents Renovate from automerging directly to the base branch, then this won't work and you should stick with the default PR-based automerging instead. Assignees and Reviewers When automerge is enabled on a PR, Renovate will not add assignees or reviewers at PR creation time, in order to decrease notifications noise a little. If tests subsequently fail , making automerge not possible, then Renovate will then add the configured assignees and/or reviewers. Frequent problems and how to resolve them Automerge not enabled correctly in config Sometimes, the reason Renovate is not automerging a PR is because of a configuration mistake. You can confirm that Renovate knows you want it to automerge by checking if the PR body includes the text \"Automerge: Enabled\". If you see \"Automerge: Disabled by config\" then it means you need a config change for automerge to work. Absence of tests By default, Renovate will not automerge until it sees passing status checks / check runs for the branch. If you have no tests but still want Renovate to automerge, you need to add \"requiredStatusChecks\": null to your configuration. However, we strongly recommend you have tests in any project where you are regularly updating dependencies. Committer restrictions If you have protected your base branch with a list of allowed committers, and Renovate is not on that list, then naturally automerge can't work. Pull Requests Required If you have configured your project to require Pull Requests before merging, it means that branch automerging is not possible, even if Renovate has rights to commit to the base branch. Required Pull Request reviews If you have mandatory Pull Request reviews then it means Renovate can't automerge its own PR until such a review has happened. If you are running the hosted WhiteSource Renovate App on github.com , you can also install the helper apps renovate-approve and renovate-approve-2 and they will mark all automerging Pull Requests by Renovate as approved. These approval helper apps are only available for GitHub. Codeowners Depending on the platform, having a CODEOWNERS file could block automerging, because it means a code owner must review the PR.","title":"Automerging Updates"},{"location":"automerge-configuration/#introduction","text":"Automerging is a Renovate feature that can enable you to fully automate upgrading of certain dependencies. When enabled, it means Renovate will attempt to merge the proposed update once it has passed tests. As a general guide, it is recommended that you enable automerge for any types of dependency updates where you would just click Merge anyway. If there are updates for which you prefer to manually review release notes or code before merging, even when they pass tests, then do not enable automerge for those. Automerge works particularly well for devDependencies as well as for production dependencies in projects which have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests... automerge them! If you have a linter like eslint or tslint and its update passes... automerge them! If you have an API with 100% test coverage and express is updated... automerge it!","title":"Introduction"},{"location":"automerge-configuration/#configuration-examples","text":"","title":"Configuration examples"},{"location":"automerge-configuration/#automerge-lock-file-maintenance","text":"The lowest risk type of update to automerge is probably lockFileMaintenance . When Renovate performs lock file maintenance, it leaves the project dependency definitions unchanged, but refreshes the lock file completely so that the latest versions according to the package file constraints are installed. Here is an example of automerging lock file maintenance: { \"lockFileMaintenance\": { \"enabled\": true, \"automerge\": true } }","title":"Automerge lock file maintenance"},{"location":"automerge-configuration/#automerge-lint-tool-updates","text":"Automerging lint tool updates can be a real time-saver. Sometimes an update to a lint tool or plugin definition can cause tests to fail, and that is usually deliberate/intentional because the lint authors have added a new rule that you need to adhere to. However, in many cases the new version(s) will pass tests, and if so then there's really nothing else to consider before merging, so they may as well be automerged: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchPackagePatterns\": [\"lint\", \"prettier\"], \"automerge\": true } ] }","title":"Automerge lint tool updates"},{"location":"automerge-configuration/#automerge-non-major-updates","text":"Non-major updates in SemVer ecosystems shouldn't have breaking changes (if they follow the spec), therefore many users enable automerge for these too: { \"packageRules\": [ { \"matchUpdateTypes\": [\"minor\", \"patch\"], \"matchCurrentVersion\": \"!/^0/\", \"automerge\": true } ] } The matchCurrentVersion setting above is a rule to exclude any dependencies which are pre-1.0.0 because those can make breaking changes at any time according to the SemVer spec.","title":"Automerge non-major updates"},{"location":"automerge-configuration/#automerging-and-scheduling","text":"Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to master The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one.","title":"Automerging and scheduling"},{"location":"automerge-configuration/#branch-vs-pr-automerging","text":"Even if you automerge PRs, you are likely to still get notification noise - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review Add the renovate/** branch to your testing workflow files, or Renovate will not work properly with the automergeType=branch setting. The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your master branch. If you have enabled branch protection which prevents Renovate from automerging directly to the base branch, then this won't work and you should stick with the default PR-based automerging instead.","title":"Branch vs PR automerging"},{"location":"automerge-configuration/#assignees-and-reviewers","text":"When automerge is enabled on a PR, Renovate will not add assignees or reviewers at PR creation time, in order to decrease notifications noise a little. If tests subsequently fail , making automerge not possible, then Renovate will then add the configured assignees and/or reviewers.","title":"Assignees and Reviewers"},{"location":"automerge-configuration/#frequent-problems-and-how-to-resolve-them","text":"","title":"Frequent problems and how to resolve them"},{"location":"automerge-configuration/#automerge-not-enabled-correctly-in-config","text":"Sometimes, the reason Renovate is not automerging a PR is because of a configuration mistake. You can confirm that Renovate knows you want it to automerge by checking if the PR body includes the text \"Automerge: Enabled\". If you see \"Automerge: Disabled by config\" then it means you need a config change for automerge to work.","title":"Automerge not enabled correctly in config"},{"location":"automerge-configuration/#absence-of-tests","text":"By default, Renovate will not automerge until it sees passing status checks / check runs for the branch. If you have no tests but still want Renovate to automerge, you need to add \"requiredStatusChecks\": null to your configuration. However, we strongly recommend you have tests in any project where you are regularly updating dependencies.","title":"Absence of tests"},{"location":"automerge-configuration/#committer-restrictions","text":"If you have protected your base branch with a list of allowed committers, and Renovate is not on that list, then naturally automerge can't work.","title":"Committer restrictions"},{"location":"automerge-configuration/#pull-requests-required","text":"If you have configured your project to require Pull Requests before merging, it means that branch automerging is not possible, even if Renovate has rights to commit to the base branch.","title":"Pull Requests Required"},{"location":"automerge-configuration/#required-pull-request-reviews","text":"If you have mandatory Pull Request reviews then it means Renovate can't automerge its own PR until such a review has happened. If you are running the hosted WhiteSource Renovate App on github.com , you can also install the helper apps renovate-approve and renovate-approve-2 and they will mark all automerging Pull Requests by Renovate as approved. These approval helper apps are only available for GitHub.","title":"Required Pull Request reviews"},{"location":"automerge-configuration/#codeowners","text":"Depending on the platform, having a CODEOWNERS file could block automerging, because it means a code owner must review the PR.","title":"Codeowners"},{"location":"bazel/","text":"Bazel Renovate supports upgrading dependencies in Bazel WORKSPACE files. How it works Bazel support is enabled automatically Renovate will search repositories for any WORKSPACE files in the repository Existing dependencies will be extracted from git_repository and http_archive declarations Renovate will replace any old versions with the latest version available git_repository Renovate will update any git_repository declaration that contains the following: name remote matching https://github.com/<owner>/<repo>.git tag using a valid SemVer e.g.: git_repository( name = \"build_bazel_rules_typescript\", remote = \"https://github.com/bazelbuild/rules_typescript.git\", tag = \"0.6.1\", ) Renovate uses the list of tags on the remote repository (GitHub) to detect a new version. http_archive and http_file Renovate will update any http_archive or http_file declaration that contains the following: name url matching https://github.com/<owner>/<repo>/releases/download/<semver>/<repo>.tar.gz sha256 e.g.: http_archive( name = \"io_bazel_rules_go\", url = \"https://github.com/bazelbuild/rules_go/releases/download/0.7.1/rules_go-0.7.1.tar.gz\", sha256 = \"341d5eacef704415386974bc82a1783a8b7ffbff2ab6ba02375e1ca20d9b031c\", ) Renovate uses the list of releases that it finds at the url to detect a new version. Future work Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Bazel"},{"location":"bazel/#bazel","text":"Renovate supports upgrading dependencies in Bazel WORKSPACE files.","title":"Bazel"},{"location":"bazel/#how-it-works","text":"Bazel support is enabled automatically Renovate will search repositories for any WORKSPACE files in the repository Existing dependencies will be extracted from git_repository and http_archive declarations Renovate will replace any old versions with the latest version available","title":"How it works"},{"location":"bazel/#git_repository","text":"Renovate will update any git_repository declaration that contains the following: name remote matching https://github.com/<owner>/<repo>.git tag using a valid SemVer e.g.: git_repository( name = \"build_bazel_rules_typescript\", remote = \"https://github.com/bazelbuild/rules_typescript.git\", tag = \"0.6.1\", ) Renovate uses the list of tags on the remote repository (GitHub) to detect a new version.","title":"git_repository"},{"location":"bazel/#http_archive-and-http_file","text":"Renovate will update any http_archive or http_file declaration that contains the following: name url matching https://github.com/<owner>/<repo>/releases/download/<semver>/<repo>.tar.gz sha256 e.g.: http_archive( name = \"io_bazel_rules_go\", url = \"https://github.com/bazelbuild/rules_go/releases/download/0.7.1/rules_go-0.7.1.tar.gz\", sha256 = \"341d5eacef704415386974bc82a1783a8b7ffbff2ab6ba02375e1ca20d9b031c\", ) Renovate uses the list of releases that it finds at the url to detect a new version.","title":"http_archive and http_file"},{"location":"bazel/#future-work","text":"Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Future work"},{"location":"config-presets/","text":"Shareable Config Presets Renovate's \"config presets\" are a convenient way to distribute config for reuse across multiple repositories. It is similar in design to eslint 's shareable configs, and can be used for whole repository configs and for individual rules. They are defined using the extends array within config and may also be nested. In short: Browse Renovate's default presets to find any that are useful to you Publish your own if you wish to reuse them across repositories Goals of Preset Configs The main reason for supporting preset configs is to decrease duplication. By using a preset config you: Avoid duplicating the same config across all your repositories Can use someone else's configuration and extend it Renovate's configuration is self-documenting, because you can fill in the \"description\" field in all preset configs. Implementation Approach In order to achieve these goals, preset configs allow for a very modular approach - preset configs can be as small as a partial package rule or as large as an entire configuration, like an eslint config. Preset Hosting In general, GitHub, GitLab or Gitea-based preset hosting is easier than npm because you avoid the \"publish\" step - simply commit preset code to the default branch and it will be picked up by Renovate the next time it runs. An additional benefit of using source code hosting is that the same token/authentication can be reused by Renovate in case you want to make your config private. name example use preset resolves as filename GitHub default github>abc/foo default https://github.com/abc/foo default.json or renovate.json GitHub with preset name github>abc/foo:xyz xyz https://github.com/abc/foo xyz.json GitLab default gitlab>abc/foo default https://gitlab.com/abc/foo default.json or renovate.json GitLab with preset name gitlab>abc/foo:xyz xyz https://gitlab.com/abc/foo xyz.json Gitea default gitea>abc/foo default https://gitea.com/abc/foo default.json or renovate.json Gitea with preset name gitea>abc/foo:xyz xyz https://gitea.com/abc/foo xyz.json Local default local>abc/foo default https://github.company.com/abc/foo default.json or renovate.json Example configs An example of a small rule is :preserveSemverRanges , which has the description \"Preserve (but continue to upgrade) any existing semver ranges\". It simply sets the configuration option rangeStrategy to replace . An example of a full config is config:base , which is Renovate's default configuration. It mostly uses Renovate config defaults but adds a few smart customisations such as grouping monorepo packages together. Special note: the :xyz naming convention (with : prefix) is a special shorthand for the default: presets. e.g. :xyz is equivalent to default:xyz . How to Use Preset Configs By default, the Renovate App's onboarding process will suggest [\"config:base]\" . If you are self hosting you must add \"onboardingConfig\": { \"extends\": [\"config:base\"] } to your bot's config. A typical onboarding renovate.json looks like this: { \"extends\": [\"config:base\"] } Say you want to modify the default behavior, for example scheduling Renovate to process upgrades during non-office hours only. To do this you can modify the default renovate.json file like this: { \"extends\": [\"config:base\", \"schedule:nonOfficeHours\"] } This makes use of the schedules: presets. You can find the Renovate team's preset configs at the \"Config Presets\" section of Renovate Docs . Preset Parameters If you browse the \"default\" presets, you will see some that contain parameters, e.g.: \"labels\": { \"description\": \"Apply labels <code>{{arg0}}</code> and <code>{{arg1}}</code> to PRs\", \"labels\": [ \"{{arg0}}\", \"{{arg1}}\" ] }, \"assignee\": { \"description\": \"Assign PRs to <code>{{arg0}}</code>\", \"assignees\": [ \"{{arg0}}\" ] }, Here is how you would use these in your Renovate config: \"extends\": [ \":labels(depedendencies,devops)\", \":assignee(rarkins)\" ] In short, the number of {{argx}} parameters in the definition is how many parameters you need to provide. Parameters must be strings, non-quoted, and separated by commas if there are more than one. If you find that you are repeating config a lot, you might consider publishing one of these types of parameterised presets yourself. Or if you think your preset would be valuable for others, please contribute a PR to the Renovate repository. How to Publish Preset Configs If you manage multiple repositories using Renovate and want the same custom config across all or most of them, then you might want to consider publishing your own preset config so that you can \"extend\" it in every applicable repository. That way when you want to change your Renovate configuration you can make the change in one location rather than having to copy/paste it to every repository individually. Let's say that your username on npm and elsewhere is \"fastcore\". In that case, you can choose between publishing your preset config package as @fastcore/renovate-config or renovate-config-fastcore . Let's assume you choose renovate-config-fastcore as the package name: You then need to publish the renovate-config-fastcore package where the package.json contains the field renovate-config and then put your config under the field default . For example: { \"name\": \"renovate-config-fastcore\", \"version\": \"0.0.1\", ... \"renovate-config\": { \"default\": { \"extends\": [\"config:base\", \"schedule:nonOfficeHours\"] } } } Then in each of your repositories you can add your renovate config like: \"extends\": [\"fastcore\"] Any repository including this config will then adopt the rules of the default library preset but schedule it on weeknights or weekends. Note: if you prefer to publish using the namespace @fastcore/renovate-config then you would use the @ prefix instead: \"extends\": [\"@fastcore\"] GitHub-hosted Presets It is also possible to host your preset config using just a regular GitHub repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, e.g. master. To host your preset config on GitHub: Create a new repository. Normally you'd call it renovate-config but it can be named anything Add configuration files to this new repo for any presets you want to share. For the default preset, default.json will be checked first and then renovate.json . For named presets, <preset-name>.json will be loaded. For example, loading preset library would load library.json . No other files are necessary. In other repos, reference it in an extends array like \"github>owner/name\", for example: \"extends\": [\"github>rarkins/renovate-config\"] From then on Renovate will use the renovate config from the preset repo's default branch. You do not need to add it as a devDependency or add any other files to the preset repo. GitLab-hosted Presets It is also possible to host your preset config using just a regular GitLab repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, (for now only the master branch is supported). To host your preset config on GitLab: Create a new repository on GitLab. Normally you'd call it renovate-config but it can be named anything Add a renovate.json to this new repo containing the preset config. No other files are necessary In other repos, reference it in an extends array like \"gitlab>owner/name\", e.g. \"gitlab>rarkins/renovate-config\" Gitea-hosted Presets It is also possible to host your preset config using just a regular Gitea repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, (for now only the master branch is supported). To host your preset config on Gitea: Create a new repository on Gitea. Normally you'd call it renovate-config but you can use any name you want Add a renovate.json to this new repository containing the preset config. No other files are necessary In other repositories, reference it in an extends array like \"gitea>owner/name\" , e.g. \"gitea>rarkins/renovate-config\" Local presets Renovate also supports local presets, e.g. presets that are hosted on the same platform as the target repository. This is especially helpful in self-hosted scenarios where public presets cannot be used. Local presets are only supported on GitHub, GitLab, Gitea and Bitbucket Server. Local presets are specified either by leaving out any prefix, e.g. owner/name , or explicitly by adding a local> prefix, e.g. local>owner/name . Renovate will determine the current platform and look up the preset from there. Presets and Private Modules Using your own preset config along with private npm modules can present a chicken and egg problem. You want to configure the encrypted token just once, which means in the preset. But you also probably want the preset to be private too, so how can the other repos reference it? The answer is to host your preset using GitHub or GitLab - not npmjs - and make sure you have added the preset's repo to Renovate too. GitHub will then allow Renovate to access the preset repo whenever it is processing any other repos within the same account/org. Contributing to presets Have you configured a rule that you think others might benefit from? Please consider contributing it to the Renovate repository so that it gains higher visibility and saves others from reinventing the same thing. Organization level presets Whenever repository onboarding happens, Renovate checks if the current user/group/org contains a default config to extend. It looks for: A repository called renovate-config under the same user/group/org with either default.json or renovate.json , or A repository named like .{{platform}} (e.g. .github ) under the same user/group/org with renovate-config.json If found, that repository's preset will be suggested as the sole extended preset, and any existing onboardingConfig config will be ignored/overridden. For example the result may be: { \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\", \"extends\": [\"local>myorgname/.github:renovate-config\"] }","title":"Shareable Config Presets"},{"location":"config-presets/#shareable-config-presets","text":"Renovate's \"config presets\" are a convenient way to distribute config for reuse across multiple repositories. It is similar in design to eslint 's shareable configs, and can be used for whole repository configs and for individual rules. They are defined using the extends array within config and may also be nested. In short: Browse Renovate's default presets to find any that are useful to you Publish your own if you wish to reuse them across repositories","title":"Shareable Config Presets"},{"location":"config-presets/#goals-of-preset-configs","text":"The main reason for supporting preset configs is to decrease duplication. By using a preset config you: Avoid duplicating the same config across all your repositories Can use someone else's configuration and extend it Renovate's configuration is self-documenting, because you can fill in the \"description\" field in all preset configs.","title":"Goals of Preset Configs"},{"location":"config-presets/#implementation-approach","text":"In order to achieve these goals, preset configs allow for a very modular approach - preset configs can be as small as a partial package rule or as large as an entire configuration, like an eslint config.","title":"Implementation Approach"},{"location":"config-presets/#preset-hosting","text":"In general, GitHub, GitLab or Gitea-based preset hosting is easier than npm because you avoid the \"publish\" step - simply commit preset code to the default branch and it will be picked up by Renovate the next time it runs. An additional benefit of using source code hosting is that the same token/authentication can be reused by Renovate in case you want to make your config private. name example use preset resolves as filename GitHub default github>abc/foo default https://github.com/abc/foo default.json or renovate.json GitHub with preset name github>abc/foo:xyz xyz https://github.com/abc/foo xyz.json GitLab default gitlab>abc/foo default https://gitlab.com/abc/foo default.json or renovate.json GitLab with preset name gitlab>abc/foo:xyz xyz https://gitlab.com/abc/foo xyz.json Gitea default gitea>abc/foo default https://gitea.com/abc/foo default.json or renovate.json Gitea with preset name gitea>abc/foo:xyz xyz https://gitea.com/abc/foo xyz.json Local default local>abc/foo default https://github.company.com/abc/foo default.json or renovate.json","title":"Preset Hosting"},{"location":"config-presets/#example-configs","text":"An example of a small rule is :preserveSemverRanges , which has the description \"Preserve (but continue to upgrade) any existing semver ranges\". It simply sets the configuration option rangeStrategy to replace . An example of a full config is config:base , which is Renovate's default configuration. It mostly uses Renovate config defaults but adds a few smart customisations such as grouping monorepo packages together. Special note: the :xyz naming convention (with : prefix) is a special shorthand for the default: presets. e.g. :xyz is equivalent to default:xyz .","title":"Example configs"},{"location":"config-presets/#how-to-use-preset-configs","text":"By default, the Renovate App's onboarding process will suggest [\"config:base]\" . If you are self hosting you must add \"onboardingConfig\": { \"extends\": [\"config:base\"] } to your bot's config. A typical onboarding renovate.json looks like this: { \"extends\": [\"config:base\"] } Say you want to modify the default behavior, for example scheduling Renovate to process upgrades during non-office hours only. To do this you can modify the default renovate.json file like this: { \"extends\": [\"config:base\", \"schedule:nonOfficeHours\"] } This makes use of the schedules: presets. You can find the Renovate team's preset configs at the \"Config Presets\" section of Renovate Docs .","title":"How to Use Preset Configs"},{"location":"config-presets/#preset-parameters","text":"If you browse the \"default\" presets, you will see some that contain parameters, e.g.: \"labels\": { \"description\": \"Apply labels <code>{{arg0}}</code> and <code>{{arg1}}</code> to PRs\", \"labels\": [ \"{{arg0}}\", \"{{arg1}}\" ] }, \"assignee\": { \"description\": \"Assign PRs to <code>{{arg0}}</code>\", \"assignees\": [ \"{{arg0}}\" ] }, Here is how you would use these in your Renovate config: \"extends\": [ \":labels(depedendencies,devops)\", \":assignee(rarkins)\" ] In short, the number of {{argx}} parameters in the definition is how many parameters you need to provide. Parameters must be strings, non-quoted, and separated by commas if there are more than one. If you find that you are repeating config a lot, you might consider publishing one of these types of parameterised presets yourself. Or if you think your preset would be valuable for others, please contribute a PR to the Renovate repository.","title":"Preset Parameters"},{"location":"config-presets/#how-to-publish-preset-configs","text":"If you manage multiple repositories using Renovate and want the same custom config across all or most of them, then you might want to consider publishing your own preset config so that you can \"extend\" it in every applicable repository. That way when you want to change your Renovate configuration you can make the change in one location rather than having to copy/paste it to every repository individually. Let's say that your username on npm and elsewhere is \"fastcore\". In that case, you can choose between publishing your preset config package as @fastcore/renovate-config or renovate-config-fastcore . Let's assume you choose renovate-config-fastcore as the package name: You then need to publish the renovate-config-fastcore package where the package.json contains the field renovate-config and then put your config under the field default . For example: { \"name\": \"renovate-config-fastcore\", \"version\": \"0.0.1\", ... \"renovate-config\": { \"default\": { \"extends\": [\"config:base\", \"schedule:nonOfficeHours\"] } } } Then in each of your repositories you can add your renovate config like: \"extends\": [\"fastcore\"] Any repository including this config will then adopt the rules of the default library preset but schedule it on weeknights or weekends. Note: if you prefer to publish using the namespace @fastcore/renovate-config then you would use the @ prefix instead: \"extends\": [\"@fastcore\"]","title":"How to Publish Preset Configs"},{"location":"config-presets/#github-hosted-presets","text":"It is also possible to host your preset config using just a regular GitHub repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, e.g. master. To host your preset config on GitHub: Create a new repository. Normally you'd call it renovate-config but it can be named anything Add configuration files to this new repo for any presets you want to share. For the default preset, default.json will be checked first and then renovate.json . For named presets, <preset-name>.json will be loaded. For example, loading preset library would load library.json . No other files are necessary. In other repos, reference it in an extends array like \"github>owner/name\", for example: \"extends\": [\"github>rarkins/renovate-config\"] From then on Renovate will use the renovate config from the preset repo's default branch. You do not need to add it as a devDependency or add any other files to the preset repo.","title":"GitHub-hosted Presets"},{"location":"config-presets/#gitlab-hosted-presets","text":"It is also possible to host your preset config using just a regular GitLab repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, (for now only the master branch is supported). To host your preset config on GitLab: Create a new repository on GitLab. Normally you'd call it renovate-config but it can be named anything Add a renovate.json to this new repo containing the preset config. No other files are necessary In other repos, reference it in an extends array like \"gitlab>owner/name\", e.g. \"gitlab>rarkins/renovate-config\"","title":"GitLab-hosted Presets"},{"location":"config-presets/#gitea-hosted-presets","text":"It is also possible to host your preset config using just a regular Gitea repository and without needing to publish it to npmjs. In such cases Renovate will simply look for a renovate.json file in the default branch, (for now only the master branch is supported). To host your preset config on Gitea: Create a new repository on Gitea. Normally you'd call it renovate-config but you can use any name you want Add a renovate.json to this new repository containing the preset config. No other files are necessary In other repositories, reference it in an extends array like \"gitea>owner/name\" , e.g. \"gitea>rarkins/renovate-config\"","title":"Gitea-hosted Presets"},{"location":"config-presets/#local-presets","text":"Renovate also supports local presets, e.g. presets that are hosted on the same platform as the target repository. This is especially helpful in self-hosted scenarios where public presets cannot be used. Local presets are only supported on GitHub, GitLab, Gitea and Bitbucket Server. Local presets are specified either by leaving out any prefix, e.g. owner/name , or explicitly by adding a local> prefix, e.g. local>owner/name . Renovate will determine the current platform and look up the preset from there.","title":"Local presets"},{"location":"config-presets/#presets-and-private-modules","text":"Using your own preset config along with private npm modules can present a chicken and egg problem. You want to configure the encrypted token just once, which means in the preset. But you also probably want the preset to be private too, so how can the other repos reference it? The answer is to host your preset using GitHub or GitLab - not npmjs - and make sure you have added the preset's repo to Renovate too. GitHub will then allow Renovate to access the preset repo whenever it is processing any other repos within the same account/org.","title":"Presets and Private Modules"},{"location":"config-presets/#contributing-to-presets","text":"Have you configured a rule that you think others might benefit from? Please consider contributing it to the Renovate repository so that it gains higher visibility and saves others from reinventing the same thing.","title":"Contributing to presets"},{"location":"config-presets/#organization-level-presets","text":"Whenever repository onboarding happens, Renovate checks if the current user/group/org contains a default config to extend. It looks for: A repository called renovate-config under the same user/group/org with either default.json or renovate.json , or A repository named like .{{platform}} (e.g. .github ) under the same user/group/org with renovate-config.json If found, that repository's preset will be suggested as the sole extended preset, and any existing onboardingConfig config will be ignored/overridden. For example the result may be: { \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\", \"extends\": [\"local>myorgname/.github:renovate-config\"] }","title":"Organization level presets"},{"location":"configuration-options/","text":"Configuration Options This document describes all the configuration options you may configure in a Renovate configuration file. Any config you define applies to the whole repository (e.g. if you have a monorepo). You can store your Renovate configuration file in one of the following locations: .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc.json renovate.json renovate.json5 .renovaterc package.json (within a \"renovate\" section) Renovate always uses the config from the repository's default branch, even if that configuration specifies multiple baseBranches . Renovate does not read/override the config from within each base branch if present. Also, be sure to check out Renovate's shareable config presets to save yourself from reinventing any wheels. If you have any questions about the config options, or want to get help/feedback about a config, go to the discussions tab in the Renovate repository and start a new \"config help\" discussion. We will do our best to answer your question(s). addLabels Labels to add to Pull Request. Name Value type array subType string mergeable true The labels field is non-mergeable, meaning that any config setting a list of PR labels will replace any existing list. If you want to append labels for matched rules, then define an addLabels array with one (or more) label strings. All matched addLabels strings will be attached to the PR. Consider this example: { \"labels\": [\"dependencies\"], \"packageRules\": [ { \"matchPackagePatterns\": [\"eslint\"], \"labels\": [\"linting\"] }, { \"matchDepTypes\": [\"optionalDependencies\"], \"addLabels\": [\"optional\"] } ] } With the above config: Optional dependencies will have the labels dependencies and optional ESLint dependencies will have the label linting All other dependencies will have the label dependencies additionalBranchPrefix Additional string value to be appended to branchPrefix. Name Value type string default \"\" This value defaults to an empty string, and is typically not necessary. Some managers populate this field for historical reasons, for example we use docker- for Docker branches, so they may look like renovate/docker-ubuntu-16.x . You normally don't need to configure this, but one example where it can be useful is combining with parentDir in monorepos to split PRs based on where the package definition is located, e.g. { \"additionalBranchPrefix\": \"{{parentDir}}-\" } additionalReviewers Additional reviewers for Pull Requests (in contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it). Name Value type array subType string mergeable true In contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it. This makes it suitable for augmenting a preset or base list without displacing the original, for example when adding focused reviewers for a specific package group. aliases Aliases for registries, package manager specific. Name Value type object additionalProperties [object Object] The aliases object is used for configuring registry aliases. Currently it is needed/supported for the helm-requirements manager only. helm-requirements includes this default alias: { \"aliases\": { \"stable\": \"https://charts.helm.sh/stable\" } } Alias values must be properly formatted URIs. assignAutomerge Assign reviewers and assignees even if the PR is to be automerged. Name Value type boolean default false By default, Renovate will not assign reviewers and assignees to an automerge-enabled PR unless it fails status checks. By configuring this setting to true , Renovate will instead always assign reviewers and assignees for automerging PRs at time of creation. assignees Assignees for Pull Request (either username or email address depending on the platform). Name Value type array subType string Must be valid usernames on the platform in use. assigneesFromCodeOwners Determine assignees based on configured code owners and changes in PR. Name Value type boolean default false If enabled Renovate will try to determine PR assignees by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations. assigneesSampleSize Take a random sample of given size from assignees. Name Value type integer If configured, Renovate will take a random sample of given size from assignees and assign them only, instead of assigning the entire list of assignees you have configured. automerge Whether to automerge branches/PRs automatically, without human intervention. Name Value type boolean default false By default, Renovate raises PRs but leaves them to someone or something else to merge them. By configuring this setting, you can enable Renovate to automerge PRs or even branches itself, therefore reducing the amount of human intervention required. Usually you won't want to automerge all PRs, for example most people would want to leave major dependency updates to a human to review first. You could configure Renovate to automerge all but major this way: { \"packageRules\": [ { \"matchUpdateTypes\": [\"minor\", \"patch\", \"pin\", \"digest\"], \"automerge\": true } ] } Also note that this option can be combined with other nested settings, such as dependency type. So for example you could elect to automerge all (passing) devDependencies only this way: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"automerge\": true } ] } Important: Renovate won't automerge on GitHub if a PR has a negative review outstanding. Note: on Azure there can be a delay between a PR being set as completed by Renovate, and Azure merging the PR / finishing its tasks. Renovate will try to delay until Azure is in the expected state, however if it takes too long it will continue. In some cases this can result in a dependency not being merged, and a fresh PR being created for the dependency. automergeComment PR comment to add to trigger automerge. Used only if automergeType=pr-comment. Name Value type string default \"automergeComment\" Use this only if you configure automergeType=\"pr-comment\" . Example use: { \"automerge\": true, \"automergeType\": \"pr-comment\", \"automergeComment\": \"bors: r+\" } automergeType How to automerge, if enabled. Name Value type string allowedValues branch,pr,pr-comment default \"pr\" This setting is only applicable if you opt in to configure automerge to true for any of your dependencies. Automerging defaults to using Pull Requests ( automergeType=\"pr\" ). In that case Renovate first creates a branch and associated Pull Request, and then automerges the PR on a subsequent run once it detects the PR's status checks are \"green\". If by the next run the PR is already behind master branch then it will be automatically rebased, because Renovate only automerges branches which are up-to-date and green. If Renovate is scheduled for hourly runs on the repository but commits are made every 15 minutes to the main branch, then an automerge like this will keep getting deferred with every rebase. Note: if you have no tests but still want Renovate to automerge, you need to add \"requiredStatusChecks\": null to your configuration. If you prefer that Renovate more silently automerge without Pull Requests at all, you can configure \"automergeType\": \"branch\" . In this case Renovate will: Create the branch, wait for test results Rebase it any time it gets out of date with the base branch Automerge the branch commit if it's: (a) up-to-date with the base branch, and (b) passing all tests As a backup, raise a PR only if either: (a) tests fail, or (b) tests remain pending for too long (default: 24 hours) The final value for automergeType is \"pr-comment\" , intended only for users who already have a \"merge bot\" such as bors-ng and want Renovate to not actually automerge by itself and instead tell bors-ng to merge for it, by using a comment in the PR. If you're not already using bors-ng or similar, don't worry about this option. azureAutoComplete If set to true, Azure DevOps PRs will be set to auto-complete after all (if any) branch policies have been met. Name Value type boolean default false Setting this to true will configure PRs in Azure DevOps to auto-complete after all (if any) branch policies have been met. You can also configure this using packageRules if you want to use it selectively (e.g. per-package). azureWorkItemId The id of an existing work item on Azure Boards to link to each PR. Name Value type integer default 0 When creating a PR in Azure DevOps, some branches can be protected with branch policies to check for linked work items . Creating a work item in Azure DevOps is beyond the scope of Renovate, but Renovate can link an already existing work item when creating PRs. baseBranches An array of one or more custom base branches to be processed. If left empty, the default branch will be chosen. Name Value type array By default, Renovate will detect and process only the repository's default branch, e.g. master . For most projects, this is the expected approach. However, Renovate also allows users to explicitly configure baseBranches , e.g. for use cases such as: You wish Renovate to process only a non-default branch, e.g. dev : \"baseBranches\": [\"dev\"] You have multiple release streams you need Renovate to keep up to date, e.g. in branches master and next : \"baseBranches\": [\"master\", \"next\"] It's possible to add this setting into the renovate.json file as part of the \"Configure Renovate\" onboarding PR. If so then Renovate will reflect this setting in its description and use package file contents from the custom base branch(es) instead of default. bbUseDefaultReviewers Use the default reviewers (Bitbucket only). Name Value type boolean default true Configuring this to true means that Renovate will detect and apply the default reviewers rules to PRs (Bitbucket only). branchConcurrentLimit Limit to a maximum of x concurrent branches. 0 means no limit, null (default) inherits value from prConcurrentLimit . Name Value type integer By default, Renovate won't enforce any concurrent branch limits. If you want the same limit for both concurrent branches and concurrent PRs, then just set a value for prConcurrentLimit and it will be reused for branch calculations too. However, if you want to allow more concurrent branches than concurrent PRs, you can configure both values ( e.g. branchConcurrentLimit=5 and prConcurrentLimit=3 ). This limit is enforced on a per-repository basis. Example config: { \"branchConcurrentLimit\": 3 } branchName Branch name template. Name Value type string default \"{{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}}\" Warning: it's strongly recommended not to configure this field directly. Use at your own risk. If you truly need to configure this then it probably means either: You are hopefully mistaken, and there's a better approach you should use, so open a new \"config help\" discussion at the Renovate discussions tab or You have a use case we didn't anticipate and we should have a feature request from you to add it to the project branchPrefix Prefix to use for all branch names. Name Value type string default \"renovate/\" You can modify this field if you want to change the prefix used. For example if you want branches to be like deps/eslint-4.x instead of renovate/eslint-4.x then you configure branchPrefix = deps/ . Or if you wish to avoid forward slashes in branch names then you could use renovate_ instead, for example. branchPrefix must be configured at the root of the configuration (e.g. not within any package rule) and is not allowed to use template values. e.g. instead of renovate/{{parentDir}}- , configure the template part in additionalBranchPrefix , like \"additionalBranchPrefix\": \"{{parentDir}}-\" . Note that this setting does not change the default onboarding branch name, i.e. renovate/configure . If you wish to change that too, you need to also configure the field onboardingBranch in your admin bot config. branchTopic Branch topic. Name Value type string default \"{{{depNameSanitized}}}-{{{newMajor}}}{{#if isPatch}}.{{{newMinor}}}{{/if}}.x{{#if isLockfileUpdate}}-lockfile{{/if}}\" This field is combined with branchPrefix and additionalBranchPrefix to form the full branchName . branchName uniqueness is important for dependency update grouping or non-grouping so be cautious about ever editing this field manually. This is an advance field and it's recommend you seek a config review before applying it. bumpVersion Bump the version in the package file being updated. Name Value type string allowedValues major,minor,patch default null Currently this setting supports helmv3 , npm and sbt only, so raise a feature request if you have a use for it with other package managers. Its purpose is if you want Renovate to update the version field within your file's package.json any time it updates dependencies within. Usually this is for automatic release purposes, so that you don't need to add another step after Renovate before you can release a new version. Configure this value to \"patch\" , \"minor\" or \"major\" to have Renovate update the version in your edited package.json . e.g. if you wish Renovate to always increase the target package.json version with a patch update, configure this to \"patch\" . For npm only you can also configure this field to \"mirror:x\" where x is the name of a package in the package.json . Doing so means that the package.json version field will mirror whatever the version is that x depended on. Make sure that version is a pinned version of course, as otherwise it won't be valid. cloneSubmodules Set to false to disable initialization of submodules during repository clone. Name Value type boolean default true commitBody Commit message body template. Will be appended to commit message, separated by two line returns. Name Value type string default null Configure this if you wish Renovate to add a commit body, otherwise Renovate just uses a regular single-line commit. For example, To add [skip ci] to every commit you could configure: { \"commitBody\": \"[skip ci]\" } Another example would be if you want to configure a DCO signoff to each commit. commitBodyTable If enabled, append a table in the commit message body describing all updates in the commit. Name Value type boolean default false commitMessage Message to use for commit messages and pull request titles. Name Value type string default \"{{{commitMessagePrefix}}} {{{commitMessageAction}}} {{{commitMessageTopic}}} {{{commitMessageExtra}}} {{{commitMessageSuffix}}}\" Editing of commitMessage directly is now deprecated and not recommended. Please instead edit the fields such as commitMessageAction , commitMessageExtra , etc. commitMessageAction Action verb to use in commit messages and PR titles. Name Value type string default \"Update\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. Actions may be like Update , Pin , Roll back , Refresh , etc. Check out the default value for commitMessage to understand how this field is used. commitMessageExtra Extra description used after the commit message topic - typically the version. Name Value type string default \"to {{#if isMajor}}v{{{newMajor}}}{{else}}{{#if isSingleVersion}}v{{{newVersion}}}{{else}}{{{newValue}}}{{/if}}{{/if}}\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"extra\" is usually an identifier of the new version, e.g. \"to v1.3.2\" or \"to tag 9.2\". commitMessagePrefix Prefix to add to start of commit messages and PR titles. Uses a semantic prefix if semanticCommits enabled. Name Value type string default null This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"prefix\" is usually an automatically applied semantic commit prefix, however it can also be statically configured. commitMessageSuffix Suffix to add to end of commit messages and PR titles. Name Value type string default null This is used to add a suffix to commit messages. Usually left empty except for internal use (multiple base branches, and vulnerability alerts). commitMessageTopic The upgrade topic/noun used in commit messages and PR titles. Name Value type string default \"dependency {{depName}}\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"topic\" is usually refers to the dependency being updated, e.g. \"dependency react\" . configWarningReuseIssue Set this to false and Renovate will open each config warning in a new issue instead of reopening/reusing an existing issue. Name Value type boolean default true Renovate's default behavior is to reuse/reopen a single Config Warning issue in each repository so as to keep the \"noise\" down. However for some people this has the downside that the config warning won't be sorted near the top if you view issues by creation date. Configure this option to false if you prefer Renovate to open a new issue whenever there is a config warning. constraints Configuration object to define language or manager version constraints. Name Value type object mergeable true Constraints are used in package managers which use third party tools to update \"artifacts\" like lock files or checksum files. Typically, the constraint is detected automatically by Renovate from files within the repository and there is no need to manually configure it. Constraints are also used to manually restrict which datasource versions are possible to upgrade to based on their language support. For now this only supports python , other compatibility restrictions will be added in the future. { \"constraints\": { \"python\": \"2.7\" } } If you need to override constraints that Renovate detects from the repository, wrap it in the force object like so: { \"force\": { \"constraints\": { \"node\": \"< 15.0.0\" } } } Note: make sure not to mix this up with the term compatibility , which Renovate uses in the context of version releases, e.g. if a Docker image is node:12.16.0-alpine then the -alpine suffix represents compatibility . dependencyDashboard Whether to create a \"Dependency Dashboard\" issue within the repository. Name Value type boolean default false Configuring dependencyDashboard to true will lead to the creation of a \"Dependency Dashboard\" issue within the repository. This issue contains a list of all PRs pending, open, closed (unmerged) or in error. The goal of this issue is to give visibility into all updates that Renovate is managing. Examples of what having a Dependency Dashboard will allow you to do: View all PRs in one place, rather than having to filter PRs by author Rebase/retry multiple PRs without having to open each individually Override any rate limiting (e.g. concurrent PRs) or scheduling to force Renovate to create a PR that would otherwise be suppressed Recreate an unmerged PR (e.g. for a major update that you postponed by closing the original PR) Note: Enabling the Dependency Dashboard does not itself change any of the \"control flow\" of Renovate, e.g. it will otherwise still create and manage PRs exactly as it always has, including scheduling and rate limiting. The Dependency Dashboard therefore provides visibility as well as additional control. dependencyDashboardApproval Whether updates should require manual approval from within the Dependency Dashboard issue before creation. Name Value type boolean default false This feature allows you to use Renovate's Dependency Dashboard to force approval of updates before they are created. By setting dependencyDashboardApproval to true in config (including within packageRules ), you can tell Renovate to wait for your approval from the Dependency Dashboard before creating a branch/PR. You can approve a pending PR by ticking the checkbox in the Dependency Dashboard issue. Note: When you set dependencyDashboardApproval to true the Dependency Dashboard issue will be created automatically, you do not need to turn on dependencyDashboard explictly. You can configure Renovate to wait for approval for: all package upgrades major, minor, patch level upgrades specific package upgrades upgrades coming from specific package managers If you want to approve all upgrades, set dependencyDashboardApproval to true : { \"dependencyDashboardApproval\": true } If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\": { \"dependencyDashboardApproval\": true } } If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\": [ { \"matchPackagePatterns\": [\"^@package-name\"], \"dependencyDashboardApproval\": true } ] } dependencyDashboardAutoclose Set to true and Renovate will autoclose the Dependency Dashboard issue if there are no updates. Name Value type boolean default false You can configure this to true if you prefer Renovate to close an existing Dependency Dashboard whenever there are no outstanding PRs left. dependencyDashboardFooter Any text added here will be placed last in the Dependency Dashboard issue body, with a divider separator before it. Name Value type string default null dependencyDashboardHeader Any text added here will be placed first in the Dependency Dashboard issue body. Name Value type string default \"This issue contains a list of Renovate updates and their statuses.\" dependencyDashboardTitle Title to use for the Dependency Dashboard issue. Name Value type string default \"Dependency Dashboard\" Configure this option if you prefer a different title for the Dependency Dashboard. description Plain text description for a config or preset. Name Value type array subType string mergeable true The description field is used by config presets to describe what they do. They are then collated as part of the onboarding description. digest Configuration to apply when updating a digest (no change in tag/version). Name Value type object mergeable true Add to this object if you wish to define rules that apply only to PRs that update Docker digests. docker Configuration object for Docker language. Name Value type object mergeable true Add config here if you wish it to apply to Docker package managers Dockerfile and Docker Compose. If instead you mean to apply settings to any package manager that updates using the Docker datasource , use a package rule instead, e.g. { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"labels\": [\"docker-update\"] } ] } dotnet Configuration object for .NET language. Name Value type object mergeable true draftPR If enabled, the PR created by Renovate is set to a draft. Name Value type boolean default false If you want the PRs created by Renovate to be considered as drafts rather than normal PRs, you could add this property to your renovate.json : { \"draftPR\": true } This option is evaluated at PR/MR creation time and is only supported on the following platforms: GitHub, GitLab, Azure. Note that GitLab implements draft status by checking whether the PR's title starts with certain strings. Therefore, draftPR on GitLab is incompatible with the legacy method of triggering Renovate to rebase a PR by renaming the PR to start with rebase! . enabled Enable or disable the bot. Name Value type boolean default true The most common use of enabled is if you want to turn Renovate's functionality off, for some reason. For example, if you wanted to disable Renovate completely on a repository, you could make this your renovate.json : { \"enabled\": false } To disable Renovate for all eslint packages, you can configure a package rule like: { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"enabled\": false } ] } To disable Renovate for npm devDependencies but keep it for dependencies you could configure: { \"packageRules\": [ { \"matchManagers\": [\"npm\"], \"matchDepTypes\": [\"devDependencies\"], \"enabled\": false } ] } enabledManagers A list of package managers to enable. If defined, then all managers not on the list are disabled. Name Value type array This is a way to allow only certain package managers and implicitly disable all others. Example: { \"enabledManagers\": [\"dockerfile\", \"npm\"] } For the full list of available managers, see the Supported Managers documentation. encrypted A configuration object containing configuration encrypted with project key. Name Value type object See Private npm module support for details on how this is used to encrypt npm tokens. excludeCommitPaths A file that matches any of these glob patterns will not be committed, even if it has been updated. Name Value type array subType string Warning: Advanced use! Be careful you know what you're doing with this option. The initial intended use is to allow the user to exclude certain dependencies from being added/removed/modified when \"vendoring\" dependencies. Example: { \"excludeCommitPaths\": [\"vendor/golang.org/x/text/**\"] } The above would mean Renovate would not include files matching the above glob pattern in the commit, even if it thinks they should be updated. extends Configuration presets to use/extend. Note: does not work if configured in config.js. Name Value type array subType string See shareable config presets for details. extractVersion A regex (re2) to extract a version from a datasource's raw version string. Name Value type string format regex default null Use this only when the raw version strings from the datasource do not match the expected format that you need in your package file. You must defined a \"named capture group\" called version as shown in the below examples. For example, to extract only the major.minor precision from a GitHub release, the following would work: { \"packageRules\": [ { \"matchPackageNames\": [\"foo\"], \"extractVersion\": \"^(?<version>v\\\\d+\\\\.\\\\d+)\" } ] } The above will change a raw version of v1.31.5 to v1.31 , for example. Alternatively, to strip a release- prefix: { \"packageRules\": [ { \"matchPackageNames\": [\"bar\"], \"extractVersion\": \"^release-(?<version>.*)$\" } ] } The above will change a raw version of release-2.0.0 to 2.0.0 , for example. A similar one could strip leading v prefixes: { \"packageRules\": [ { \"matchPackageNames\": [\"baz\"], \"extractVersion\": \"^v(?<version>.*)$\" } ] } fetchReleaseNotes Allow to disable release notes fetching. Name Value type boolean default true Configure this to false if you want to disable release notes fetching fileMatch RegEx (re2) pattern for matching manager files. Name Value type array subType string format regex mergeable true fileMatch is used by Renovate to know which files in a repository to parse and extract, and it is possible to override defaults values to customize for your project's needs. Sometimes file matches are really simple - for example with Go Modules Renovate looks for any go.mod file, and you probably don't need to change that default. At other times, the possible files is too vague for Renovate to have any default. For default, Kubernetes manifests can exist in any *.yaml file and we don't want Renovate to parse every single YAML file in every repository just in case some of them contain a Kubernetes manifest, so Renovate's default fileMatch for manager kubernetes is actually empty ( [] ) and needs the user to tell Renovate what directories/files to look in. Finally, there are cases where Renovate's default fileMatch is good, but you may be using file patterns that a bot couldn't possibly guess about. For example, Renovate's default fileMatch for Dockerfile is ['(^|/|\\\\.)Dockerfile$', '(^|/)Dockerfile\\\\.[^/]*$'] . This will catch files like backend/Dockerfile , prefix.Dockerfile or Dockerfile.suffix , but it will miss files like ACTUALLY_A_DOCKERFILE.template . Because fileMatch is mergeable, you don't need to duplicate the defaults and could just add the missing file like this: { \"dockerfile\": { \"fileMatch\": [\"^ACTUALLY_A_DOCKERFILE\\\\.template$\"] } } If you configure fileMatch then it must be within a manager object (e.g. dockerfile in the above example). The full list of supported managers can be found here . followTag If defined, packages will follow this release tag exactly. Name Value type string default null Caution: advanced functionality. Only use it if you're sure you know what you're doing. This functionality requires that the datasource to support distribution streams/tags, such as npm does. The primary use case for this option is if you are following a pre-release tag of a certain dependency, e.g. typescript 's \"insiders\" build. If configured, Renovate bypasses its normal major/minor/patch upgrade logic and stable/unstable consistency logic and keeps your dependency version sync'd strictly to whatever version is in the tag. Beware that Renovate follows tags strictly. For example, if you are following a tag like next and then that stream is released as stable and next is no longer being updated then that means your dependencies also won't be getting updated. gitIgnoredAuthors Additional git authors which are ignored by Renovate. Must conform to RFC5322. Name Value type array subType string Specify commit authors ignored by Renovate. By default, Renovate will treat any PR as modified if another git author has added to the branch. When a PR is considered modified, Renovate won't perform any further commits such as if it's conflicted or needs a version update. If you have other bots which commit on top of Renovate PRs, and don't want Renovate to treat these PRs as modified, then add the other git author(s) to gitIgnoredAuthors . Example: { \"gitIgnoredAuthors\": [\"some-bot@example.org\"] } gitLabAutomerge Enable or disable usage of GitLab's \"merge when pipeline succeeds\" feature when automerging PRs. Name Value type boolean default false Caution (fixed in GitLab >= 12.7): when this option is enabled it is possible due to a bug in GitLab that MRs with failing pipelines might still get merged. This is caused by a race condition in GitLab's Merge Request API - read the corresponding issue for details. golang Configuration object for Go language. Name Value type object mergeable true Configuration added here applies for all Go-related updates, however currently the only supported package manager for Go is the native Go Modules (the gomod manager). group Config if groupName is enabled. Name Value type object mergeable true Caution: Advanced functionality only. Do not use unless you know what you're doing. The default configuration for groups are essentially internal to Renovate and you normally shouldn't need to modify them. However, you may choose to add settings to any group by defining your own group configuration object. groupName Human understandable name for the dependency group. Name Value type string There are multiple cases where it can be useful to group multiple upgrades together. Internally Renovate uses this for branches such as \"Pin Dependencies\", \"Lock File Maintenance\", etc. Another example used previously is to group together all related eslint packages, or perhaps angular or babel . To enable grouping, you configure the groupName field to something non-null. The groupName field allows free text and does not have any semantic interpretation by Renovate. All updates sharing the same groupName will be placed into the same branch/PR. For example, to group all non-major devDependencies updates together into a single PR: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchUpdateTypes\": [\"patch\", \"minor\"], \"groupName\": \"devDependencies (non-major)\" } ] } groupSlug Slug to use for group (e.g. in branch name). Will be calculated from groupName if null. Name Value type string By default, Renovate will \"slugify\" the groupName to determine the branch name. For example if you named your group \"devDependencies (non-major)\" then the branchName would be renovate/devdependencies-non-major . If you wished to override this then you could configure like this: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchUpdateTypes\": [\"patch\", \"minor\"], \"groupName\": \"devDependencies (non-major)\", \"groupSlug\": \"dev-dependencies\" } ] } As a result of the above, the branchName would be renovate/dev-dependencies instead. Note: you shouldn't usually need to configure this unless you really care about your branch names. hashedBranchLength If enabled, branch names will use a hashing function to ensure each branch has that length. Name Value type integer Some code hosting systems have restrictions on the branch name lengths, this option lets you get around these restrictions. You can set the hashedBranchLength option to a number of characters that works for your system and then Renovate will generate branch names with the appropriate length by hashing additionalBranchPrefix and branchTopic , and then truncating the hash so that the full branch name (including branchPrefix ) has the right number of characters. Example: If you have set branchPrefix: \"deps-\" and hashedBranchLength: 12 it will result in a branch name like deps-5bf36ec instead of the traditional pretty branch name like deps-react-17.x . hostRules Host rules/configuration including credentials. Name Value type array subType object mergeable true Currently the purpose of hostRules is to configure credentials for host authentication. You tell Renovate how to match against the host you need authenticated, and then you also tell it which credentials to use. The lookup keys for a hostRule are: hostType , domainName , hostName , and baseUrl . All are optional, but you can only have one of the last three per rule. Supported credential fields are token , username , password , timeout , enabled and insecureRegistry . Example for configuring docker auth: { \"hostRules\": [ { \"domainName\": \"docker.io\", \"username\": \"<some-username>\", \"password\": \"<some-password>\" } ] } To disable requests to a particular host, you can configure a rule like: { \"hostRules\": [ { \"hostName\": \"registry.npmjs.org\", \"enabled\": false } ] } A preset alternative to the above is: { \"extends\": [\":disableHost(registry.npmjs.org)\"] } Note: Disabling a host is only 100% effective if added to self-hosted config. Renovate currently still checks its cache for results first before making connection attempts, so if a public host is blocked in your repository config (e.g. renovate.json ) then it's possible you may get cached results from that host if another repository using the same bot has successfully queried for the same dependency recently. abortIgnoreStatusCodes A list of HTTP status codes to ignore and not abort the run because of when abortOnError=true. Name Value type array subType number parent hostRules This field can be used to configure status codes that Renovate ignores and passes through when abortOnError is set to true . For example to also skip 404 responses then configure the following: { \"hostRules\": [ { \"abortOnError\": true, \"abortIgnoreStatusCodes\": [404] } ] } Note that this field is not mergeable, so the last-applied host rule will take precedence. abortOnError If enabled, Renovate will abort its run when HTTP request errors occur. Name Value type boolean parent hostRules default false Use this field to configure Renovate to abort runs for custom hosts. By default, Renovate will only abort for known public hosts, which has the downside that transient errors for other hosts can cause autoclosing of PRs. To abort Renovate runs for http failures from any host: { \"hostRules\": [ { \"abortOnError\": true } ] } To abort Renovate runs for any docker datasource failures: { \"hostRules\": [ { \"hostType\": \"docker\", \"abortOnError\": true } ] } To abort Renovate for errors for a specific docker host: { \"hostRules\": [ { \"hostName\": \"docker.company.com\", \"abortOnError\": true } ] } When this field is enabled, Renovate will abort its run if it encounters either (a) any low-level http error (e.g. ETIMEDOUT ) or (b) receives a response not matching any of the configured abortIgnoreStatusCodes (e.g. 500 Internal Error ); authType Authentication type for http header. e.g. \"Bearer\" or \"Basic\". Name Value type string parent hostRules default \"Bearer\" This can be used with token to create a custom http authorization header. An example for npm basic auth with token: { \"hostRules\": [ { \"domainName\": \"npm.custom.org\", \"token\": \"<some-token>\", \"authType\": \"Basic\" } ] } This will generate the following header: authorization: Basic <some-token> . baseUrl baseUrl for a host rule. e.g. \"https://api.github.com/\". Name Value type string parent hostRules default null Use this instead of domainName or hostName if you need a rule to apply to a specific path on a host. For example, \"baseUrl\": \"https://api.github.com\" is equivalent to \"hostName\": \"api.github.com\" but \"baseUrl\": \"https://api.github.com/google/\" is not. Renovate does not do a \"longest match\" algorithm to pick between multiple matching baseUrl values in different rules, so put the longer baseUrl rule after the shorter one in your hostRules . concurrentRequestLimit Limit concurrent requests per host. Name Value type integer parent hostRules Usually the default setting is fine, but you can use concurrentRequestLimit to limit the number of concurrent outstanding requests. You only need to adjust this setting if a datasource is rate limiting Renovate or has problems with the load. The limit will be set for any host it applies to. Example config: { \"hostRules\": [ { \"hostName\": \"github.com\", \"concurrentRequestLimit\": 2 } ] } domainName Domain name for a host rule. e.g. \"docker.io\". Name Value type string parent hostRules default null If you have any uncertainty about exactly which hosts a service uses, then it can be more reliable to use domainName instead of hostName or baseUrl . e.g. configure \"hostName\": \"docker.io\" to cover both index.docker.io and auth.docker.io and any other host that's in use. enableHttp2 Enable got HTTP/2 support. Name Value type boolean parent hostRules default false Enable got http2 support. hostName Hostname for a host rule. e.g. \"index.docker.io\". Name Value type string parent hostRules default null hostType hostType for a package rule. Can be a platform name or a datasource name. Name Value type string parent hostRules default null hostType is another way to filter rules and can be either a platform such as github and bitbucket-server , or it can be a datasource such as docker and rubygems . You usually don't need to configure it in a host rule if you have already configured domainName , hostName or baseUrl and only one host type is in use for those, as is usually the case. hostType can help for cases like an enterprise registry that serves multiple package types and has different authentication for each, although it's often the case that multiple baseUrl rules could achieve the same thing. insecureRegistry Explicitly turn on insecure Docker registry access (HTTP). Name Value type boolean parent hostRules default true Warning: Advanced config, use at own risk. Enable this option to allow Renovate to connect to an insecure Docker registry that is http only. This is insecure and is not recommended. Example: { \"hostRules\": [ { \"hostName\": \"reg.insecure.com\", \"insecureRegistry\": true } ] } timeout Timeout (in milliseconds) for queries to external endpoints. Name Value type integer parent hostRules Use this figure to adjust the timeout for queries. The default is 60s, which is quite high. To adjust it down to 10s for all queries, do this: { \"hostRules\": [ { \"timeout\": 10000 } ] } ignoreDeprecated Ignore deprecated versions unless the current version is deprecated. Name Value type boolean default true By default, Renovate won't update a dependency version to a deprecated release unless the current version was itself deprecated. The goal of this is to make sure you don't upgrade from a non-deprecated version to a deprecated one just because it's higher than the current version. If for some reason you wish to force deprecated updates with Renovate, you can configure ignoreDeprecated to false , but this is not recommended for most situations. ignoreDeps Dependencies to ignore. Name Value type array subType string mergeable true The ignoreDeps configuration field allows you to define a list of dependency names to be ignored by Renovate. Currently it supports only \"exact match\" dependency names and not any patterns. e.g. to ignore both eslint and eslint-config-base you would add this to your config: { \"ignoreDeps\": [\"eslint\", \"eslint-config-base\"] } The above is the same as if you wrote this package rule: { \"packageRules\": [ { \"matchPackageNames\": [\"eslint\", \"eslint-config-base\"], \"enabled\": false } ] } ignoreNpmrcFile Whether to ignore any .npmrc file found in repository. Name Value type boolean default false By default, Renovate will look for and use any .npmrc file it finds in a repository. Additionally, it will be read in by npm or yarn at the time of lock file generation. Sometimes this causes problems, for example if the file contains placeholder values, so you can configure this to true and Renovate will ignore any .npmrc files it finds and temporarily remove the file before running npm install or yarn install . Renovate will try to configure this to true also if you have configured any npmrc string within your config file. ignorePaths Skip any package file whose path matches one of these. Can be a string or glob pattern. Name Value type array subType string Using this setting, you can selectively ignore package files that you don't want Renovate autodiscovering. For instance if your repository has an \"examples\" directory of many package.json files that you don't want to be kept up to date. ignorePrAuthor Set to true to fetch the entire list of PRs instead of only those authored by the Renovate user. Name Value type boolean default false This is usually needed if someone needs to migrate bot accounts, including from hosted app to self-hosted. If ignorePrAuthor is configured to true, it means Renovate will fetch the entire list of repository PRs instead of optimizing to fetch only those PRs which it created itself. You should only want to enable this if you are changing the bot account (e.g. from @old-bot to @new-bot ) and want @new-bot to find and update any existing PRs created by @old-bot . It's recommended to revert this setting once that transition period is over and all old PRs are resolved. ignorePresets A list of presets to ignore, including nested ones inside extends . Name Value type array subType string Use this if you are extending a complex preset but don't want to use every \"sub preset\" that it includes. For example, consider this config: { \"extends\": [\"config:base\"], \"ignorePresets\": [\":prHourlyLimit2\"] } It would take the entire \"config:base\" preset - which contains a lot of sub-presets - but ignore the \":prHourlyLimit2\" rule. ignoreScripts Configure this to true if trustLevel is high but you wish to skip running scripts when updating lock files. Name Value type boolean default false Applicable for npm and Composer only for now. Set this to true if running scripts causes problems. ignoreUnstable Ignore versions with unstable SemVer. Name Value type boolean default true By default, Renovate won't update any package versions to unstable versions (e.g. 4.0.0-rc3 ) unless the current version has the same major.minor.patch and was already unstable (e.g. it was already on 4.0.0-rc2 ). Renovate will also not \"jump\" unstable versions automatically, e.g. if you are on 4.0.0-rc2 and newer versions 4.0.0 and 4.1.0-alpha.1 exist then Renovate will update you to 4.0.0 only. If you need to force permanent unstable updates for a package, you can add a package rule setting ignoreUnstable to false . Also check out the followTag configuration option above if you wish Renovate to keep you pinned to a particular release tag. includeForks Whether to process forked repositories or not. By default, all forked repositories are skipped. Name Value type boolean default false By default, Renovate will skip over any repositories that are forked. This includes if the forked repository contain a Renovate config file, because Renovate can't tell if that file was added by the original repository or not. If you wish to enable processing of a forked repository by Renovate, you need to add \"includeForks\": true to your repository config or run the CLI command with --include-forks=true . If you are using the hosted WhiteSource Renovate then this option will be configured to true automatically if you \"Selected\" repositories individually but remain as false if you installed for \"All\" repositories. includePaths Include package files only within these defined paths. Name Value type array subType string If you wish for Renovate to process only select paths in the repository, use includePaths . Alternatively, if you need to just exclude certain paths in the repository then consider ignorePaths instead. If you are more interested in including only certain package managers (e.g. npm ), then consider enabledManagers instead. java Configuration object for all Java package managers. Name Value type object mergeable true Use this configuration option for shared config across all java projects (Gradle and Maven). js Configuration object for JavaScript language. Name Value type object mergeable true Use this configuration option for shared config across npm/Yarn/pnpm and meteor package managers. labels Labels to set in Pull Request. Name Value type array subType string By default, Renovate won't add any labels to its PRs. If you want Renovate to do so then define a labels array of one or more label strings. If you want the same label(s) for every PR then you can configure it at the top level of config. However you can also fully override them on a per-package basis. Consider this example: { \"labels\": [\"dependencies\"], \"packageRules\": [ { \"matchPackagePatterns\": [\"eslint\"], \"labels\": [\"linting\"] } ] } With the above config, every PR raised by Renovate will have the label dependencies while PRs containing eslint -related packages will instead have the label linting . lockFileMaintenance Configuration for lock file maintenance. Name Value type object mergeable true This feature can be used to refresh lock files and keep them up-to-date. \"Maintaining\" a lock file means recreating it so that every dependency version within it is updated to the latest. Supported lock files are package-lock.json , yarn.lock , composer.lock , Gemfile.lock , poetry.lock and Cargo.lock . Others may be added via feature request. This feature is disabled by default. If you wish to enable this feature then you could add this to your configuration: { \"lockFileMaintenance\": { \"enabled\": true } } To reduce \"noise\" in the repository, it defaults its schedule to \"before 5am on monday\" , i.e. to achieve once-per-week semantics. Depending on its running schedule, Renovate may run a few times within that time window - even possibly updating the lock file more than once - but it hopefully leaves enough time for tests to run and automerge to apply, if configured. major Configuration to apply when an update type is major. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to major updates. minor Configuration to apply when an update type is minor. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to minor updates. node Configuration object for Node version renovation. Name Value type object mergeable true Using this configuration option allows you to apply common configuration and policies across all Node.js version updates even if managed by different package managers ( npm , yarn , etc.). Check out our Node.js documentation for a comprehensive explanation of how the node option can be used. npmToken npm token used for authenticating with the default registry. Name Value type string default null See Private npm module support for details on how this is used. Typically you would encrypt it and put it inside the encrypted object. npmrc String copy of npmrc file. Use \\n instead of line breaks. Name Value type string default null See Private npm module support for details on how this is used. packageRules Rules for matching package names. Name Value type array mergeable true packageRules is a powerful feature that lets you apply rules to individual packages or to groups of packages using regex pattern matching. Here is an example if you want to group together all packages starting with eslint into a single branch/PR: { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"groupName\": \"eslint packages\" } ] } Note how the above uses matchPackagePatterns with a regex value. Here is an example where you might want to limit the \"noisy\" package aws-sdk to updates just once per week: { \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"schedule\": [\"after 9pm on sunday\"] } ] } For Maven dependencies, the package name is <groupId:artefactId> , eg \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"] Note how the above uses matchPackageNames instead of matchPackagePatterns because it is an exact match package name. This is the equivalent of defining \"matchPackagePatterns\": [\"^aws\\-sdk$\"] and hence much simpler. However you can mix together both matchPackageNames and matchPackagePatterns in the same package rule and the rule will be applied if either match. Example: { \"packageRules\": [ { \"matchPackageNames\": [\"neutrino\"], \"matchPackagePatterns\": [\"^@neutrino/\"], \"groupName\": \"neutrino monorepo\" } ] } The above rule will group together the neutrino package and any package matching @neutrino/* . Path rules are convenient to use if you wish to apply configuration rules to certain package files using patterns. For example, if you have an examples directory and you want all updates to those examples to use the chore prefix instead of fix , then you could add this configuration: { \"packageRules\": [ { \"matchPaths\": [\"examples/**\"], \"extends\": [\":semanticCommitTypeAll(chore)\"] } ] } If you wish to limit renovate to apply configuration rules to certain files in the root repository directory, you have to use matchPaths with either a partial string match or a minimatch pattern. For example you have multiple package.json and want to use dependencyDashboardApproval only on the root package.json : { \"packageRules\": [ { \"matchPaths\": [\"+(package.json)\"], \"dependencyDashboardApproval\": true } ] } Important to know: Renovate will evaluate all packageRules and not stop once it gets a first match. Therefore, you should order your packageRules in order of importance so that later rules can override settings from earlier rules if necessary. allowedVersions A version range or regex pattern capturing allowed versions for dependencies. Name Value type string parent packageRules default null Use this - usually within a packageRule - to limit how far to upgrade a dependency. For example, if you wish to upgrade to Angular v1.5 but not to angular v1.6 or higher, you could define this to be <= 1.5 or < 1.6.0 : { \"packageRules\": [ { \"matchPackageNames\": [\"angular\"], \"allowedVersions\": \"<=1.5\" } ] } The valid syntax for this will be calculated at runtime because it depends on the versioning scheme, which is itself dynamic. This field also supports Regular Expressions if they begin and end with / . For example, the following will enforce that only 3 or 4-section versions are supported, without any prefixes: { \"packageRules\": [ { \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"], \"allowedVersions\": \"/^[0-9]+\\\\.[0-9]+\\\\.[0-9]+(\\\\.[0-9]+)?$/\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\": [ { \"matchPackageNames\": [\"chalk\"], \"allowedVersions\": \"!/java$/\" } ] } matchDepTypes List of depTypes to match (e.g. [ peerDependencies ]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to limit a packageRule to certain depType values. Invalid if used outside of a packageRule . excludePackageNames Package names to exclude. Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Important : Do not mix this up with the option ignoreDeps . Use ignoreDeps instead if all you want to do is have a list of package names for Renovate to ignore. Use excludePackageNames if you want to have one or more exact name matches excluded in your package rule. See also matchPackageNames . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"excludePackageNames\": [\"eslint-foo\"] } ] } The above will match all package names starting with eslint but exclude the specific package eslint-foo . excludePackagePatterns Package name patterns to exclude. Valid only within packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package name patterns excluded in your package rule. See also matchPackagePatterns . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"excludePackagePatterns\": [\"^eslint-foo\"] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo . matchLanguages List of languages to match (e.g. [\"python\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular language. e.g. { \"packageRules\": [ { \"matchPackageNames\": [\"request\"], \"matchLanguages\": [\"python\"], \"enabled\": false } ] } matchBaseBranches List of branches to match (e.g. [\"master\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular branch. e.g. { \"packageRules\": [ { \"matchBaseBranches\": [\"master\"], \"excludePackagePatterns\": [\"^eslint\"], \"enabled\": false } ] } matchManagers List of package managers to match (e.g. [\"pipenv\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular package manager. e.g. { \"packageRules\": [ { \"matchPackageNames\": [\"node\"], \"matchManagers\": [\"dockerfile\"], \"enabled\": false } ] } matchDatasources List of datasources to match (e.g. [\"orb\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular datasource. e.g. { \"packageRules\": [ { \"matchDatasources\": [\"orb\"], \"labels\": [\"circleci-orb!!\"] } ] } matchCurrentVersion A version or version range to match against the current version of a package. Valid only within packageRules object. Name Value type string parent packageRules mergeable true default null matchCurrentVersion can be an exact semver version or a semver range. This field also supports Regular Expressions which have to begin and end with / . For example, the following will enforce that only 1.* versions: { \"packageRules\": [ { \"matchPackagePatterns\": [\"io.github.resilience4j\"], \"matchCurrentVersion\": \"/^1\\\\./\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\": [ { \"matchPackagePatterns\": [\"io.github.resilience4j\"], \"matchCurrentVersion\": \"!/^0\\\\./\" } ] } matchFiles List of strings to do an exact match against package files with full path. Applicable inside packageRules only. Name Value type array subType string parent packageRules Renovate will compare matchFiles for an exact match against the dependency's package file or lock file. For example the following would match package.json but not package/frontend/package.json : \"matchFiles\": [\"package.json\"], Use matchPaths instead if you need more flexible matching. matchPackageNames Package names to match. Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more exact name matches in your package rule. See also excludePackageNames . { \"packageRules\": [ { \"matchPackageNames\": [\"angular\"], \"rangeStrategy\": \"pin\" } ] } The above will configure rangeStrategy to pin only for the package angular . matchPackagePatterns Package name patterns to match. Valid only within packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package names patterns in your package rule. See also excludePackagePatterns . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^angular\"], \"rangeStrategy\": \"replace\" } ] } The above will configure rangeStrategy to replace for any package starting with angular . matchPaths List of strings or glob patterns to match against package files. Applicable inside packageRules only. Name Value type array subType string parent packageRules Renovate will match matchPaths against both a partial string match or a minimatch glob pattern. If you want to avoid the partial string matching so that only glob matching is performed, wrap your string in +(...) like so: \"matchPaths\": [\"+(package.json)\"], The above will match only the root package.json , whereas the following would match any package.json in any subdirectory too: \"matchPaths\": [\"package.json\"], matchSourceUrlPrefixes A list of source URL prefixes to match against, commonly used for grouping of monorepos or packages from the same organization. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to group together all packages from the Vue monorepo: { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [\"https://github.com/vuejs/vue\"], \"groupName\": \"Vue monorepo packages\" } ] } Here's an example of where you use this to group together all packages from the renovatebot github org: { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [\"https://github.com/renovatebot/\"], \"groupName\": \"All renovate packages\" } ] } matchUpdateTypes Update types to match against (major, minor, pin, etc). Valid only within packageRules object. Name Value type array subType string allowedValues major,minor,patch,pin,digest,lockFileMaintenance,rollback,bump parent packageRules mergeable true Use this field to match rules against types of updates. For example to apply a special label for Major updates: { \"packageRules\": [ { \"matchUpdateTypes\": [\"major\"], \"labels\": [\"UPDATE-MAJOR\"] } ] } patch Configuration to apply when an update type is patch. Only applies if separateMinorPatch is set to true. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to patch updates. Only applies if separateMinorPatch is set to true. php Configuration object for PHP. Name Value type object mergeable true pin Configuration to apply when an update type is pin. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to PRs that pin dependencies. pinDigests Whether to add digests to Dockerfile source images. Name Value type boolean default false If enabled Renovate will pin Docker images by means of their SHA256 digest and not only by tag so that they are immutable. postUpdateOptions Enable post-update options to be run after package/artifact updating. Name Value type array allowedValues gomodTidy,npmDedupe,yarnDedupeFewer,yarnDedupeHighest mergeable true gomodTidy : Run go mod tidy after Go module updates npmDedupe : Run npm dedupe after package-lock.json updates yarnDedupeFewer : Run yarn-deduplicate --strategy fewer after yarn.lock updates yarnDedupeHighest : Run yarn-deduplicate --strategy highest ( yarn dedupe --strategy highest for Yarn >=2.2.0) after yarn.lock updates postUpgradeTasks Post-upgrade tasks that are executed before a commit is made by Renovate. Name Value type object Post-upgrade tasks are commands that are executed by Renovate after a dependency has been updated but before the commit is created. The intention is to run any additional command line tools that would modify existing files or generate new files when a dependency changes. This is only available on Renovate instances that have a trustLevel of 'high'. Each command must match at least one of the patterns defined in allowedPostUpgradeTasks in order to be executed. If the list of allowed tasks is empty then no tasks will be executed. e.g. { \"postUpgradeTasks\": { \"commands\": [\"tslint --fix\"], \"fileFilters\": [\"yarn.lock\", \"**/*.js\"] } } The postUpgradeTasks configuration consists of two fields: commands A list of post-upgrade commands that are executed before a commit is made by Renovate. Name Value type array subType string parent postUpgradeTasks A list of commands that are executed after Renovate has updated a dependency but before the commit it made fileFilters Files that match these glob patterns will be committed if they are present after running a post-upgrade task. Name Value type array subType string parent postUpgradeTasks A list of glob-style matchers that determine which files will be included in the final commit made by Renovate prBodyColumns List of columns to use in PR bodies. Name Value type array subType string Use this array to provide a list of column names you wish to include in the PR tables. For example, if you wish to add the package file name to the table, you would add this to your config: { \"prBodyColumns\": [ \"Package\", \"Update\", \"Type\", \"New value\", \"Package file\", \"References\" ] } Note: \"Package file\" is predefined in the default prBodyDefinitions object so does not require a definition before it can be used. prBodyDefinitions Table column definitions for use in PR tables. Name Value type object freeChoice true mergeable true You can configure this object to either (a) modify the template for an existing table column in PR bodies, or (b) you wish to add a definition for a new/additional column. Here is an example of modifying the default value for the \"Package\" column to put it inside a <code></code> block: { \"prBodyDefinitions\": { \"Package\": \"`{{{depName}}}`\" } } Here is an example of adding a custom \"Sourcegraph\" column definition: { \"prBodyDefinitions\": { \"Sourcegraph\": \"[![code search for \\\"{{{depName}}}\\\"](https://sourcegraph.com/search/badge?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}}&label=matches)](https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}})\" }, \"prBodyColumns\": [ \"Package\", \"Update\", \"New value\", \"References\", \"Sourcegraph\" ] } Note: Columns must also be included in the prBodyColumns array in order to be used, so that's why it's included above in the example. prBodyNotes List of additional notes/templates to be included in the Pull Request bodies. Name Value type array subType string mergeable true Use this field to add custom content inside PR bodies, including conditionally. e.g. if you wish to add an extra Warning to major updates: { \"prBodyNotes\": [\"{{#if isMajor}}:warning: MAJOR MAJOR MAJOR :warning:{{/if}}\"] } prBodyTemplate Pull Request body template. Controls which sections are rendered in the body. Name Value type string default \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{controls}}}{{{footer}}}\" This setting controls which sections are rendered in the body of the pull request. The available sections are header, table, notes, changelogs, configDescription, controls, footer. prConcurrentLimit Limit to a maximum of x concurrent branches/PRs. 0 (default) means no limit. Name Value type integer default 0 This setting - if enabled - limits Renovate to a maximum of x concurrent PRs open at any time. Note that this limit is enforced on a per-repository basis. prCreation When to create the PR for a branch. Name Value type string allowedValues immediate,not-pending,status-success,approval default \"immediate\" This setting tells Renovate when you would like it to raise PRs: immediate (default): Renovate will create PRs immediately after creating the corresponding branch not-pending : Renovate will wait until status checks have completed (passed or failed) before raising the PR status-success : Renovate won't raise PRs unless tests pass Renovate defaults to immediate but some like to change to not-pending . If you configure to immediate, it means you will usually get GitHub notifications that a new PR is available but if you view it immediately then it will still have \"pending\" tests so you can't take any action. With not-pending , it means that when you receive the PR notification, you can see if it passed or failed and take action immediately. Therefore you can customise this setting if you wish to be notified a little later in order to reduce \"noise\". prFooter Any text added here will be placed last in the PR body, with a divider separator before it. Name Value type string default \"This PR has been generated by [Renovate Bot](https://github.com/renovatebot/renovate).\" prHeader Any text added here will be placed first in the PR body. Name Value type string default null prHourlyLimit Rate limit PRs to maximum x created per hour. 0 (default) means no limit. Name Value type integer default 0 This setting - if enabled - helps slow down Renovate, particularly during the onboarding phase. What may happen without this setting is: Onboarding PR is created User merges onboarding PR to activate Renovate Renovate creates a \"Pin Dependencies\" PR (if necessary) User merges Pin PR Renovate then creates every single upgrade PR necessary - potentially dozens The above can result in swamping CI systems, as well as a lot of retesting if branches need to be rebased every time one is merged. Instead, if prHourlyLimit is configure to a value like 1 or 2, it will mean that Renovate creates at most that many new PRs within each hourly period (:00-:59). So the project should still result in all PRs created perhaps within the first 24 hours maximum, but at a rate that may allow users to merge them once they pass tests. It does not place a limit on the number of concurrently open PRs - only on the rate they are created. Note that this limit is enforced on a per-repository basis. prNotPendingHours Timeout in hours for when prCreation=not-pending. Name Value type integer default 25 If you configure prCreation=not-pending , then Renovate will wait until tests are non-pending (all pass or at least one fails) before creating PRs. However there are cases where PRs may remain in pending state forever, e.g. absence of tests or status checks that are configure to pending indefinitely. Therefore we configure an upper limit for how long we wait until creating a PR. Note: if the option stabilityDays is non-zero then Renovate will disable the prNotPendingHours functionality. prPriority Set sorting priority for PR creation. PRs with higher priority are created first, negative priority last. Name Value type integer default 0 Sometimes Renovate needs to rate limit its creation of PRs, e.g. hourly or concurrent PR limits. In such cases it sorts/prioritizes by default based on the update type (e.g. patches raised before minor, minor before major). If you have dependencies that are more or less important than others then you can use the prPriority field for PR sorting. The default value is 0, so therefore setting a negative value will make dependencies sort last, while higher values sort first. Here's an example of how you would define PR priority so that devDependencies are raised last and react is raised first: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"prPriority\": -1 }, { \"matchPackageNames\": [\"react\"], \"prPriority\": 5 } ] } prTitle Pull Request title template (deprecated). Now uses commitMessage. Name Value type string The PR title is important for some of Renovate's matching algorithms (e.g. determining whether to recreate a PR or not) so ideally don't modify it much. pruneStaleBranches Enable or disable pruning of stale branches. Name Value type boolean default true Configure to false to disable deleting orphan branches and autoclosing PRs. Defaults to true . python Configuration object for Python. Name Value type object mergeable true Currently the only Python package manager is pip - specifically for requirements.txt and requirements.pip files - so adding any config to this python object is essentially the same as adding it to the pip_requirements object instead. rangeStrategy Policy for how to modify/update existing ranges. Name Value type string default \"replace\" allowedValues auto,pin,bump,replace,widen,update-lockfile Behavior: auto = Renovate decides (this will be done on a manager-by-manager basis) pin = convert ranges to exact versions, e.g. ^1.0.0 -> 1.1.0 bump = e.g. bump the range even if the new version satisfies the existing range, e.g. ^1.0.0 -> ^1.1.0 replace = Replace the range with a newer one if the new version falls outside it, e.g. ^1.0.0 -> ^2.0.0 widen = Widen the range with newer one, e.g. ^1.0.0 -> ^1.0.0 || ^2.0.0 update-lockfile = Update the lock file when in-range updates are available, otherwise replace for updates out of range. Works for bundler , composer , npm , yarn and poetry so far Renovate's \"auto\" strategy works like this for npm: Always pin devDependencies Pin dependencies if we detect that it's an app and not a library Widen peerDependencies If an existing range already ends with an \"or\" operator - e.g. \"^1.0.0 || ^2.0.0\" - then Renovate will widen it, e.g. making it into \"^1.0.0 || ^2.0.0 || ^3.0.0\" Otherwise, replace the range. e.g. \"^2.0.0\" would be replaced by \"^3.0.0\" By default, Renovate assumes that if you are using ranges then it's because you want them to be wide/open. As such, Renovate won't deliberately \"narrow\" any range by increasing the semver value inside. For example, if your package.json specifies a value for left-pad of ^1.0.0 and the latest version on npmjs is 1.2.0 , then Renovate won't change anything because 1.2.0 satisfies the range. If instead you'd prefer to be updated to ^1.2.0 in cases like this, then configure rangeStrategy to bump in your Renovate config. This feature supports simple caret ( ^ ) and tilde ( ~ ) ranges only, like ^1.0.0 and ~1.0.0 . rebaseLabel Label to use to request the bot to rebase a PR manually. Name Value type string default \"rebase\" On supported platforms it is possible to add a label to a PR to manually request Renovate to recreate/rebase it. By default this label is \"rebase\" however you can configure it to anything you want by changing this rebaseLabel field. rebaseWhen Control when Renovate decides to rebase an existing branch. Name Value type string allowedValues auto,never,conflicted,behind-base-branch default \"auto\" Possible values and meanings: auto : Renovate will autodetect the best setting. Defaults to conflicted unless the repository has a setting requiring PRs to be up to date with the base branch never : Renovate will never rebase the branch conflicted : Renovate will rebase only if the branch is conflicted behind-base-branch : Renovate will rebase whenever the branch falls 1 or more commit behind its base branch rebaseWhen=conflicted is not recommended if you have enabled Renovate automerge, because: It could result in a broken base branch if two updates are merged one after another without testing the new versions together If you have enforced that PRs must be up-to-date before merging (e.g. using branch protection on GitHub), then automerge won't be possible as soon as a PR gets out-of-date but remains non-conflicted recreateClosed Recreate PRs even if same ones were closed previously. Name Value type boolean default false By default, Renovate will detect if it has proposed an update to a project before and not propose the same one again. For example the Webpack 3.x case described above. This field lets you customise this behavior down to a per-package level. For example we override it to true in the following cases where branch names and PR titles need to be reused: Package groups When pinning versions Lock file maintenance Typically you shouldn't need to modify this setting. regexManagers Custom managers using regex matching. Name Value type array subType object mergeable true regexManagers entries are used to configure the regex Manager in Renovate. Users can define custom managers for cases such as: Proprietary file formats or conventions Popular file formats not yet supported as a manager by Renovate The custom manager concept is based on using Regular Expression named capture groups. For the fields datasource , depName and currentValue , it's mandatory to have either a named capture group matching them (e.g. (?<depName>.*) ) or to configure it's corresponding template (e.g. depNameTemplate ). It's not recommended to do both, due to the potential for confusion. It is recommended to also include versioning however if it is missing then it will default to semver . For more details and examples, see the documentation page the for the regex manager here . For template fields, use the triple brace {{{ }}} notation to avoid Handlebars escaping any special characters. matchStrings Regex capture rule to use. Valid only within a regexManagers object. Name Value type array subType string format regex parent regexManagers matchStrings should each be a valid regular expression, optionally with named capture groups. Currently only a length of one matchString is supported. Example: { \"matchStrings\": [ \"ENV .*?_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)\\\\s\" ] } matchStringsStrategy Strategy how to interpret matchStrings. Name Value type string default \"any\" allowedValues any,recursive,combination parent regexManagers matchStringsStrategy controls behavior when multiple matchStrings values are provided. Three options are available: any (default) recursive combination any Each provided matchString will be matched individually to the content of the packageFile . If a matchString has multiple matches in a file each will be interpreted as an independent dependency. As example the following configuration will update all 3 lines in the Dockerfile. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStringsStrategy\": \"any\", \"matchStrings\": [ \"ENV [A-Z]+_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)(\\\\&versioning=(?<versioning>.*?))?\\\\s\", \"FROM (?<depName>\\\\S*):(?<currentValue>\\\\S*)\" ], \"datasourceTemplate\": \"docker\" } ] } a Dockerfile: FROM amd64/ubuntu:18.04 ENV GRADLE_VERSION=6.2 # gradle-version/gradle&versioning=maven ENV NODE_VERSION=10.19.0 # github-tags/nodejs/node&versioning=node recursive If using recursive the matchStrings will be looped through and the full match of the last will define the range of the next one. This can be used to narrow down the search area to prevent multiple matches. However, the recursive strategy still allows the matching of multiple dependencies as described below. All matches of the first matchStrings pattern are detected, then each of these matches will used as basis be used as the input for the next matchStrings pattern, and so on. If the next matchStrings pattern has multiple matches then it will split again. This process will be followed as long there is a match plus a next matchingStrings pattern is available or a dependency is detected. This is an example how this can work. The first regex manager will only upgrade grafana/loki as looks for the backup key then looks for the test key and then uses this result for extraction of necessary attributes. However, the second regex manager will upgrade both definitions as its first matchStrings matches both test keys. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^example.json$\"], \"matchStringsStrategy\": \"recursive\", \"matchStrings\": [ \"\\\"backup\\\":\\\\s*{[^}]*}\", \"\\\"test\\\":\\\\s*\\\\{[^}]*}\", \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\": \"docker\" }, { \"fileMatch\": [\"^example.json$\"], \"matchStringsStrategy\": \"recursive\", \"matchStrings\": [ \"\\\"test\\\":\\\\s*\\\\{[^}]*}\", \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\": \"docker\" } ] } example.json: { \"backup\": { \"test\": { \"name\": \"grafana/loki\", \"type\": \"docker\", \"value\": \"1.6.1\" } }, \"setup\": { \"test\": { \"name\": \"python\", \"type\": \"docker\", \"value\": \"3.9.0\" } } } combination This option allows the possibility to combine the values of multiple lines inside a file. While using multiple lines is also possible using both other matchStringStrategy values, the combination approach is less susceptible to white space or line breaks stopping a match. combination will only match at most one dependency per file, so if you want to update multiple dependencies using combination you have to define multiple regex managers. Matched group values will be merged to form a single dependency. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^main.yml$\"], \"matchStringsStrategy\": \"combination\", \"matchStrings\": [ \"prometheus_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\", \"prometheus_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\": \"docker\" }, { \"fileMatch\": [\"^main.yml$\"], \"matchStringsStrategy\": \"combination\", \"matchStrings\": [ \"thanos_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\", \"thanos_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\": \"docker\" } ] } Ansible variable file ( yaml ): prometheus_image: \"prom/prometheus\" // a comment prometheus_version: \"v2.21.0\" // a comment ------ thanos_image: \"prom/prometheus\" // a comment thanos_version: \"0.15.0\" // a comment In the above example, each regex manager will match a single dependency each. depNameTemplate Optional depName for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depName cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result. lookupNameTemplate Optional lookupName for extracted dependencies, else defaults to depName value. Valid only within a regexManagers object. Name Value type string parent regexManagers default null lookupName is used for looking up dependency versions. It will be compiled using Handlebars and the regex groups result. It will default to the value of depName if left unconfigured/undefined. datasourceTemplate Optional datasource for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the datasource for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. versioningTemplate Optional versioning for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the versioning for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. registryUrlTemplate Optional registry URL for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the registryUrls for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. registryUrls List of URLs to try for dependency lookup. Package manager specific. Name Value type array subType string Usually Renovate is able to either (a) use the default registries for a datasource, or (b) automatically detect during the manager extract phase which custom registries are in use. In case there is a need to configure them manually, it can be done using this registryUrls field, typically using packageUrls like so: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"registryUrls\": [\"https://docker.mycompany.domain\"] } ] } The field supports multiple URLs however it is datasource-dependent on whether only the first is used or multiple. requiredStatusChecks List of status checks that must pass before automerging. Set to null to enable automerging without tests. Name Value type array subType string Currently Renovate's default behavior is to only automerge if every status check has succeeded. Setting this option to null means that Renovate will ignore all status checks. You need to set this if you don't have any status checks but still want Renovate to automerge PRs. In future, this might be configurable to allow certain status checks to be ignored/required. See issue 1853 at the renovate repository for more details. respectLatest Ignore versions newer than npm \"latest\" version. Name Value type boolean default true Similar to ignoreUnstable , this option controls whether to update to versions that are greater than the version tagged as latest in the repository. By default, renovate will update to a version greater than latest only if the current version is itself past latest. reviewers Requested reviewers for Pull Requests (either username or email address depending on the platform). Name Value type array subType string Must be valid usernames. If on GitHub and assigning a team to review, use the prefix team: , e.g. provide a value like team:someteam . reviewersFromCodeOwners Determine reviewers based on configured code owners and changes in PR. Name Value type boolean default false If enabled Renovate will try to determine PR reviewers by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations. reviewersSampleSize Take a random sample of given size from reviewers. Name Value type integer Take a random sample of given size from reviewers. rollbackPrs Create PRs to roll back versions if the current version is not found in the registry. Name Value type boolean default false Configure this to false either globally, per-language, or per-package if you want to disable Renovate's behavior of generating rollback PRs when it can't find the current version on the registry anymore. ruby Configuration object for Ruby language. Name Value type object mergeable true rust Configuration option for Rust package management. Name Value type object mergeable true schedule Times of day/week to limit branch creation to. Name Value type array subType string The schedule option allows you to define times of week or month for Renovate updates. Running Renovate around the clock may seem too \"noisy\" for some projects and therefore schedule is a good way to reduce the noise by reducing the timeframe in which Renovate will operate on your repository. The default value for schedule is \"at any time\", which is functionally the same as declaring a null schedule. i.e. Renovate will run on the repository around the clock. The easiest way to define a schedule is to use a preset if one of them fits your requirements. See Schedule presets for details and feel free to request a new one in the source repository if you think others would benefit from it too. Otherwise, here are some text schedules that are known to work: every weekend before 5:00am after 10pm and before 5:00am after 10pm and before 5am every weekday on friday and saturday every 3 months on the first day of the month One example might be that you don't want Renovate to run during your typical business hours, so that your build machines don't get clogged up testing package.json updates. You could then configure a schedule like this at the repository level: { \"schedule\": [\"after 10pm and before 5am every weekday\", \"every weekend\"] } This would mean that Renovate can run for 7 hours each night plus all the time on weekends. This scheduling feature can also be particularly useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to only monthly updates, you could add this package rule: { \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"extends\": [\"schedule:monthly\"] } ] } Technical details: We mostly rely on the text parsing of the library later but only its concepts of \"days\", \"time_before\", and \"time_after\" (Renovate does not support scheduled minutes or \"at an exact time\" granularity). semanticCommitScope Commit scope to use if Semantic Commits are enabled. Name Value type string default \"deps\" By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"package\" then it will look like \"chore(package):\" . You can also use parentDir or baseDir to namespace your commits for monorepos e.g. \"{{parentDir}}\" . semanticCommitType Commit type to use if Semantic Commits is enabled. Name Value type string default \"chore\" By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"ci\" then it will look like \"ci(deps):\" . semanticCommits Enable Semantic Commit prefixes for commits and PR titles. Name Value type string allowedValues auto,enabled,disabled default \"auto\" If you are using a semantic prefix for your commits, then you will want to enable this setting. Although it's configurable to a package-level, it makes most sense to configure it at a repository level. If configured to enabled , then the semanticCommitScope and semanticCommitType fields will be used for each commit message and PR title. However, please note that Renovate will autodetect if your repository is already using semantic commits or not and follow suit, so you only really need to configure this if you wish to override Renovate's autodetected setting. separateMajorMinor If set to false, it will upgrade dependencies to latest release only, and not separate major/minor branches. Name Value type boolean default true Renovate's default behavior is to create a separate branch/PR if both minor and major version updates exist (note that your choice of rangeStrategy value can influence which updates exist in the first place however). For example, if you were using Webpack 2.0.0 and versions 2.1.0 and 3.0.0 were both available, then Renovate would create two PRs so that you have the choice whether to apply the minor update to 2.x or the major update of 3.x. If you were to apply the minor update then Renovate would keep updating the 3.x branch for you as well, e.g. if Webpack 3.0.1 or 3.1.0 were released. If instead you applied the 3.0.0 update then Renovate would clean up the unneeded 2.x branch for you on the next run. It is recommended that you leave this setting to true , because of the polite way that Renovate handles this. For example, let's say in the above example that you decided you wouldn't update to Webpack 3 for a long time and don't want to build/test every time a new 3.x version arrives. In that case, simply close the \"Update Webpack to version 3.x\" PR and it won't be recreated again even if subsequent Webpack 3.x versions are released. You can continue with Webpack 2.x for as long as you want and receive any updates/patches that are made for it. Then eventually when you do want to update to Webpack 3.x you can make that update to package.json yourself and commit it to master once it's tested. After that, Renovate will resume providing you updates to 3.x again! i.e. if you close a major upgrade PR then it won't come back again, but once you make the major upgrade yourself then Renovate will resume providing you with minor or patch updates. separateMinorPatch If set to true, it will separate minor and patch updates into separate branches. Name Value type boolean default false By default, Renovate won't distinguish between \"patch\" (e.g. 1.0.x) and \"minor\" (e.g. 1.x.0) releases - it groups them together. E.g., if you are running version 1.0.0 of a package and both versions 1.0.1 and 1.1.0 are available then Renovate will raise a single PR for version 1.1.0. If you wish to distinguish between patch and minor upgrades, for example if you wish to automerge patch but not minor, then you can configured this option to true . separateMultipleMajor If set to true, PRs will be raised separately for each available major upgrade version. Name Value type boolean default false Configure this to true if you wish to receive one PR for every separate major version upgrade of a dependency. e.g. if you are on webpack@v1 currently then default behavior is a PR for upgrading to webpack@v3 and not for webpack@v2. If this setting is true then you would get one PR for webpack@v2 and one for webpack@v3. stabilityDays Number of days required before a new release is considered to be stabilized. Name Value type integer default 0 If this is configured to a non-zero value, and an update has a release date/timestamp available, then Renovate will check if the configured \"stability days\" have elapsed. If the days since the release is less than the configured stability days then a \"pending\" status check will be added to the branch. If enough days have passed then a passing status check will be added. There are a couple of uses for this: Suppress branch/PR creation for X days If you combine stabilityDays=3 and prCreation=\"not-pending\" then Renovate will hold back from creating branches until 3 or more days have elapsed since the version was released. It's recommended that you enable dependencyDashboard=true so you don't lose visibility of these pending PRs. Await X days before Automerging If you have both automerge as well as stabilityDays enabled, it means that PRs will be created immediately but automerging will be delayed until X days have passed. This works because Renovate will add a \"renovate/stability-days\" pending status check to each branch/PR and that pending check will prevent the branch going green to automerge. supportPolicy Dependency support policy, e.g. used for LTS vs non-LTS etc (Node only). Name Value type array subType string Language support is limited to those listed below: Node.js - Read our Node.js documentation suppressNotifications Options to suppress various types of warnings and other notifications. Name Value type array subType string allowedValues prIgnoreNotification,branchAutomergeFailure,lockFileErrors,artifactErrors,deprecationWarningIssues,onboardingClose mergeable true Use this field to suppress various types of warnings and other notifications from Renovate. Example: { \"suppressNotifications\": [\"prIgnoreNotification\"] } The above config will suppress the comment which is added to a PR whenever you close a PR unmerged. timezone IANA Time Zone Name Value type string default null It is only recommended to configure this field if you wish to use the schedules feature and want to write them in your local timezone. Please see the above link for valid timezone names. transitiveRemediation Enable remediation of transitive dependencies. Name Value type boolean default false When enabled, Renovate will attempt to remediate vulnerabilities even if they exist only in transitive dependencies. Applicable only for GitHub platform (with vulnerability alerts enabled), npm manager, and when a package-lock.json v1 format is present. This is considered a feature flag with the aim to remove it and default to this behavior once it has been more widely tested. unicodeEmoji Enable or disable Unicode emoji. Name Value type boolean default true If enabled emoji shortcodes ( :warning: ) are replaced with their unicode equivalents ( \u26a0\ufe0f ) updateInternalDeps Whether to update internal dep versions in a monorepo (Lerna or Yarn Workspaces). Name Value type boolean default false Renovate defaults to skipping any internal package dependencies within monorepos. In such case dependency versions won't be updated by Renovate. To opt in to letting Renovate update internal package versions normally, set this configuration option to true. updateLockFiles Set to false to disable lock file updating. Name Value type boolean default true updateNotScheduled Whether to update (but not create) branches when not scheduled. Name Value type boolean default true When schedules are in use, it generally means \"no updates\". However there are cases where updates might be desirable - e.g. if you have configured prCreation=not-pending, or you have rebaseStale=true and master branch is updated so you want Renovate PRs to be rebased. This defaults to true , meaning that Renovate will perform certain \"desirable\" updates to existing PRs even when outside of schedule. If you wish to disable all updates outside of scheduled hours then configure this field to false . versioning Versioning to use for filtering and comparisons. Name Value type string allowedValues cargo,composer,docker,git,gradle,hashicorp,hex,ivy,loose,maven,node,npm,nuget,pep440,poetry,regex,ruby,semver,swift,ubuntu default \"semver\" Usually, each language or package manager has a specific type of \"versioning\". e.g. JavaScript uses npm's semver implementation, Python uses pep440, etc. At Renovate we have also implemented some of our own, such as \"docker\" to address the most common way people tag versions using Docker, and \"loose\" as a fallback that tries semver first but otherwise just does its best to sort and compare. By exposing versioning to config, it allows you to override the default versioning for a package manager if you really need. In most cases it would not be recommended, but there are some cases such as Docker or Gradle where versioning is not strictly defined and you may need to specify the versioning type per-package. vulnerabilityAlerts Config to apply when a PR is necessary due to vulnerability of existing package version. Name Value type object mergeable true Use this object to customise PRs that are raised when vulnerability alerts are detected (GitHub-only). For example, to configure custom labels and assignees: { \"vulnerabilityAlerts\": { \"labels\": [\"security\"], \"assignees\": [\"@rarkins\"] } } To disable vulnerability alerts completely, configure like this: { \"vulnerabilityAlerts\": { \"enabled\": false } } yarnrc String copy of yarnrc file. Use \\n instead of line breaks. Name Value type string default null","title":"Configuration Options"},{"location":"configuration-options/#configuration-options","text":"This document describes all the configuration options you may configure in a Renovate configuration file. Any config you define applies to the whole repository (e.g. if you have a monorepo). You can store your Renovate configuration file in one of the following locations: .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc.json renovate.json renovate.json5 .renovaterc package.json (within a \"renovate\" section) Renovate always uses the config from the repository's default branch, even if that configuration specifies multiple baseBranches . Renovate does not read/override the config from within each base branch if present. Also, be sure to check out Renovate's shareable config presets to save yourself from reinventing any wheels. If you have any questions about the config options, or want to get help/feedback about a config, go to the discussions tab in the Renovate repository and start a new \"config help\" discussion. We will do our best to answer your question(s).","title":"Configuration Options"},{"location":"configuration-options/#addlabels","text":"Labels to add to Pull Request. Name Value type array subType string mergeable true The labels field is non-mergeable, meaning that any config setting a list of PR labels will replace any existing list. If you want to append labels for matched rules, then define an addLabels array with one (or more) label strings. All matched addLabels strings will be attached to the PR. Consider this example: { \"labels\": [\"dependencies\"], \"packageRules\": [ { \"matchPackagePatterns\": [\"eslint\"], \"labels\": [\"linting\"] }, { \"matchDepTypes\": [\"optionalDependencies\"], \"addLabels\": [\"optional\"] } ] } With the above config: Optional dependencies will have the labels dependencies and optional ESLint dependencies will have the label linting All other dependencies will have the label dependencies","title":"addLabels"},{"location":"configuration-options/#additionalbranchprefix","text":"Additional string value to be appended to branchPrefix. Name Value type string default \"\" This value defaults to an empty string, and is typically not necessary. Some managers populate this field for historical reasons, for example we use docker- for Docker branches, so they may look like renovate/docker-ubuntu-16.x . You normally don't need to configure this, but one example where it can be useful is combining with parentDir in monorepos to split PRs based on where the package definition is located, e.g. { \"additionalBranchPrefix\": \"{{parentDir}}-\" }","title":"additionalBranchPrefix"},{"location":"configuration-options/#additionalreviewers","text":"Additional reviewers for Pull Requests (in contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it). Name Value type array subType string mergeable true In contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it. This makes it suitable for augmenting a preset or base list without displacing the original, for example when adding focused reviewers for a specific package group.","title":"additionalReviewers"},{"location":"configuration-options/#aliases","text":"Aliases for registries, package manager specific. Name Value type object additionalProperties [object Object] The aliases object is used for configuring registry aliases. Currently it is needed/supported for the helm-requirements manager only. helm-requirements includes this default alias: { \"aliases\": { \"stable\": \"https://charts.helm.sh/stable\" } } Alias values must be properly formatted URIs.","title":"aliases"},{"location":"configuration-options/#assignautomerge","text":"Assign reviewers and assignees even if the PR is to be automerged. Name Value type boolean default false By default, Renovate will not assign reviewers and assignees to an automerge-enabled PR unless it fails status checks. By configuring this setting to true , Renovate will instead always assign reviewers and assignees for automerging PRs at time of creation.","title":"assignAutomerge"},{"location":"configuration-options/#assignees","text":"Assignees for Pull Request (either username or email address depending on the platform). Name Value type array subType string Must be valid usernames on the platform in use.","title":"assignees"},{"location":"configuration-options/#assigneesfromcodeowners","text":"Determine assignees based on configured code owners and changes in PR. Name Value type boolean default false If enabled Renovate will try to determine PR assignees by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations.","title":"assigneesFromCodeOwners"},{"location":"configuration-options/#assigneessamplesize","text":"Take a random sample of given size from assignees. Name Value type integer If configured, Renovate will take a random sample of given size from assignees and assign them only, instead of assigning the entire list of assignees you have configured.","title":"assigneesSampleSize"},{"location":"configuration-options/#automerge","text":"Whether to automerge branches/PRs automatically, without human intervention. Name Value type boolean default false By default, Renovate raises PRs but leaves them to someone or something else to merge them. By configuring this setting, you can enable Renovate to automerge PRs or even branches itself, therefore reducing the amount of human intervention required. Usually you won't want to automerge all PRs, for example most people would want to leave major dependency updates to a human to review first. You could configure Renovate to automerge all but major this way: { \"packageRules\": [ { \"matchUpdateTypes\": [\"minor\", \"patch\", \"pin\", \"digest\"], \"automerge\": true } ] } Also note that this option can be combined with other nested settings, such as dependency type. So for example you could elect to automerge all (passing) devDependencies only this way: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"automerge\": true } ] } Important: Renovate won't automerge on GitHub if a PR has a negative review outstanding. Note: on Azure there can be a delay between a PR being set as completed by Renovate, and Azure merging the PR / finishing its tasks. Renovate will try to delay until Azure is in the expected state, however if it takes too long it will continue. In some cases this can result in a dependency not being merged, and a fresh PR being created for the dependency.","title":"automerge"},{"location":"configuration-options/#automergecomment","text":"PR comment to add to trigger automerge. Used only if automergeType=pr-comment. Name Value type string default \"automergeComment\" Use this only if you configure automergeType=\"pr-comment\" . Example use: { \"automerge\": true, \"automergeType\": \"pr-comment\", \"automergeComment\": \"bors: r+\" }","title":"automergeComment"},{"location":"configuration-options/#automergetype","text":"How to automerge, if enabled. Name Value type string allowedValues branch,pr,pr-comment default \"pr\" This setting is only applicable if you opt in to configure automerge to true for any of your dependencies. Automerging defaults to using Pull Requests ( automergeType=\"pr\" ). In that case Renovate first creates a branch and associated Pull Request, and then automerges the PR on a subsequent run once it detects the PR's status checks are \"green\". If by the next run the PR is already behind master branch then it will be automatically rebased, because Renovate only automerges branches which are up-to-date and green. If Renovate is scheduled for hourly runs on the repository but commits are made every 15 minutes to the main branch, then an automerge like this will keep getting deferred with every rebase. Note: if you have no tests but still want Renovate to automerge, you need to add \"requiredStatusChecks\": null to your configuration. If you prefer that Renovate more silently automerge without Pull Requests at all, you can configure \"automergeType\": \"branch\" . In this case Renovate will: Create the branch, wait for test results Rebase it any time it gets out of date with the base branch Automerge the branch commit if it's: (a) up-to-date with the base branch, and (b) passing all tests As a backup, raise a PR only if either: (a) tests fail, or (b) tests remain pending for too long (default: 24 hours) The final value for automergeType is \"pr-comment\" , intended only for users who already have a \"merge bot\" such as bors-ng and want Renovate to not actually automerge by itself and instead tell bors-ng to merge for it, by using a comment in the PR. If you're not already using bors-ng or similar, don't worry about this option.","title":"automergeType"},{"location":"configuration-options/#azureautocomplete","text":"If set to true, Azure DevOps PRs will be set to auto-complete after all (if any) branch policies have been met. Name Value type boolean default false Setting this to true will configure PRs in Azure DevOps to auto-complete after all (if any) branch policies have been met. You can also configure this using packageRules if you want to use it selectively (e.g. per-package).","title":"azureAutoComplete"},{"location":"configuration-options/#azureworkitemid","text":"The id of an existing work item on Azure Boards to link to each PR. Name Value type integer default 0 When creating a PR in Azure DevOps, some branches can be protected with branch policies to check for linked work items . Creating a work item in Azure DevOps is beyond the scope of Renovate, but Renovate can link an already existing work item when creating PRs.","title":"azureWorkItemId"},{"location":"configuration-options/#basebranches","text":"An array of one or more custom base branches to be processed. If left empty, the default branch will be chosen. Name Value type array By default, Renovate will detect and process only the repository's default branch, e.g. master . For most projects, this is the expected approach. However, Renovate also allows users to explicitly configure baseBranches , e.g. for use cases such as: You wish Renovate to process only a non-default branch, e.g. dev : \"baseBranches\": [\"dev\"] You have multiple release streams you need Renovate to keep up to date, e.g. in branches master and next : \"baseBranches\": [\"master\", \"next\"] It's possible to add this setting into the renovate.json file as part of the \"Configure Renovate\" onboarding PR. If so then Renovate will reflect this setting in its description and use package file contents from the custom base branch(es) instead of default.","title":"baseBranches"},{"location":"configuration-options/#bbusedefaultreviewers","text":"Use the default reviewers (Bitbucket only). Name Value type boolean default true Configuring this to true means that Renovate will detect and apply the default reviewers rules to PRs (Bitbucket only).","title":"bbUseDefaultReviewers"},{"location":"configuration-options/#branchconcurrentlimit","text":"Limit to a maximum of x concurrent branches. 0 means no limit, null (default) inherits value from prConcurrentLimit . Name Value type integer By default, Renovate won't enforce any concurrent branch limits. If you want the same limit for both concurrent branches and concurrent PRs, then just set a value for prConcurrentLimit and it will be reused for branch calculations too. However, if you want to allow more concurrent branches than concurrent PRs, you can configure both values ( e.g. branchConcurrentLimit=5 and prConcurrentLimit=3 ). This limit is enforced on a per-repository basis. Example config: { \"branchConcurrentLimit\": 3 }","title":"branchConcurrentLimit"},{"location":"configuration-options/#branchname","text":"Branch name template. Name Value type string default \"{{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}}\" Warning: it's strongly recommended not to configure this field directly. Use at your own risk. If you truly need to configure this then it probably means either: You are hopefully mistaken, and there's a better approach you should use, so open a new \"config help\" discussion at the Renovate discussions tab or You have a use case we didn't anticipate and we should have a feature request from you to add it to the project","title":"branchName"},{"location":"configuration-options/#branchprefix","text":"Prefix to use for all branch names. Name Value type string default \"renovate/\" You can modify this field if you want to change the prefix used. For example if you want branches to be like deps/eslint-4.x instead of renovate/eslint-4.x then you configure branchPrefix = deps/ . Or if you wish to avoid forward slashes in branch names then you could use renovate_ instead, for example. branchPrefix must be configured at the root of the configuration (e.g. not within any package rule) and is not allowed to use template values. e.g. instead of renovate/{{parentDir}}- , configure the template part in additionalBranchPrefix , like \"additionalBranchPrefix\": \"{{parentDir}}-\" . Note that this setting does not change the default onboarding branch name, i.e. renovate/configure . If you wish to change that too, you need to also configure the field onboardingBranch in your admin bot config.","title":"branchPrefix"},{"location":"configuration-options/#branchtopic","text":"Branch topic. Name Value type string default \"{{{depNameSanitized}}}-{{{newMajor}}}{{#if isPatch}}.{{{newMinor}}}{{/if}}.x{{#if isLockfileUpdate}}-lockfile{{/if}}\" This field is combined with branchPrefix and additionalBranchPrefix to form the full branchName . branchName uniqueness is important for dependency update grouping or non-grouping so be cautious about ever editing this field manually. This is an advance field and it's recommend you seek a config review before applying it.","title":"branchTopic"},{"location":"configuration-options/#bumpversion","text":"Bump the version in the package file being updated. Name Value type string allowedValues major,minor,patch default null Currently this setting supports helmv3 , npm and sbt only, so raise a feature request if you have a use for it with other package managers. Its purpose is if you want Renovate to update the version field within your file's package.json any time it updates dependencies within. Usually this is for automatic release purposes, so that you don't need to add another step after Renovate before you can release a new version. Configure this value to \"patch\" , \"minor\" or \"major\" to have Renovate update the version in your edited package.json . e.g. if you wish Renovate to always increase the target package.json version with a patch update, configure this to \"patch\" . For npm only you can also configure this field to \"mirror:x\" where x is the name of a package in the package.json . Doing so means that the package.json version field will mirror whatever the version is that x depended on. Make sure that version is a pinned version of course, as otherwise it won't be valid.","title":"bumpVersion"},{"location":"configuration-options/#clonesubmodules","text":"Set to false to disable initialization of submodules during repository clone. Name Value type boolean default true","title":"cloneSubmodules"},{"location":"configuration-options/#commitbody","text":"Commit message body template. Will be appended to commit message, separated by two line returns. Name Value type string default null Configure this if you wish Renovate to add a commit body, otherwise Renovate just uses a regular single-line commit. For example, To add [skip ci] to every commit you could configure: { \"commitBody\": \"[skip ci]\" } Another example would be if you want to configure a DCO signoff to each commit.","title":"commitBody"},{"location":"configuration-options/#commitbodytable","text":"If enabled, append a table in the commit message body describing all updates in the commit. Name Value type boolean default false","title":"commitBodyTable"},{"location":"configuration-options/#commitmessage","text":"Message to use for commit messages and pull request titles. Name Value type string default \"{{{commitMessagePrefix}}} {{{commitMessageAction}}} {{{commitMessageTopic}}} {{{commitMessageExtra}}} {{{commitMessageSuffix}}}\" Editing of commitMessage directly is now deprecated and not recommended. Please instead edit the fields such as commitMessageAction , commitMessageExtra , etc.","title":"commitMessage"},{"location":"configuration-options/#commitmessageaction","text":"Action verb to use in commit messages and PR titles. Name Value type string default \"Update\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. Actions may be like Update , Pin , Roll back , Refresh , etc. Check out the default value for commitMessage to understand how this field is used.","title":"commitMessageAction"},{"location":"configuration-options/#commitmessageextra","text":"Extra description used after the commit message topic - typically the version. Name Value type string default \"to {{#if isMajor}}v{{{newMajor}}}{{else}}{{#if isSingleVersion}}v{{{newVersion}}}{{else}}{{{newValue}}}{{/if}}{{/if}}\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"extra\" is usually an identifier of the new version, e.g. \"to v1.3.2\" or \"to tag 9.2\".","title":"commitMessageExtra"},{"location":"configuration-options/#commitmessageprefix","text":"Prefix to add to start of commit messages and PR titles. Uses a semantic prefix if semanticCommits enabled. Name Value type string default null This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"prefix\" is usually an automatically applied semantic commit prefix, however it can also be statically configured.","title":"commitMessagePrefix"},{"location":"configuration-options/#commitmessagesuffix","text":"Suffix to add to end of commit messages and PR titles. Name Value type string default null This is used to add a suffix to commit messages. Usually left empty except for internal use (multiple base branches, and vulnerability alerts).","title":"commitMessageSuffix"},{"location":"configuration-options/#commitmessagetopic","text":"The upgrade topic/noun used in commit messages and PR titles. Name Value type string default \"dependency {{depName}}\" This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"topic\" is usually refers to the dependency being updated, e.g. \"dependency react\" .","title":"commitMessageTopic"},{"location":"configuration-options/#configwarningreuseissue","text":"Set this to false and Renovate will open each config warning in a new issue instead of reopening/reusing an existing issue. Name Value type boolean default true Renovate's default behavior is to reuse/reopen a single Config Warning issue in each repository so as to keep the \"noise\" down. However for some people this has the downside that the config warning won't be sorted near the top if you view issues by creation date. Configure this option to false if you prefer Renovate to open a new issue whenever there is a config warning.","title":"configWarningReuseIssue"},{"location":"configuration-options/#constraints","text":"Configuration object to define language or manager version constraints. Name Value type object mergeable true Constraints are used in package managers which use third party tools to update \"artifacts\" like lock files or checksum files. Typically, the constraint is detected automatically by Renovate from files within the repository and there is no need to manually configure it. Constraints are also used to manually restrict which datasource versions are possible to upgrade to based on their language support. For now this only supports python , other compatibility restrictions will be added in the future. { \"constraints\": { \"python\": \"2.7\" } } If you need to override constraints that Renovate detects from the repository, wrap it in the force object like so: { \"force\": { \"constraints\": { \"node\": \"< 15.0.0\" } } } Note: make sure not to mix this up with the term compatibility , which Renovate uses in the context of version releases, e.g. if a Docker image is node:12.16.0-alpine then the -alpine suffix represents compatibility .","title":"constraints"},{"location":"configuration-options/#dependencydashboard","text":"Whether to create a \"Dependency Dashboard\" issue within the repository. Name Value type boolean default false Configuring dependencyDashboard to true will lead to the creation of a \"Dependency Dashboard\" issue within the repository. This issue contains a list of all PRs pending, open, closed (unmerged) or in error. The goal of this issue is to give visibility into all updates that Renovate is managing. Examples of what having a Dependency Dashboard will allow you to do: View all PRs in one place, rather than having to filter PRs by author Rebase/retry multiple PRs without having to open each individually Override any rate limiting (e.g. concurrent PRs) or scheduling to force Renovate to create a PR that would otherwise be suppressed Recreate an unmerged PR (e.g. for a major update that you postponed by closing the original PR) Note: Enabling the Dependency Dashboard does not itself change any of the \"control flow\" of Renovate, e.g. it will otherwise still create and manage PRs exactly as it always has, including scheduling and rate limiting. The Dependency Dashboard therefore provides visibility as well as additional control.","title":"dependencyDashboard"},{"location":"configuration-options/#dependencydashboardapproval","text":"Whether updates should require manual approval from within the Dependency Dashboard issue before creation. Name Value type boolean default false This feature allows you to use Renovate's Dependency Dashboard to force approval of updates before they are created. By setting dependencyDashboardApproval to true in config (including within packageRules ), you can tell Renovate to wait for your approval from the Dependency Dashboard before creating a branch/PR. You can approve a pending PR by ticking the checkbox in the Dependency Dashboard issue. Note: When you set dependencyDashboardApproval to true the Dependency Dashboard issue will be created automatically, you do not need to turn on dependencyDashboard explictly. You can configure Renovate to wait for approval for: all package upgrades major, minor, patch level upgrades specific package upgrades upgrades coming from specific package managers If you want to approve all upgrades, set dependencyDashboardApproval to true : { \"dependencyDashboardApproval\": true } If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\": { \"dependencyDashboardApproval\": true } } If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\": [ { \"matchPackagePatterns\": [\"^@package-name\"], \"dependencyDashboardApproval\": true } ] }","title":"dependencyDashboardApproval"},{"location":"configuration-options/#dependencydashboardautoclose","text":"Set to true and Renovate will autoclose the Dependency Dashboard issue if there are no updates. Name Value type boolean default false You can configure this to true if you prefer Renovate to close an existing Dependency Dashboard whenever there are no outstanding PRs left.","title":"dependencyDashboardAutoclose"},{"location":"configuration-options/#dependencydashboardfooter","text":"Any text added here will be placed last in the Dependency Dashboard issue body, with a divider separator before it. Name Value type string default null","title":"dependencyDashboardFooter"},{"location":"configuration-options/#dependencydashboardheader","text":"Any text added here will be placed first in the Dependency Dashboard issue body. Name Value type string default \"This issue contains a list of Renovate updates and their statuses.\"","title":"dependencyDashboardHeader"},{"location":"configuration-options/#dependencydashboardtitle","text":"Title to use for the Dependency Dashboard issue. Name Value type string default \"Dependency Dashboard\" Configure this option if you prefer a different title for the Dependency Dashboard.","title":"dependencyDashboardTitle"},{"location":"configuration-options/#description","text":"Plain text description for a config or preset. Name Value type array subType string mergeable true The description field is used by config presets to describe what they do. They are then collated as part of the onboarding description.","title":"description"},{"location":"configuration-options/#digest","text":"Configuration to apply when updating a digest (no change in tag/version). Name Value type object mergeable true Add to this object if you wish to define rules that apply only to PRs that update Docker digests.","title":"digest"},{"location":"configuration-options/#docker","text":"Configuration object for Docker language. Name Value type object mergeable true Add config here if you wish it to apply to Docker package managers Dockerfile and Docker Compose. If instead you mean to apply settings to any package manager that updates using the Docker datasource , use a package rule instead, e.g. { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"labels\": [\"docker-update\"] } ] }","title":"docker"},{"location":"configuration-options/#dotnet","text":"Configuration object for .NET language. Name Value type object mergeable true","title":"dotnet"},{"location":"configuration-options/#draftpr","text":"If enabled, the PR created by Renovate is set to a draft. Name Value type boolean default false If you want the PRs created by Renovate to be considered as drafts rather than normal PRs, you could add this property to your renovate.json : { \"draftPR\": true } This option is evaluated at PR/MR creation time and is only supported on the following platforms: GitHub, GitLab, Azure. Note that GitLab implements draft status by checking whether the PR's title starts with certain strings. Therefore, draftPR on GitLab is incompatible with the legacy method of triggering Renovate to rebase a PR by renaming the PR to start with rebase! .","title":"draftPR"},{"location":"configuration-options/#enabled","text":"Enable or disable the bot. Name Value type boolean default true The most common use of enabled is if you want to turn Renovate's functionality off, for some reason. For example, if you wanted to disable Renovate completely on a repository, you could make this your renovate.json : { \"enabled\": false } To disable Renovate for all eslint packages, you can configure a package rule like: { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"enabled\": false } ] } To disable Renovate for npm devDependencies but keep it for dependencies you could configure: { \"packageRules\": [ { \"matchManagers\": [\"npm\"], \"matchDepTypes\": [\"devDependencies\"], \"enabled\": false } ] }","title":"enabled"},{"location":"configuration-options/#enabledmanagers","text":"A list of package managers to enable. If defined, then all managers not on the list are disabled. Name Value type array This is a way to allow only certain package managers and implicitly disable all others. Example: { \"enabledManagers\": [\"dockerfile\", \"npm\"] } For the full list of available managers, see the Supported Managers documentation.","title":"enabledManagers"},{"location":"configuration-options/#encrypted","text":"A configuration object containing configuration encrypted with project key. Name Value type object See Private npm module support for details on how this is used to encrypt npm tokens.","title":"encrypted"},{"location":"configuration-options/#excludecommitpaths","text":"A file that matches any of these glob patterns will not be committed, even if it has been updated. Name Value type array subType string Warning: Advanced use! Be careful you know what you're doing with this option. The initial intended use is to allow the user to exclude certain dependencies from being added/removed/modified when \"vendoring\" dependencies. Example: { \"excludeCommitPaths\": [\"vendor/golang.org/x/text/**\"] } The above would mean Renovate would not include files matching the above glob pattern in the commit, even if it thinks they should be updated.","title":"excludeCommitPaths"},{"location":"configuration-options/#extends","text":"Configuration presets to use/extend. Note: does not work if configured in config.js. Name Value type array subType string See shareable config presets for details.","title":"extends"},{"location":"configuration-options/#extractversion","text":"A regex (re2) to extract a version from a datasource's raw version string. Name Value type string format regex default null Use this only when the raw version strings from the datasource do not match the expected format that you need in your package file. You must defined a \"named capture group\" called version as shown in the below examples. For example, to extract only the major.minor precision from a GitHub release, the following would work: { \"packageRules\": [ { \"matchPackageNames\": [\"foo\"], \"extractVersion\": \"^(?<version>v\\\\d+\\\\.\\\\d+)\" } ] } The above will change a raw version of v1.31.5 to v1.31 , for example. Alternatively, to strip a release- prefix: { \"packageRules\": [ { \"matchPackageNames\": [\"bar\"], \"extractVersion\": \"^release-(?<version>.*)$\" } ] } The above will change a raw version of release-2.0.0 to 2.0.0 , for example. A similar one could strip leading v prefixes: { \"packageRules\": [ { \"matchPackageNames\": [\"baz\"], \"extractVersion\": \"^v(?<version>.*)$\" } ] }","title":"extractVersion"},{"location":"configuration-options/#fetchreleasenotes","text":"Allow to disable release notes fetching. Name Value type boolean default true Configure this to false if you want to disable release notes fetching","title":"fetchReleaseNotes"},{"location":"configuration-options/#filematch","text":"RegEx (re2) pattern for matching manager files. Name Value type array subType string format regex mergeable true fileMatch is used by Renovate to know which files in a repository to parse and extract, and it is possible to override defaults values to customize for your project's needs. Sometimes file matches are really simple - for example with Go Modules Renovate looks for any go.mod file, and you probably don't need to change that default. At other times, the possible files is too vague for Renovate to have any default. For default, Kubernetes manifests can exist in any *.yaml file and we don't want Renovate to parse every single YAML file in every repository just in case some of them contain a Kubernetes manifest, so Renovate's default fileMatch for manager kubernetes is actually empty ( [] ) and needs the user to tell Renovate what directories/files to look in. Finally, there are cases where Renovate's default fileMatch is good, but you may be using file patterns that a bot couldn't possibly guess about. For example, Renovate's default fileMatch for Dockerfile is ['(^|/|\\\\.)Dockerfile$', '(^|/)Dockerfile\\\\.[^/]*$'] . This will catch files like backend/Dockerfile , prefix.Dockerfile or Dockerfile.suffix , but it will miss files like ACTUALLY_A_DOCKERFILE.template . Because fileMatch is mergeable, you don't need to duplicate the defaults and could just add the missing file like this: { \"dockerfile\": { \"fileMatch\": [\"^ACTUALLY_A_DOCKERFILE\\\\.template$\"] } } If you configure fileMatch then it must be within a manager object (e.g. dockerfile in the above example). The full list of supported managers can be found here .","title":"fileMatch"},{"location":"configuration-options/#followtag","text":"If defined, packages will follow this release tag exactly. Name Value type string default null Caution: advanced functionality. Only use it if you're sure you know what you're doing. This functionality requires that the datasource to support distribution streams/tags, such as npm does. The primary use case for this option is if you are following a pre-release tag of a certain dependency, e.g. typescript 's \"insiders\" build. If configured, Renovate bypasses its normal major/minor/patch upgrade logic and stable/unstable consistency logic and keeps your dependency version sync'd strictly to whatever version is in the tag. Beware that Renovate follows tags strictly. For example, if you are following a tag like next and then that stream is released as stable and next is no longer being updated then that means your dependencies also won't be getting updated.","title":"followTag"},{"location":"configuration-options/#gitignoredauthors","text":"Additional git authors which are ignored by Renovate. Must conform to RFC5322. Name Value type array subType string Specify commit authors ignored by Renovate. By default, Renovate will treat any PR as modified if another git author has added to the branch. When a PR is considered modified, Renovate won't perform any further commits such as if it's conflicted or needs a version update. If you have other bots which commit on top of Renovate PRs, and don't want Renovate to treat these PRs as modified, then add the other git author(s) to gitIgnoredAuthors . Example: { \"gitIgnoredAuthors\": [\"some-bot@example.org\"] }","title":"gitIgnoredAuthors"},{"location":"configuration-options/#gitlabautomerge","text":"Enable or disable usage of GitLab's \"merge when pipeline succeeds\" feature when automerging PRs. Name Value type boolean default false Caution (fixed in GitLab >= 12.7): when this option is enabled it is possible due to a bug in GitLab that MRs with failing pipelines might still get merged. This is caused by a race condition in GitLab's Merge Request API - read the corresponding issue for details.","title":"gitLabAutomerge"},{"location":"configuration-options/#golang","text":"Configuration object for Go language. Name Value type object mergeable true Configuration added here applies for all Go-related updates, however currently the only supported package manager for Go is the native Go Modules (the gomod manager).","title":"golang"},{"location":"configuration-options/#group","text":"Config if groupName is enabled. Name Value type object mergeable true Caution: Advanced functionality only. Do not use unless you know what you're doing. The default configuration for groups are essentially internal to Renovate and you normally shouldn't need to modify them. However, you may choose to add settings to any group by defining your own group configuration object.","title":"group"},{"location":"configuration-options/#groupname","text":"Human understandable name for the dependency group. Name Value type string There are multiple cases where it can be useful to group multiple upgrades together. Internally Renovate uses this for branches such as \"Pin Dependencies\", \"Lock File Maintenance\", etc. Another example used previously is to group together all related eslint packages, or perhaps angular or babel . To enable grouping, you configure the groupName field to something non-null. The groupName field allows free text and does not have any semantic interpretation by Renovate. All updates sharing the same groupName will be placed into the same branch/PR. For example, to group all non-major devDependencies updates together into a single PR: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchUpdateTypes\": [\"patch\", \"minor\"], \"groupName\": \"devDependencies (non-major)\" } ] }","title":"groupName"},{"location":"configuration-options/#groupslug","text":"Slug to use for group (e.g. in branch name). Will be calculated from groupName if null. Name Value type string By default, Renovate will \"slugify\" the groupName to determine the branch name. For example if you named your group \"devDependencies (non-major)\" then the branchName would be renovate/devdependencies-non-major . If you wished to override this then you could configure like this: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"matchUpdateTypes\": [\"patch\", \"minor\"], \"groupName\": \"devDependencies (non-major)\", \"groupSlug\": \"dev-dependencies\" } ] } As a result of the above, the branchName would be renovate/dev-dependencies instead. Note: you shouldn't usually need to configure this unless you really care about your branch names.","title":"groupSlug"},{"location":"configuration-options/#hashedbranchlength","text":"If enabled, branch names will use a hashing function to ensure each branch has that length. Name Value type integer Some code hosting systems have restrictions on the branch name lengths, this option lets you get around these restrictions. You can set the hashedBranchLength option to a number of characters that works for your system and then Renovate will generate branch names with the appropriate length by hashing additionalBranchPrefix and branchTopic , and then truncating the hash so that the full branch name (including branchPrefix ) has the right number of characters. Example: If you have set branchPrefix: \"deps-\" and hashedBranchLength: 12 it will result in a branch name like deps-5bf36ec instead of the traditional pretty branch name like deps-react-17.x .","title":"hashedBranchLength"},{"location":"configuration-options/#hostrules","text":"Host rules/configuration including credentials. Name Value type array subType object mergeable true Currently the purpose of hostRules is to configure credentials for host authentication. You tell Renovate how to match against the host you need authenticated, and then you also tell it which credentials to use. The lookup keys for a hostRule are: hostType , domainName , hostName , and baseUrl . All are optional, but you can only have one of the last three per rule. Supported credential fields are token , username , password , timeout , enabled and insecureRegistry . Example for configuring docker auth: { \"hostRules\": [ { \"domainName\": \"docker.io\", \"username\": \"<some-username>\", \"password\": \"<some-password>\" } ] } To disable requests to a particular host, you can configure a rule like: { \"hostRules\": [ { \"hostName\": \"registry.npmjs.org\", \"enabled\": false } ] } A preset alternative to the above is: { \"extends\": [\":disableHost(registry.npmjs.org)\"] } Note: Disabling a host is only 100% effective if added to self-hosted config. Renovate currently still checks its cache for results first before making connection attempts, so if a public host is blocked in your repository config (e.g. renovate.json ) then it's possible you may get cached results from that host if another repository using the same bot has successfully queried for the same dependency recently.","title":"hostRules"},{"location":"configuration-options/#abortignorestatuscodes","text":"A list of HTTP status codes to ignore and not abort the run because of when abortOnError=true. Name Value type array subType number parent hostRules This field can be used to configure status codes that Renovate ignores and passes through when abortOnError is set to true . For example to also skip 404 responses then configure the following: { \"hostRules\": [ { \"abortOnError\": true, \"abortIgnoreStatusCodes\": [404] } ] } Note that this field is not mergeable, so the last-applied host rule will take precedence.","title":"abortIgnoreStatusCodes"},{"location":"configuration-options/#abortonerror","text":"If enabled, Renovate will abort its run when HTTP request errors occur. Name Value type boolean parent hostRules default false Use this field to configure Renovate to abort runs for custom hosts. By default, Renovate will only abort for known public hosts, which has the downside that transient errors for other hosts can cause autoclosing of PRs. To abort Renovate runs for http failures from any host: { \"hostRules\": [ { \"abortOnError\": true } ] } To abort Renovate runs for any docker datasource failures: { \"hostRules\": [ { \"hostType\": \"docker\", \"abortOnError\": true } ] } To abort Renovate for errors for a specific docker host: { \"hostRules\": [ { \"hostName\": \"docker.company.com\", \"abortOnError\": true } ] } When this field is enabled, Renovate will abort its run if it encounters either (a) any low-level http error (e.g. ETIMEDOUT ) or (b) receives a response not matching any of the configured abortIgnoreStatusCodes (e.g. 500 Internal Error );","title":"abortOnError"},{"location":"configuration-options/#authtype","text":"Authentication type for http header. e.g. \"Bearer\" or \"Basic\". Name Value type string parent hostRules default \"Bearer\" This can be used with token to create a custom http authorization header. An example for npm basic auth with token: { \"hostRules\": [ { \"domainName\": \"npm.custom.org\", \"token\": \"<some-token>\", \"authType\": \"Basic\" } ] } This will generate the following header: authorization: Basic <some-token> .","title":"authType"},{"location":"configuration-options/#baseurl","text":"baseUrl for a host rule. e.g. \"https://api.github.com/\". Name Value type string parent hostRules default null Use this instead of domainName or hostName if you need a rule to apply to a specific path on a host. For example, \"baseUrl\": \"https://api.github.com\" is equivalent to \"hostName\": \"api.github.com\" but \"baseUrl\": \"https://api.github.com/google/\" is not. Renovate does not do a \"longest match\" algorithm to pick between multiple matching baseUrl values in different rules, so put the longer baseUrl rule after the shorter one in your hostRules .","title":"baseUrl"},{"location":"configuration-options/#concurrentrequestlimit","text":"Limit concurrent requests per host. Name Value type integer parent hostRules Usually the default setting is fine, but you can use concurrentRequestLimit to limit the number of concurrent outstanding requests. You only need to adjust this setting if a datasource is rate limiting Renovate or has problems with the load. The limit will be set for any host it applies to. Example config: { \"hostRules\": [ { \"hostName\": \"github.com\", \"concurrentRequestLimit\": 2 } ] }","title":"concurrentRequestLimit"},{"location":"configuration-options/#domainname","text":"Domain name for a host rule. e.g. \"docker.io\". Name Value type string parent hostRules default null If you have any uncertainty about exactly which hosts a service uses, then it can be more reliable to use domainName instead of hostName or baseUrl . e.g. configure \"hostName\": \"docker.io\" to cover both index.docker.io and auth.docker.io and any other host that's in use.","title":"domainName"},{"location":"configuration-options/#enablehttp2","text":"Enable got HTTP/2 support. Name Value type boolean parent hostRules default false Enable got http2 support.","title":"enableHttp2"},{"location":"configuration-options/#hostname","text":"Hostname for a host rule. e.g. \"index.docker.io\". Name Value type string parent hostRules default null","title":"hostName"},{"location":"configuration-options/#hosttype","text":"hostType for a package rule. Can be a platform name or a datasource name. Name Value type string parent hostRules default null hostType is another way to filter rules and can be either a platform such as github and bitbucket-server , or it can be a datasource such as docker and rubygems . You usually don't need to configure it in a host rule if you have already configured domainName , hostName or baseUrl and only one host type is in use for those, as is usually the case. hostType can help for cases like an enterprise registry that serves multiple package types and has different authentication for each, although it's often the case that multiple baseUrl rules could achieve the same thing.","title":"hostType"},{"location":"configuration-options/#insecureregistry","text":"Explicitly turn on insecure Docker registry access (HTTP). Name Value type boolean parent hostRules default true Warning: Advanced config, use at own risk. Enable this option to allow Renovate to connect to an insecure Docker registry that is http only. This is insecure and is not recommended. Example: { \"hostRules\": [ { \"hostName\": \"reg.insecure.com\", \"insecureRegistry\": true } ] }","title":"insecureRegistry"},{"location":"configuration-options/#timeout","text":"Timeout (in milliseconds) for queries to external endpoints. Name Value type integer parent hostRules Use this figure to adjust the timeout for queries. The default is 60s, which is quite high. To adjust it down to 10s for all queries, do this: { \"hostRules\": [ { \"timeout\": 10000 } ] }","title":"timeout"},{"location":"configuration-options/#ignoredeprecated","text":"Ignore deprecated versions unless the current version is deprecated. Name Value type boolean default true By default, Renovate won't update a dependency version to a deprecated release unless the current version was itself deprecated. The goal of this is to make sure you don't upgrade from a non-deprecated version to a deprecated one just because it's higher than the current version. If for some reason you wish to force deprecated updates with Renovate, you can configure ignoreDeprecated to false , but this is not recommended for most situations.","title":"ignoreDeprecated"},{"location":"configuration-options/#ignoredeps","text":"Dependencies to ignore. Name Value type array subType string mergeable true The ignoreDeps configuration field allows you to define a list of dependency names to be ignored by Renovate. Currently it supports only \"exact match\" dependency names and not any patterns. e.g. to ignore both eslint and eslint-config-base you would add this to your config: { \"ignoreDeps\": [\"eslint\", \"eslint-config-base\"] } The above is the same as if you wrote this package rule: { \"packageRules\": [ { \"matchPackageNames\": [\"eslint\", \"eslint-config-base\"], \"enabled\": false } ] }","title":"ignoreDeps"},{"location":"configuration-options/#ignorenpmrcfile","text":"Whether to ignore any .npmrc file found in repository. Name Value type boolean default false By default, Renovate will look for and use any .npmrc file it finds in a repository. Additionally, it will be read in by npm or yarn at the time of lock file generation. Sometimes this causes problems, for example if the file contains placeholder values, so you can configure this to true and Renovate will ignore any .npmrc files it finds and temporarily remove the file before running npm install or yarn install . Renovate will try to configure this to true also if you have configured any npmrc string within your config file.","title":"ignoreNpmrcFile"},{"location":"configuration-options/#ignorepaths","text":"Skip any package file whose path matches one of these. Can be a string or glob pattern. Name Value type array subType string Using this setting, you can selectively ignore package files that you don't want Renovate autodiscovering. For instance if your repository has an \"examples\" directory of many package.json files that you don't want to be kept up to date.","title":"ignorePaths"},{"location":"configuration-options/#ignoreprauthor","text":"Set to true to fetch the entire list of PRs instead of only those authored by the Renovate user. Name Value type boolean default false This is usually needed if someone needs to migrate bot accounts, including from hosted app to self-hosted. If ignorePrAuthor is configured to true, it means Renovate will fetch the entire list of repository PRs instead of optimizing to fetch only those PRs which it created itself. You should only want to enable this if you are changing the bot account (e.g. from @old-bot to @new-bot ) and want @new-bot to find and update any existing PRs created by @old-bot . It's recommended to revert this setting once that transition period is over and all old PRs are resolved.","title":"ignorePrAuthor"},{"location":"configuration-options/#ignorepresets","text":"A list of presets to ignore, including nested ones inside extends . Name Value type array subType string Use this if you are extending a complex preset but don't want to use every \"sub preset\" that it includes. For example, consider this config: { \"extends\": [\"config:base\"], \"ignorePresets\": [\":prHourlyLimit2\"] } It would take the entire \"config:base\" preset - which contains a lot of sub-presets - but ignore the \":prHourlyLimit2\" rule.","title":"ignorePresets"},{"location":"configuration-options/#ignorescripts","text":"Configure this to true if trustLevel is high but you wish to skip running scripts when updating lock files. Name Value type boolean default false Applicable for npm and Composer only for now. Set this to true if running scripts causes problems.","title":"ignoreScripts"},{"location":"configuration-options/#ignoreunstable","text":"Ignore versions with unstable SemVer. Name Value type boolean default true By default, Renovate won't update any package versions to unstable versions (e.g. 4.0.0-rc3 ) unless the current version has the same major.minor.patch and was already unstable (e.g. it was already on 4.0.0-rc2 ). Renovate will also not \"jump\" unstable versions automatically, e.g. if you are on 4.0.0-rc2 and newer versions 4.0.0 and 4.1.0-alpha.1 exist then Renovate will update you to 4.0.0 only. If you need to force permanent unstable updates for a package, you can add a package rule setting ignoreUnstable to false . Also check out the followTag configuration option above if you wish Renovate to keep you pinned to a particular release tag.","title":"ignoreUnstable"},{"location":"configuration-options/#includeforks","text":"Whether to process forked repositories or not. By default, all forked repositories are skipped. Name Value type boolean default false By default, Renovate will skip over any repositories that are forked. This includes if the forked repository contain a Renovate config file, because Renovate can't tell if that file was added by the original repository or not. If you wish to enable processing of a forked repository by Renovate, you need to add \"includeForks\": true to your repository config or run the CLI command with --include-forks=true . If you are using the hosted WhiteSource Renovate then this option will be configured to true automatically if you \"Selected\" repositories individually but remain as false if you installed for \"All\" repositories.","title":"includeForks"},{"location":"configuration-options/#includepaths","text":"Include package files only within these defined paths. Name Value type array subType string If you wish for Renovate to process only select paths in the repository, use includePaths . Alternatively, if you need to just exclude certain paths in the repository then consider ignorePaths instead. If you are more interested in including only certain package managers (e.g. npm ), then consider enabledManagers instead.","title":"includePaths"},{"location":"configuration-options/#java","text":"Configuration object for all Java package managers. Name Value type object mergeable true Use this configuration option for shared config across all java projects (Gradle and Maven).","title":"java"},{"location":"configuration-options/#js","text":"Configuration object for JavaScript language. Name Value type object mergeable true Use this configuration option for shared config across npm/Yarn/pnpm and meteor package managers.","title":"js"},{"location":"configuration-options/#labels","text":"Labels to set in Pull Request. Name Value type array subType string By default, Renovate won't add any labels to its PRs. If you want Renovate to do so then define a labels array of one or more label strings. If you want the same label(s) for every PR then you can configure it at the top level of config. However you can also fully override them on a per-package basis. Consider this example: { \"labels\": [\"dependencies\"], \"packageRules\": [ { \"matchPackagePatterns\": [\"eslint\"], \"labels\": [\"linting\"] } ] } With the above config, every PR raised by Renovate will have the label dependencies while PRs containing eslint -related packages will instead have the label linting .","title":"labels"},{"location":"configuration-options/#lockfilemaintenance","text":"Configuration for lock file maintenance. Name Value type object mergeable true This feature can be used to refresh lock files and keep them up-to-date. \"Maintaining\" a lock file means recreating it so that every dependency version within it is updated to the latest. Supported lock files are package-lock.json , yarn.lock , composer.lock , Gemfile.lock , poetry.lock and Cargo.lock . Others may be added via feature request. This feature is disabled by default. If you wish to enable this feature then you could add this to your configuration: { \"lockFileMaintenance\": { \"enabled\": true } } To reduce \"noise\" in the repository, it defaults its schedule to \"before 5am on monday\" , i.e. to achieve once-per-week semantics. Depending on its running schedule, Renovate may run a few times within that time window - even possibly updating the lock file more than once - but it hopefully leaves enough time for tests to run and automerge to apply, if configured.","title":"lockFileMaintenance"},{"location":"configuration-options/#major","text":"Configuration to apply when an update type is major. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to major updates.","title":"major"},{"location":"configuration-options/#minor","text":"Configuration to apply when an update type is minor. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to minor updates.","title":"minor"},{"location":"configuration-options/#node","text":"Configuration object for Node version renovation. Name Value type object mergeable true Using this configuration option allows you to apply common configuration and policies across all Node.js version updates even if managed by different package managers ( npm , yarn , etc.). Check out our Node.js documentation for a comprehensive explanation of how the node option can be used.","title":"node"},{"location":"configuration-options/#npmtoken","text":"npm token used for authenticating with the default registry. Name Value type string default null See Private npm module support for details on how this is used. Typically you would encrypt it and put it inside the encrypted object.","title":"npmToken"},{"location":"configuration-options/#npmrc","text":"String copy of npmrc file. Use \\n instead of line breaks. Name Value type string default null See Private npm module support for details on how this is used.","title":"npmrc"},{"location":"configuration-options/#packagerules","text":"Rules for matching package names. Name Value type array mergeable true packageRules is a powerful feature that lets you apply rules to individual packages or to groups of packages using regex pattern matching. Here is an example if you want to group together all packages starting with eslint into a single branch/PR: { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"groupName\": \"eslint packages\" } ] } Note how the above uses matchPackagePatterns with a regex value. Here is an example where you might want to limit the \"noisy\" package aws-sdk to updates just once per week: { \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"schedule\": [\"after 9pm on sunday\"] } ] } For Maven dependencies, the package name is <groupId:artefactId> , eg \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"] Note how the above uses matchPackageNames instead of matchPackagePatterns because it is an exact match package name. This is the equivalent of defining \"matchPackagePatterns\": [\"^aws\\-sdk$\"] and hence much simpler. However you can mix together both matchPackageNames and matchPackagePatterns in the same package rule and the rule will be applied if either match. Example: { \"packageRules\": [ { \"matchPackageNames\": [\"neutrino\"], \"matchPackagePatterns\": [\"^@neutrino/\"], \"groupName\": \"neutrino monorepo\" } ] } The above rule will group together the neutrino package and any package matching @neutrino/* . Path rules are convenient to use if you wish to apply configuration rules to certain package files using patterns. For example, if you have an examples directory and you want all updates to those examples to use the chore prefix instead of fix , then you could add this configuration: { \"packageRules\": [ { \"matchPaths\": [\"examples/**\"], \"extends\": [\":semanticCommitTypeAll(chore)\"] } ] } If you wish to limit renovate to apply configuration rules to certain files in the root repository directory, you have to use matchPaths with either a partial string match or a minimatch pattern. For example you have multiple package.json and want to use dependencyDashboardApproval only on the root package.json : { \"packageRules\": [ { \"matchPaths\": [\"+(package.json)\"], \"dependencyDashboardApproval\": true } ] } Important to know: Renovate will evaluate all packageRules and not stop once it gets a first match. Therefore, you should order your packageRules in order of importance so that later rules can override settings from earlier rules if necessary.","title":"packageRules"},{"location":"configuration-options/#allowedversions","text":"A version range or regex pattern capturing allowed versions for dependencies. Name Value type string parent packageRules default null Use this - usually within a packageRule - to limit how far to upgrade a dependency. For example, if you wish to upgrade to Angular v1.5 but not to angular v1.6 or higher, you could define this to be <= 1.5 or < 1.6.0 : { \"packageRules\": [ { \"matchPackageNames\": [\"angular\"], \"allowedVersions\": \"<=1.5\" } ] } The valid syntax for this will be calculated at runtime because it depends on the versioning scheme, which is itself dynamic. This field also supports Regular Expressions if they begin and end with / . For example, the following will enforce that only 3 or 4-section versions are supported, without any prefixes: { \"packageRules\": [ { \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"], \"allowedVersions\": \"/^[0-9]+\\\\.[0-9]+\\\\.[0-9]+(\\\\.[0-9]+)?$/\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\": [ { \"matchPackageNames\": [\"chalk\"], \"allowedVersions\": \"!/java$/\" } ] }","title":"allowedVersions"},{"location":"configuration-options/#matchdeptypes","text":"List of depTypes to match (e.g. [ peerDependencies ]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to limit a packageRule to certain depType values. Invalid if used outside of a packageRule .","title":"matchDepTypes"},{"location":"configuration-options/#excludepackagenames","text":"Package names to exclude. Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Important : Do not mix this up with the option ignoreDeps . Use ignoreDeps instead if all you want to do is have a list of package names for Renovate to ignore. Use excludePackageNames if you want to have one or more exact name matches excluded in your package rule. See also matchPackageNames . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"excludePackageNames\": [\"eslint-foo\"] } ] } The above will match all package names starting with eslint but exclude the specific package eslint-foo .","title":"excludePackageNames"},{"location":"configuration-options/#excludepackagepatterns","text":"Package name patterns to exclude. Valid only within packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package name patterns excluded in your package rule. See also matchPackagePatterns . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^eslint\"], \"excludePackagePatterns\": [\"^eslint-foo\"] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo .","title":"excludePackagePatterns"},{"location":"configuration-options/#matchlanguages","text":"List of languages to match (e.g. [\"python\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular language. e.g. { \"packageRules\": [ { \"matchPackageNames\": [\"request\"], \"matchLanguages\": [\"python\"], \"enabled\": false } ] }","title":"matchLanguages"},{"location":"configuration-options/#matchbasebranches","text":"List of branches to match (e.g. [\"master\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular branch. e.g. { \"packageRules\": [ { \"matchBaseBranches\": [\"master\"], \"excludePackagePatterns\": [\"^eslint\"], \"enabled\": false } ] }","title":"matchBaseBranches"},{"location":"configuration-options/#matchmanagers","text":"List of package managers to match (e.g. [\"pipenv\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular package manager. e.g. { \"packageRules\": [ { \"matchPackageNames\": [\"node\"], \"matchManagers\": [\"dockerfile\"], \"enabled\": false } ] }","title":"matchManagers"},{"location":"configuration-options/#matchdatasources","text":"List of datasources to match (e.g. [\"orb\"]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular datasource. e.g. { \"packageRules\": [ { \"matchDatasources\": [\"orb\"], \"labels\": [\"circleci-orb!!\"] } ] }","title":"matchDatasources"},{"location":"configuration-options/#matchcurrentversion","text":"A version or version range to match against the current version of a package. Valid only within packageRules object. Name Value type string parent packageRules mergeable true default null matchCurrentVersion can be an exact semver version or a semver range. This field also supports Regular Expressions which have to begin and end with / . For example, the following will enforce that only 1.* versions: { \"packageRules\": [ { \"matchPackagePatterns\": [\"io.github.resilience4j\"], \"matchCurrentVersion\": \"/^1\\\\./\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\": [ { \"matchPackagePatterns\": [\"io.github.resilience4j\"], \"matchCurrentVersion\": \"!/^0\\\\./\" } ] }","title":"matchCurrentVersion"},{"location":"configuration-options/#matchfiles","text":"List of strings to do an exact match against package files with full path. Applicable inside packageRules only. Name Value type array subType string parent packageRules Renovate will compare matchFiles for an exact match against the dependency's package file or lock file. For example the following would match package.json but not package/frontend/package.json : \"matchFiles\": [\"package.json\"], Use matchPaths instead if you need more flexible matching.","title":"matchFiles"},{"location":"configuration-options/#matchpackagenames","text":"Package names to match. Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more exact name matches in your package rule. See also excludePackageNames . { \"packageRules\": [ { \"matchPackageNames\": [\"angular\"], \"rangeStrategy\": \"pin\" } ] } The above will configure rangeStrategy to pin only for the package angular .","title":"matchPackageNames"},{"location":"configuration-options/#matchpackagepatterns","text":"Package name patterns to match. Valid only within packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package names patterns in your package rule. See also excludePackagePatterns . { \"packageRules\": [ { \"matchPackagePatterns\": [\"^angular\"], \"rangeStrategy\": \"replace\" } ] } The above will configure rangeStrategy to replace for any package starting with angular .","title":"matchPackagePatterns"},{"location":"configuration-options/#matchpaths","text":"List of strings or glob patterns to match against package files. Applicable inside packageRules only. Name Value type array subType string parent packageRules Renovate will match matchPaths against both a partial string match or a minimatch glob pattern. If you want to avoid the partial string matching so that only glob matching is performed, wrap your string in +(...) like so: \"matchPaths\": [\"+(package.json)\"], The above will match only the root package.json , whereas the following would match any package.json in any subdirectory too: \"matchPaths\": [\"package.json\"],","title":"matchPaths"},{"location":"configuration-options/#matchsourceurlprefixes","text":"A list of source URL prefixes to match against, commonly used for grouping of monorepos or packages from the same organization. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to group together all packages from the Vue monorepo: { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [\"https://github.com/vuejs/vue\"], \"groupName\": \"Vue monorepo packages\" } ] } Here's an example of where you use this to group together all packages from the renovatebot github org: { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [\"https://github.com/renovatebot/\"], \"groupName\": \"All renovate packages\" } ] }","title":"matchSourceUrlPrefixes"},{"location":"configuration-options/#matchupdatetypes","text":"Update types to match against (major, minor, pin, etc). Valid only within packageRules object. Name Value type array subType string allowedValues major,minor,patch,pin,digest,lockFileMaintenance,rollback,bump parent packageRules mergeable true Use this field to match rules against types of updates. For example to apply a special label for Major updates: { \"packageRules\": [ { \"matchUpdateTypes\": [\"major\"], \"labels\": [\"UPDATE-MAJOR\"] } ] }","title":"matchUpdateTypes"},{"location":"configuration-options/#patch","text":"Configuration to apply when an update type is patch. Only applies if separateMinorPatch is set to true. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to patch updates. Only applies if separateMinorPatch is set to true.","title":"patch"},{"location":"configuration-options/#php","text":"Configuration object for PHP. Name Value type object mergeable true","title":"php"},{"location":"configuration-options/#pin","text":"Configuration to apply when an update type is pin. Name Value type object mergeable true Add to this object if you wish to define rules that apply only to PRs that pin dependencies.","title":"pin"},{"location":"configuration-options/#pindigests","text":"Whether to add digests to Dockerfile source images. Name Value type boolean default false If enabled Renovate will pin Docker images by means of their SHA256 digest and not only by tag so that they are immutable.","title":"pinDigests"},{"location":"configuration-options/#postupdateoptions","text":"Enable post-update options to be run after package/artifact updating. Name Value type array allowedValues gomodTidy,npmDedupe,yarnDedupeFewer,yarnDedupeHighest mergeable true gomodTidy : Run go mod tidy after Go module updates npmDedupe : Run npm dedupe after package-lock.json updates yarnDedupeFewer : Run yarn-deduplicate --strategy fewer after yarn.lock updates yarnDedupeHighest : Run yarn-deduplicate --strategy highest ( yarn dedupe --strategy highest for Yarn >=2.2.0) after yarn.lock updates","title":"postUpdateOptions"},{"location":"configuration-options/#postupgradetasks","text":"Post-upgrade tasks that are executed before a commit is made by Renovate. Name Value type object Post-upgrade tasks are commands that are executed by Renovate after a dependency has been updated but before the commit is created. The intention is to run any additional command line tools that would modify existing files or generate new files when a dependency changes. This is only available on Renovate instances that have a trustLevel of 'high'. Each command must match at least one of the patterns defined in allowedPostUpgradeTasks in order to be executed. If the list of allowed tasks is empty then no tasks will be executed. e.g. { \"postUpgradeTasks\": { \"commands\": [\"tslint --fix\"], \"fileFilters\": [\"yarn.lock\", \"**/*.js\"] } } The postUpgradeTasks configuration consists of two fields:","title":"postUpgradeTasks"},{"location":"configuration-options/#commands","text":"A list of post-upgrade commands that are executed before a commit is made by Renovate. Name Value type array subType string parent postUpgradeTasks A list of commands that are executed after Renovate has updated a dependency but before the commit it made","title":"commands"},{"location":"configuration-options/#filefilters","text":"Files that match these glob patterns will be committed if they are present after running a post-upgrade task. Name Value type array subType string parent postUpgradeTasks A list of glob-style matchers that determine which files will be included in the final commit made by Renovate","title":"fileFilters"},{"location":"configuration-options/#prbodycolumns","text":"List of columns to use in PR bodies. Name Value type array subType string Use this array to provide a list of column names you wish to include in the PR tables. For example, if you wish to add the package file name to the table, you would add this to your config: { \"prBodyColumns\": [ \"Package\", \"Update\", \"Type\", \"New value\", \"Package file\", \"References\" ] } Note: \"Package file\" is predefined in the default prBodyDefinitions object so does not require a definition before it can be used.","title":"prBodyColumns"},{"location":"configuration-options/#prbodydefinitions","text":"Table column definitions for use in PR tables. Name Value type object freeChoice true mergeable true You can configure this object to either (a) modify the template for an existing table column in PR bodies, or (b) you wish to add a definition for a new/additional column. Here is an example of modifying the default value for the \"Package\" column to put it inside a <code></code> block: { \"prBodyDefinitions\": { \"Package\": \"`{{{depName}}}`\" } } Here is an example of adding a custom \"Sourcegraph\" column definition: { \"prBodyDefinitions\": { \"Sourcegraph\": \"[![code search for \\\"{{{depName}}}\\\"](https://sourcegraph.com/search/badge?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}}&label=matches)](https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}})\" }, \"prBodyColumns\": [ \"Package\", \"Update\", \"New value\", \"References\", \"Sourcegraph\" ] } Note: Columns must also be included in the prBodyColumns array in order to be used, so that's why it's included above in the example.","title":"prBodyDefinitions"},{"location":"configuration-options/#prbodynotes","text":"List of additional notes/templates to be included in the Pull Request bodies. Name Value type array subType string mergeable true Use this field to add custom content inside PR bodies, including conditionally. e.g. if you wish to add an extra Warning to major updates: { \"prBodyNotes\": [\"{{#if isMajor}}:warning: MAJOR MAJOR MAJOR :warning:{{/if}}\"] }","title":"prBodyNotes"},{"location":"configuration-options/#prbodytemplate","text":"Pull Request body template. Controls which sections are rendered in the body. Name Value type string default \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{controls}}}{{{footer}}}\" This setting controls which sections are rendered in the body of the pull request. The available sections are header, table, notes, changelogs, configDescription, controls, footer.","title":"prBodyTemplate"},{"location":"configuration-options/#prconcurrentlimit","text":"Limit to a maximum of x concurrent branches/PRs. 0 (default) means no limit. Name Value type integer default 0 This setting - if enabled - limits Renovate to a maximum of x concurrent PRs open at any time. Note that this limit is enforced on a per-repository basis.","title":"prConcurrentLimit"},{"location":"configuration-options/#prcreation","text":"When to create the PR for a branch. Name Value type string allowedValues immediate,not-pending,status-success,approval default \"immediate\" This setting tells Renovate when you would like it to raise PRs: immediate (default): Renovate will create PRs immediately after creating the corresponding branch not-pending : Renovate will wait until status checks have completed (passed or failed) before raising the PR status-success : Renovate won't raise PRs unless tests pass Renovate defaults to immediate but some like to change to not-pending . If you configure to immediate, it means you will usually get GitHub notifications that a new PR is available but if you view it immediately then it will still have \"pending\" tests so you can't take any action. With not-pending , it means that when you receive the PR notification, you can see if it passed or failed and take action immediately. Therefore you can customise this setting if you wish to be notified a little later in order to reduce \"noise\".","title":"prCreation"},{"location":"configuration-options/#prfooter","text":"Any text added here will be placed last in the PR body, with a divider separator before it. Name Value type string default \"This PR has been generated by [Renovate Bot](https://github.com/renovatebot/renovate).\"","title":"prFooter"},{"location":"configuration-options/#prheader","text":"Any text added here will be placed first in the PR body. Name Value type string default null","title":"prHeader"},{"location":"configuration-options/#prhourlylimit","text":"Rate limit PRs to maximum x created per hour. 0 (default) means no limit. Name Value type integer default 0 This setting - if enabled - helps slow down Renovate, particularly during the onboarding phase. What may happen without this setting is: Onboarding PR is created User merges onboarding PR to activate Renovate Renovate creates a \"Pin Dependencies\" PR (if necessary) User merges Pin PR Renovate then creates every single upgrade PR necessary - potentially dozens The above can result in swamping CI systems, as well as a lot of retesting if branches need to be rebased every time one is merged. Instead, if prHourlyLimit is configure to a value like 1 or 2, it will mean that Renovate creates at most that many new PRs within each hourly period (:00-:59). So the project should still result in all PRs created perhaps within the first 24 hours maximum, but at a rate that may allow users to merge them once they pass tests. It does not place a limit on the number of concurrently open PRs - only on the rate they are created. Note that this limit is enforced on a per-repository basis.","title":"prHourlyLimit"},{"location":"configuration-options/#prnotpendinghours","text":"Timeout in hours for when prCreation=not-pending. Name Value type integer default 25 If you configure prCreation=not-pending , then Renovate will wait until tests are non-pending (all pass or at least one fails) before creating PRs. However there are cases where PRs may remain in pending state forever, e.g. absence of tests or status checks that are configure to pending indefinitely. Therefore we configure an upper limit for how long we wait until creating a PR. Note: if the option stabilityDays is non-zero then Renovate will disable the prNotPendingHours functionality.","title":"prNotPendingHours"},{"location":"configuration-options/#prpriority","text":"Set sorting priority for PR creation. PRs with higher priority are created first, negative priority last. Name Value type integer default 0 Sometimes Renovate needs to rate limit its creation of PRs, e.g. hourly or concurrent PR limits. In such cases it sorts/prioritizes by default based on the update type (e.g. patches raised before minor, minor before major). If you have dependencies that are more or less important than others then you can use the prPriority field for PR sorting. The default value is 0, so therefore setting a negative value will make dependencies sort last, while higher values sort first. Here's an example of how you would define PR priority so that devDependencies are raised last and react is raised first: { \"packageRules\": [ { \"matchDepTypes\": [\"devDependencies\"], \"prPriority\": -1 }, { \"matchPackageNames\": [\"react\"], \"prPriority\": 5 } ] }","title":"prPriority"},{"location":"configuration-options/#prtitle","text":"Pull Request title template (deprecated). Now uses commitMessage. Name Value type string The PR title is important for some of Renovate's matching algorithms (e.g. determining whether to recreate a PR or not) so ideally don't modify it much.","title":"prTitle"},{"location":"configuration-options/#prunestalebranches","text":"Enable or disable pruning of stale branches. Name Value type boolean default true Configure to false to disable deleting orphan branches and autoclosing PRs. Defaults to true .","title":"pruneStaleBranches"},{"location":"configuration-options/#python","text":"Configuration object for Python. Name Value type object mergeable true Currently the only Python package manager is pip - specifically for requirements.txt and requirements.pip files - so adding any config to this python object is essentially the same as adding it to the pip_requirements object instead.","title":"python"},{"location":"configuration-options/#rangestrategy","text":"Policy for how to modify/update existing ranges. Name Value type string default \"replace\" allowedValues auto,pin,bump,replace,widen,update-lockfile Behavior: auto = Renovate decides (this will be done on a manager-by-manager basis) pin = convert ranges to exact versions, e.g. ^1.0.0 -> 1.1.0 bump = e.g. bump the range even if the new version satisfies the existing range, e.g. ^1.0.0 -> ^1.1.0 replace = Replace the range with a newer one if the new version falls outside it, e.g. ^1.0.0 -> ^2.0.0 widen = Widen the range with newer one, e.g. ^1.0.0 -> ^1.0.0 || ^2.0.0 update-lockfile = Update the lock file when in-range updates are available, otherwise replace for updates out of range. Works for bundler , composer , npm , yarn and poetry so far Renovate's \"auto\" strategy works like this for npm: Always pin devDependencies Pin dependencies if we detect that it's an app and not a library Widen peerDependencies If an existing range already ends with an \"or\" operator - e.g. \"^1.0.0 || ^2.0.0\" - then Renovate will widen it, e.g. making it into \"^1.0.0 || ^2.0.0 || ^3.0.0\" Otherwise, replace the range. e.g. \"^2.0.0\" would be replaced by \"^3.0.0\" By default, Renovate assumes that if you are using ranges then it's because you want them to be wide/open. As such, Renovate won't deliberately \"narrow\" any range by increasing the semver value inside. For example, if your package.json specifies a value for left-pad of ^1.0.0 and the latest version on npmjs is 1.2.0 , then Renovate won't change anything because 1.2.0 satisfies the range. If instead you'd prefer to be updated to ^1.2.0 in cases like this, then configure rangeStrategy to bump in your Renovate config. This feature supports simple caret ( ^ ) and tilde ( ~ ) ranges only, like ^1.0.0 and ~1.0.0 .","title":"rangeStrategy"},{"location":"configuration-options/#rebaselabel","text":"Label to use to request the bot to rebase a PR manually. Name Value type string default \"rebase\" On supported platforms it is possible to add a label to a PR to manually request Renovate to recreate/rebase it. By default this label is \"rebase\" however you can configure it to anything you want by changing this rebaseLabel field.","title":"rebaseLabel"},{"location":"configuration-options/#rebasewhen","text":"Control when Renovate decides to rebase an existing branch. Name Value type string allowedValues auto,never,conflicted,behind-base-branch default \"auto\" Possible values and meanings: auto : Renovate will autodetect the best setting. Defaults to conflicted unless the repository has a setting requiring PRs to be up to date with the base branch never : Renovate will never rebase the branch conflicted : Renovate will rebase only if the branch is conflicted behind-base-branch : Renovate will rebase whenever the branch falls 1 or more commit behind its base branch rebaseWhen=conflicted is not recommended if you have enabled Renovate automerge, because: It could result in a broken base branch if two updates are merged one after another without testing the new versions together If you have enforced that PRs must be up-to-date before merging (e.g. using branch protection on GitHub), then automerge won't be possible as soon as a PR gets out-of-date but remains non-conflicted","title":"rebaseWhen"},{"location":"configuration-options/#recreateclosed","text":"Recreate PRs even if same ones were closed previously. Name Value type boolean default false By default, Renovate will detect if it has proposed an update to a project before and not propose the same one again. For example the Webpack 3.x case described above. This field lets you customise this behavior down to a per-package level. For example we override it to true in the following cases where branch names and PR titles need to be reused: Package groups When pinning versions Lock file maintenance Typically you shouldn't need to modify this setting.","title":"recreateClosed"},{"location":"configuration-options/#regexmanagers","text":"Custom managers using regex matching. Name Value type array subType object mergeable true regexManagers entries are used to configure the regex Manager in Renovate. Users can define custom managers for cases such as: Proprietary file formats or conventions Popular file formats not yet supported as a manager by Renovate The custom manager concept is based on using Regular Expression named capture groups. For the fields datasource , depName and currentValue , it's mandatory to have either a named capture group matching them (e.g. (?<depName>.*) ) or to configure it's corresponding template (e.g. depNameTemplate ). It's not recommended to do both, due to the potential for confusion. It is recommended to also include versioning however if it is missing then it will default to semver . For more details and examples, see the documentation page the for the regex manager here . For template fields, use the triple brace {{{ }}} notation to avoid Handlebars escaping any special characters.","title":"regexManagers"},{"location":"configuration-options/#matchstrings","text":"Regex capture rule to use. Valid only within a regexManagers object. Name Value type array subType string format regex parent regexManagers matchStrings should each be a valid regular expression, optionally with named capture groups. Currently only a length of one matchString is supported. Example: { \"matchStrings\": [ \"ENV .*?_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)\\\\s\" ] }","title":"matchStrings"},{"location":"configuration-options/#matchstringsstrategy","text":"Strategy how to interpret matchStrings. Name Value type string default \"any\" allowedValues any,recursive,combination parent regexManagers matchStringsStrategy controls behavior when multiple matchStrings values are provided. Three options are available: any (default) recursive combination","title":"matchStringsStrategy"},{"location":"configuration-options/#any","text":"Each provided matchString will be matched individually to the content of the packageFile . If a matchString has multiple matches in a file each will be interpreted as an independent dependency. As example the following configuration will update all 3 lines in the Dockerfile. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStringsStrategy\": \"any\", \"matchStrings\": [ \"ENV [A-Z]+_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)(\\\\&versioning=(?<versioning>.*?))?\\\\s\", \"FROM (?<depName>\\\\S*):(?<currentValue>\\\\S*)\" ], \"datasourceTemplate\": \"docker\" } ] } a Dockerfile: FROM amd64/ubuntu:18.04 ENV GRADLE_VERSION=6.2 # gradle-version/gradle&versioning=maven ENV NODE_VERSION=10.19.0 # github-tags/nodejs/node&versioning=node","title":"any"},{"location":"configuration-options/#recursive","text":"If using recursive the matchStrings will be looped through and the full match of the last will define the range of the next one. This can be used to narrow down the search area to prevent multiple matches. However, the recursive strategy still allows the matching of multiple dependencies as described below. All matches of the first matchStrings pattern are detected, then each of these matches will used as basis be used as the input for the next matchStrings pattern, and so on. If the next matchStrings pattern has multiple matches then it will split again. This process will be followed as long there is a match plus a next matchingStrings pattern is available or a dependency is detected. This is an example how this can work. The first regex manager will only upgrade grafana/loki as looks for the backup key then looks for the test key and then uses this result for extraction of necessary attributes. However, the second regex manager will upgrade both definitions as its first matchStrings matches both test keys. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^example.json$\"], \"matchStringsStrategy\": \"recursive\", \"matchStrings\": [ \"\\\"backup\\\":\\\\s*{[^}]*}\", \"\\\"test\\\":\\\\s*\\\\{[^}]*}\", \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\": \"docker\" }, { \"fileMatch\": [\"^example.json$\"], \"matchStringsStrategy\": \"recursive\", \"matchStrings\": [ \"\\\"test\\\":\\\\s*\\\\{[^}]*}\", \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\": \"docker\" } ] } example.json: { \"backup\": { \"test\": { \"name\": \"grafana/loki\", \"type\": \"docker\", \"value\": \"1.6.1\" } }, \"setup\": { \"test\": { \"name\": \"python\", \"type\": \"docker\", \"value\": \"3.9.0\" } } }","title":"recursive"},{"location":"configuration-options/#combination","text":"This option allows the possibility to combine the values of multiple lines inside a file. While using multiple lines is also possible using both other matchStringStrategy values, the combination approach is less susceptible to white space or line breaks stopping a match. combination will only match at most one dependency per file, so if you want to update multiple dependencies using combination you have to define multiple regex managers. Matched group values will be merged to form a single dependency. renovate.json: { \"regexManagers\": [ { \"fileMatch\": [\"^main.yml$\"], \"matchStringsStrategy\": \"combination\", \"matchStrings\": [ \"prometheus_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\", \"prometheus_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\": \"docker\" }, { \"fileMatch\": [\"^main.yml$\"], \"matchStringsStrategy\": \"combination\", \"matchStrings\": [ \"thanos_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\", \"thanos_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\": \"docker\" } ] } Ansible variable file ( yaml ): prometheus_image: \"prom/prometheus\" // a comment prometheus_version: \"v2.21.0\" // a comment ------ thanos_image: \"prom/prometheus\" // a comment thanos_version: \"0.15.0\" // a comment In the above example, each regex manager will match a single dependency each.","title":"combination"},{"location":"configuration-options/#depnametemplate","text":"Optional depName for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depName cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result.","title":"depNameTemplate"},{"location":"configuration-options/#lookupnametemplate","text":"Optional lookupName for extracted dependencies, else defaults to depName value. Valid only within a regexManagers object. Name Value type string parent regexManagers default null lookupName is used for looking up dependency versions. It will be compiled using Handlebars and the regex groups result. It will default to the value of depName if left unconfigured/undefined.","title":"lookupNameTemplate"},{"location":"configuration-options/#datasourcetemplate","text":"Optional datasource for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the datasource for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"datasourceTemplate"},{"location":"configuration-options/#versioningtemplate","text":"Optional versioning for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the versioning for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"versioningTemplate"},{"location":"configuration-options/#registryurltemplate","text":"Optional registry URL for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the registryUrls for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"registryUrlTemplate"},{"location":"configuration-options/#registryurls","text":"List of URLs to try for dependency lookup. Package manager specific. Name Value type array subType string Usually Renovate is able to either (a) use the default registries for a datasource, or (b) automatically detect during the manager extract phase which custom registries are in use. In case there is a need to configure them manually, it can be done using this registryUrls field, typically using packageUrls like so: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"registryUrls\": [\"https://docker.mycompany.domain\"] } ] } The field supports multiple URLs however it is datasource-dependent on whether only the first is used or multiple.","title":"registryUrls"},{"location":"configuration-options/#requiredstatuschecks","text":"List of status checks that must pass before automerging. Set to null to enable automerging without tests. Name Value type array subType string Currently Renovate's default behavior is to only automerge if every status check has succeeded. Setting this option to null means that Renovate will ignore all status checks. You need to set this if you don't have any status checks but still want Renovate to automerge PRs. In future, this might be configurable to allow certain status checks to be ignored/required. See issue 1853 at the renovate repository for more details.","title":"requiredStatusChecks"},{"location":"configuration-options/#respectlatest","text":"Ignore versions newer than npm \"latest\" version. Name Value type boolean default true Similar to ignoreUnstable , this option controls whether to update to versions that are greater than the version tagged as latest in the repository. By default, renovate will update to a version greater than latest only if the current version is itself past latest.","title":"respectLatest"},{"location":"configuration-options/#reviewers","text":"Requested reviewers for Pull Requests (either username or email address depending on the platform). Name Value type array subType string Must be valid usernames. If on GitHub and assigning a team to review, use the prefix team: , e.g. provide a value like team:someteam .","title":"reviewers"},{"location":"configuration-options/#reviewersfromcodeowners","text":"Determine reviewers based on configured code owners and changes in PR. Name Value type boolean default false If enabled Renovate will try to determine PR reviewers by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations.","title":"reviewersFromCodeOwners"},{"location":"configuration-options/#reviewerssamplesize","text":"Take a random sample of given size from reviewers. Name Value type integer Take a random sample of given size from reviewers.","title":"reviewersSampleSize"},{"location":"configuration-options/#rollbackprs","text":"Create PRs to roll back versions if the current version is not found in the registry. Name Value type boolean default false Configure this to false either globally, per-language, or per-package if you want to disable Renovate's behavior of generating rollback PRs when it can't find the current version on the registry anymore.","title":"rollbackPrs"},{"location":"configuration-options/#ruby","text":"Configuration object for Ruby language. Name Value type object mergeable true","title":"ruby"},{"location":"configuration-options/#rust","text":"Configuration option for Rust package management. Name Value type object mergeable true","title":"rust"},{"location":"configuration-options/#schedule","text":"Times of day/week to limit branch creation to. Name Value type array subType string The schedule option allows you to define times of week or month for Renovate updates. Running Renovate around the clock may seem too \"noisy\" for some projects and therefore schedule is a good way to reduce the noise by reducing the timeframe in which Renovate will operate on your repository. The default value for schedule is \"at any time\", which is functionally the same as declaring a null schedule. i.e. Renovate will run on the repository around the clock. The easiest way to define a schedule is to use a preset if one of them fits your requirements. See Schedule presets for details and feel free to request a new one in the source repository if you think others would benefit from it too. Otherwise, here are some text schedules that are known to work: every weekend before 5:00am after 10pm and before 5:00am after 10pm and before 5am every weekday on friday and saturday every 3 months on the first day of the month One example might be that you don't want Renovate to run during your typical business hours, so that your build machines don't get clogged up testing package.json updates. You could then configure a schedule like this at the repository level: { \"schedule\": [\"after 10pm and before 5am every weekday\", \"every weekend\"] } This would mean that Renovate can run for 7 hours each night plus all the time on weekends. This scheduling feature can also be particularly useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to only monthly updates, you could add this package rule: { \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"extends\": [\"schedule:monthly\"] } ] } Technical details: We mostly rely on the text parsing of the library later but only its concepts of \"days\", \"time_before\", and \"time_after\" (Renovate does not support scheduled minutes or \"at an exact time\" granularity).","title":"schedule"},{"location":"configuration-options/#semanticcommitscope","text":"Commit scope to use if Semantic Commits are enabled. Name Value type string default \"deps\" By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"package\" then it will look like \"chore(package):\" . You can also use parentDir or baseDir to namespace your commits for monorepos e.g. \"{{parentDir}}\" .","title":"semanticCommitScope"},{"location":"configuration-options/#semanticcommittype","text":"Commit type to use if Semantic Commits is enabled. Name Value type string default \"chore\" By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"ci\" then it will look like \"ci(deps):\" .","title":"semanticCommitType"},{"location":"configuration-options/#semanticcommits","text":"Enable Semantic Commit prefixes for commits and PR titles. Name Value type string allowedValues auto,enabled,disabled default \"auto\" If you are using a semantic prefix for your commits, then you will want to enable this setting. Although it's configurable to a package-level, it makes most sense to configure it at a repository level. If configured to enabled , then the semanticCommitScope and semanticCommitType fields will be used for each commit message and PR title. However, please note that Renovate will autodetect if your repository is already using semantic commits or not and follow suit, so you only really need to configure this if you wish to override Renovate's autodetected setting.","title":"semanticCommits"},{"location":"configuration-options/#separatemajorminor","text":"If set to false, it will upgrade dependencies to latest release only, and not separate major/minor branches. Name Value type boolean default true Renovate's default behavior is to create a separate branch/PR if both minor and major version updates exist (note that your choice of rangeStrategy value can influence which updates exist in the first place however). For example, if you were using Webpack 2.0.0 and versions 2.1.0 and 3.0.0 were both available, then Renovate would create two PRs so that you have the choice whether to apply the minor update to 2.x or the major update of 3.x. If you were to apply the minor update then Renovate would keep updating the 3.x branch for you as well, e.g. if Webpack 3.0.1 or 3.1.0 were released. If instead you applied the 3.0.0 update then Renovate would clean up the unneeded 2.x branch for you on the next run. It is recommended that you leave this setting to true , because of the polite way that Renovate handles this. For example, let's say in the above example that you decided you wouldn't update to Webpack 3 for a long time and don't want to build/test every time a new 3.x version arrives. In that case, simply close the \"Update Webpack to version 3.x\" PR and it won't be recreated again even if subsequent Webpack 3.x versions are released. You can continue with Webpack 2.x for as long as you want and receive any updates/patches that are made for it. Then eventually when you do want to update to Webpack 3.x you can make that update to package.json yourself and commit it to master once it's tested. After that, Renovate will resume providing you updates to 3.x again! i.e. if you close a major upgrade PR then it won't come back again, but once you make the major upgrade yourself then Renovate will resume providing you with minor or patch updates.","title":"separateMajorMinor"},{"location":"configuration-options/#separateminorpatch","text":"If set to true, it will separate minor and patch updates into separate branches. Name Value type boolean default false By default, Renovate won't distinguish between \"patch\" (e.g. 1.0.x) and \"minor\" (e.g. 1.x.0) releases - it groups them together. E.g., if you are running version 1.0.0 of a package and both versions 1.0.1 and 1.1.0 are available then Renovate will raise a single PR for version 1.1.0. If you wish to distinguish between patch and minor upgrades, for example if you wish to automerge patch but not minor, then you can configured this option to true .","title":"separateMinorPatch"},{"location":"configuration-options/#separatemultiplemajor","text":"If set to true, PRs will be raised separately for each available major upgrade version. Name Value type boolean default false Configure this to true if you wish to receive one PR for every separate major version upgrade of a dependency. e.g. if you are on webpack@v1 currently then default behavior is a PR for upgrading to webpack@v3 and not for webpack@v2. If this setting is true then you would get one PR for webpack@v2 and one for webpack@v3.","title":"separateMultipleMajor"},{"location":"configuration-options/#stabilitydays","text":"Number of days required before a new release is considered to be stabilized. Name Value type integer default 0 If this is configured to a non-zero value, and an update has a release date/timestamp available, then Renovate will check if the configured \"stability days\" have elapsed. If the days since the release is less than the configured stability days then a \"pending\" status check will be added to the branch. If enough days have passed then a passing status check will be added. There are a couple of uses for this:","title":"stabilityDays"},{"location":"configuration-options/#suppress-branchpr-creation-for-x-days","text":"If you combine stabilityDays=3 and prCreation=\"not-pending\" then Renovate will hold back from creating branches until 3 or more days have elapsed since the version was released. It's recommended that you enable dependencyDashboard=true so you don't lose visibility of these pending PRs.","title":"Suppress branch/PR creation for X days"},{"location":"configuration-options/#await-x-days-before-automerging","text":"If you have both automerge as well as stabilityDays enabled, it means that PRs will be created immediately but automerging will be delayed until X days have passed. This works because Renovate will add a \"renovate/stability-days\" pending status check to each branch/PR and that pending check will prevent the branch going green to automerge.","title":"Await X days before Automerging"},{"location":"configuration-options/#supportpolicy","text":"Dependency support policy, e.g. used for LTS vs non-LTS etc (Node only). Name Value type array subType string Language support is limited to those listed below: Node.js - Read our Node.js documentation","title":"supportPolicy"},{"location":"configuration-options/#suppressnotifications","text":"Options to suppress various types of warnings and other notifications. Name Value type array subType string allowedValues prIgnoreNotification,branchAutomergeFailure,lockFileErrors,artifactErrors,deprecationWarningIssues,onboardingClose mergeable true Use this field to suppress various types of warnings and other notifications from Renovate. Example: { \"suppressNotifications\": [\"prIgnoreNotification\"] } The above config will suppress the comment which is added to a PR whenever you close a PR unmerged.","title":"suppressNotifications"},{"location":"configuration-options/#timezone","text":"IANA Time Zone Name Value type string default null It is only recommended to configure this field if you wish to use the schedules feature and want to write them in your local timezone. Please see the above link for valid timezone names.","title":"timezone"},{"location":"configuration-options/#transitiveremediation","text":"Enable remediation of transitive dependencies. Name Value type boolean default false When enabled, Renovate will attempt to remediate vulnerabilities even if they exist only in transitive dependencies. Applicable only for GitHub platform (with vulnerability alerts enabled), npm manager, and when a package-lock.json v1 format is present. This is considered a feature flag with the aim to remove it and default to this behavior once it has been more widely tested.","title":"transitiveRemediation"},{"location":"configuration-options/#unicodeemoji","text":"Enable or disable Unicode emoji. Name Value type boolean default true If enabled emoji shortcodes ( :warning: ) are replaced with their unicode equivalents ( \u26a0\ufe0f )","title":"unicodeEmoji"},{"location":"configuration-options/#updateinternaldeps","text":"Whether to update internal dep versions in a monorepo (Lerna or Yarn Workspaces). Name Value type boolean default false Renovate defaults to skipping any internal package dependencies within monorepos. In such case dependency versions won't be updated by Renovate. To opt in to letting Renovate update internal package versions normally, set this configuration option to true.","title":"updateInternalDeps"},{"location":"configuration-options/#updatelockfiles","text":"Set to false to disable lock file updating. Name Value type boolean default true","title":"updateLockFiles"},{"location":"configuration-options/#updatenotscheduled","text":"Whether to update (but not create) branches when not scheduled. Name Value type boolean default true When schedules are in use, it generally means \"no updates\". However there are cases where updates might be desirable - e.g. if you have configured prCreation=not-pending, or you have rebaseStale=true and master branch is updated so you want Renovate PRs to be rebased. This defaults to true , meaning that Renovate will perform certain \"desirable\" updates to existing PRs even when outside of schedule. If you wish to disable all updates outside of scheduled hours then configure this field to false .","title":"updateNotScheduled"},{"location":"configuration-options/#versioning","text":"Versioning to use for filtering and comparisons. Name Value type string allowedValues cargo,composer,docker,git,gradle,hashicorp,hex,ivy,loose,maven,node,npm,nuget,pep440,poetry,regex,ruby,semver,swift,ubuntu default \"semver\" Usually, each language or package manager has a specific type of \"versioning\". e.g. JavaScript uses npm's semver implementation, Python uses pep440, etc. At Renovate we have also implemented some of our own, such as \"docker\" to address the most common way people tag versions using Docker, and \"loose\" as a fallback that tries semver first but otherwise just does its best to sort and compare. By exposing versioning to config, it allows you to override the default versioning for a package manager if you really need. In most cases it would not be recommended, but there are some cases such as Docker or Gradle where versioning is not strictly defined and you may need to specify the versioning type per-package.","title":"versioning"},{"location":"configuration-options/#vulnerabilityalerts","text":"Config to apply when a PR is necessary due to vulnerability of existing package version. Name Value type object mergeable true Use this object to customise PRs that are raised when vulnerability alerts are detected (GitHub-only). For example, to configure custom labels and assignees: { \"vulnerabilityAlerts\": { \"labels\": [\"security\"], \"assignees\": [\"@rarkins\"] } } To disable vulnerability alerts completely, configure like this: { \"vulnerabilityAlerts\": { \"enabled\": false } }","title":"vulnerabilityAlerts"},{"location":"configuration-options/#yarnrc","text":"String copy of yarnrc file. Use \\n instead of line breaks. Name Value type string default null","title":"yarnrc"},{"location":"configuration-templates/","text":"Config Template Editing This document describes how you can edit branch names, commit messages, PR titles and PR content. Branch Name The branch name is very important for Renovate because it helps determine \"grouping\" of updates, and also makes it efficient when an existing PR needs to be updated when a newer version of a package is released. If you change the branchPrefix while you have ignored some upgrades (closed PR without merging), you might get a duplicate PR after the new branchPrefix setting is picked up by the bot. branchName default value is {{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}} . The most common branch name you will see looks like this: renovate/react-16.x . In this example, the branchPrefix is the default renovate/ , additionalBranchPrefix is empty, and branchTopic is react-16.x . Most users will be happy with the default branchPrefix of renovate/ , but you can change this if you don't like the default. Say you don't want the forward slashes, in that case you would use renovate- as your branchPrefix . The onboarding PR will always use renovate/configure . additionalBranchPrefix is optional and by default is empty for all JavaScript dependencies. We use docker- for all Docker updates, branches will look like this: renovate/docker-ubuntu-16.x . branchTopic depends on the package manager and upgrade type, so you will see a lot of variety. This is probably a setting you want to change yourself. Be careful, and consider creating a new \"config help\" post at the discussions tab in the Renovate repository to get help from the Renovate team with your config. Commit Message Renovate will use one commit per branch, this makes it easy for you to merge. As such, the commitMessage reflects the contents of the branch and is usually the same as the PR title. commitMessage has a default value of {{commitMessagePrefix}} {{commitMessageAction}} {{commitMessageTopic}} {{commitMessageExtra}} {{commitMessageSuffix}} , with the intention that you only edit some of those subcomponents. You usually don't need to edit commitMessagePrefix , this option is used by Renovate if it needs to add a prefix to conform to the Semantic Commit convention. Do not touch this unless you know what you're doing. commitMessageAction is usually just one word, e.g. 'Update', 'Pin', 'Refresh', etc. You're probably fine leaving this setting alone, though you can change it. e.g. if you prefer that Renovate uses the term 'Upgrade' instead of 'Update' then you could configure \"commitMessageAction\": \"Upgrade\" . commitMessageTopic is usually two to three words that identify what is being updated. e.g. it might be dependency react or Docker image ubuntu . You may want to edit this. If you think your new commitMessageTopic is helpful for others, please open a PR . commitMessageExtra refers to the version being updated to. e.g. to v16 for a major upgrade, or to v16.0.3 for a patch update. It can be empty in some cases, like if the action/topic doesn't change a package version, e.g. Pin Docker digests . commitMessageSuffix defaults to empty but is currently used in two cases: Differentiating major from non-major groups Differentiating between PRs from different base branches, maybe for major updates you always want the PR to end with (MAJOR) , for instance commitBody is used if you wish to add multi-line commit messages, such as for the Signed-off-by fields, or adding [skip-ci] , etc. It is appended to the generated commitMessage , separated by a newline. PR Title Because commit messages match with the PR title, the PR title template defaults to null and inherits/copies the value from commitMessage . If you have a requirement where prTitle should be different from commitMessage , then please raise a feature request for discussion. PR Body You can change the PR body in the following ways: Change the entire layout/flow by using prBodyTemplate (we do not recommend this) Add a header by using prHeader Add a footer by using prFooter Add a note by using prBodyNotes Edit the embedded table by using prBodyDefinitions and prBodyColumns","title":"Config Template Editing"},{"location":"configuration-templates/#config-template-editing","text":"This document describes how you can edit branch names, commit messages, PR titles and PR content.","title":"Config Template Editing"},{"location":"configuration-templates/#branch-name","text":"The branch name is very important for Renovate because it helps determine \"grouping\" of updates, and also makes it efficient when an existing PR needs to be updated when a newer version of a package is released. If you change the branchPrefix while you have ignored some upgrades (closed PR without merging), you might get a duplicate PR after the new branchPrefix setting is picked up by the bot. branchName default value is {{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}} . The most common branch name you will see looks like this: renovate/react-16.x . In this example, the branchPrefix is the default renovate/ , additionalBranchPrefix is empty, and branchTopic is react-16.x . Most users will be happy with the default branchPrefix of renovate/ , but you can change this if you don't like the default. Say you don't want the forward slashes, in that case you would use renovate- as your branchPrefix . The onboarding PR will always use renovate/configure . additionalBranchPrefix is optional and by default is empty for all JavaScript dependencies. We use docker- for all Docker updates, branches will look like this: renovate/docker-ubuntu-16.x . branchTopic depends on the package manager and upgrade type, so you will see a lot of variety. This is probably a setting you want to change yourself. Be careful, and consider creating a new \"config help\" post at the discussions tab in the Renovate repository to get help from the Renovate team with your config.","title":"Branch Name"},{"location":"configuration-templates/#commit-message","text":"Renovate will use one commit per branch, this makes it easy for you to merge. As such, the commitMessage reflects the contents of the branch and is usually the same as the PR title. commitMessage has a default value of {{commitMessagePrefix}} {{commitMessageAction}} {{commitMessageTopic}} {{commitMessageExtra}} {{commitMessageSuffix}} , with the intention that you only edit some of those subcomponents. You usually don't need to edit commitMessagePrefix , this option is used by Renovate if it needs to add a prefix to conform to the Semantic Commit convention. Do not touch this unless you know what you're doing. commitMessageAction is usually just one word, e.g. 'Update', 'Pin', 'Refresh', etc. You're probably fine leaving this setting alone, though you can change it. e.g. if you prefer that Renovate uses the term 'Upgrade' instead of 'Update' then you could configure \"commitMessageAction\": \"Upgrade\" . commitMessageTopic is usually two to three words that identify what is being updated. e.g. it might be dependency react or Docker image ubuntu . You may want to edit this. If you think your new commitMessageTopic is helpful for others, please open a PR . commitMessageExtra refers to the version being updated to. e.g. to v16 for a major upgrade, or to v16.0.3 for a patch update. It can be empty in some cases, like if the action/topic doesn't change a package version, e.g. Pin Docker digests . commitMessageSuffix defaults to empty but is currently used in two cases: Differentiating major from non-major groups Differentiating between PRs from different base branches, maybe for major updates you always want the PR to end with (MAJOR) , for instance commitBody is used if you wish to add multi-line commit messages, such as for the Signed-off-by fields, or adding [skip-ci] , etc. It is appended to the generated commitMessage , separated by a newline.","title":"Commit Message"},{"location":"configuration-templates/#pr-title","text":"Because commit messages match with the PR title, the PR title template defaults to null and inherits/copies the value from commitMessage . If you have a requirement where prTitle should be different from commitMessage , then please raise a feature request for discussion.","title":"PR Title"},{"location":"configuration-templates/#pr-body","text":"You can change the PR body in the following ways: Change the entire layout/flow by using prBodyTemplate (we do not recommend this) Add a header by using prHeader Add a footer by using prFooter Add a note by using prBodyNotes Edit the embedded table by using prBodyDefinitions and prBodyColumns","title":"PR Body"},{"location":"configure-renovate/","text":"Configure Renovate (Onboarding PR) Once you have enabled Renovate on a repository, you will receive a \"Configure Renovate\" Pull Request looking something like this: No risk onboarding Conveniently, Renovate will not make any changes to your repository or raise any further Pull Requests until after you merge this initial Pull Request. If there is anything about the Pull Request that you don't like or understand, take your time to read the documentation or ask questions on the discussions forum on GitHub and merge the PR only once you're satisfied with the result. You can edit your Renovate configuration within the renovate/configure branch and Renovate will keep updating the description in the PR to match, so you can keep doing that until you're satisfied with the results. Check for warnings If you have any Warnings or Errors listed, see if you need or want to make any changes to address them. If you do, then make them in your base branch (e.g. master ) so that Renovate can recreate its Configure Renovate PR from it on its next cycle. Configuration location The \"Configure Renovate\" PR will include a renovate.json file in the root directory, with suggested default settings. If you don't want a renovate.json file in your repository you can use one of the following files instead: renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json package.json You can add the same settings to a \"renovate\" section in your package.json file instead. The package.json file must be located at the root of your repository. This is handy if you are already using a package.json file anyway, e.g. when you're working on a JavaScript project. The configuration in your package.json will apply to the whole project (this includes other, nested package.json files). Customised defaults Most of the settings in the renovate.json onboarding configuration are defaults, however usually this configuration file will have some default overrides in it, such as: Automatically enabling Angular-style semantic commits if your repository uses them Determining whether to use dependency range pinning depending on the detected project type (app vs library) Common overrides Please check the docs on this website for an exhaustive Configuration Reference. To help you get started, here are some of the most commonly changed (overridden) configuration settings: rangeStrategy : By default (with zero config) it's \"replace\" however the \"config:base\" preset overrides it to \"auto\" . If you don't want to pin dependency versions and retain ranges, add the \":preserveSemverRanges\" preset to the extends array labels : Labels to assign to Pull Requests assignees : GitHub user(s) to assign the Pull Requests to Renovate will update your PR description each time it finds changes. Merge Once you're done checking and configuring in your Configure Renovate PR, it's time to merge it to enable the real Pull Requests to begin.","title":"Configure Renovate (Onboarding PR)"},{"location":"configure-renovate/#configure-renovate-onboarding-pr","text":"Once you have enabled Renovate on a repository, you will receive a \"Configure Renovate\" Pull Request looking something like this:","title":"Configure Renovate (Onboarding PR)"},{"location":"configure-renovate/#no-risk-onboarding","text":"Conveniently, Renovate will not make any changes to your repository or raise any further Pull Requests until after you merge this initial Pull Request. If there is anything about the Pull Request that you don't like or understand, take your time to read the documentation or ask questions on the discussions forum on GitHub and merge the PR only once you're satisfied with the result. You can edit your Renovate configuration within the renovate/configure branch and Renovate will keep updating the description in the PR to match, so you can keep doing that until you're satisfied with the results.","title":"No risk onboarding"},{"location":"configure-renovate/#check-for-warnings","text":"If you have any Warnings or Errors listed, see if you need or want to make any changes to address them. If you do, then make them in your base branch (e.g. master ) so that Renovate can recreate its Configure Renovate PR from it on its next cycle.","title":"Check for warnings"},{"location":"configure-renovate/#configuration-location","text":"The \"Configure Renovate\" PR will include a renovate.json file in the root directory, with suggested default settings. If you don't want a renovate.json file in your repository you can use one of the following files instead: renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json","title":"Configuration location"},{"location":"configure-renovate/#packagejson","text":"You can add the same settings to a \"renovate\" section in your package.json file instead. The package.json file must be located at the root of your repository. This is handy if you are already using a package.json file anyway, e.g. when you're working on a JavaScript project. The configuration in your package.json will apply to the whole project (this includes other, nested package.json files).","title":"package.json"},{"location":"configure-renovate/#customised-defaults","text":"Most of the settings in the renovate.json onboarding configuration are defaults, however usually this configuration file will have some default overrides in it, such as: Automatically enabling Angular-style semantic commits if your repository uses them Determining whether to use dependency range pinning depending on the detected project type (app vs library)","title":"Customised defaults"},{"location":"configure-renovate/#common-overrides","text":"Please check the docs on this website for an exhaustive Configuration Reference. To help you get started, here are some of the most commonly changed (overridden) configuration settings: rangeStrategy : By default (with zero config) it's \"replace\" however the \"config:base\" preset overrides it to \"auto\" . If you don't want to pin dependency versions and retain ranges, add the \":preserveSemverRanges\" preset to the extends array labels : Labels to assign to Pull Requests assignees : GitHub user(s) to assign the Pull Requests to Renovate will update your PR description each time it finds changes.","title":"Common overrides"},{"location":"configure-renovate/#merge","text":"Once you're done checking and configuring in your Configure Renovate PR, it's time to merge it to enable the real Pull Requests to begin.","title":"Merge"},{"location":"dependency-pinning/","text":"Should you Pin your JavaScript Dependencies? Once you start using a tool/service like Renovate, probably the biggest decision you need to make is whether to \"pin\" your dependencies instead of using SemVer ranges. The answer is \"It's your choice\", however we can certainly make some generalisations/recommendations to help you. If you do not want to read the in-depth discussion, and just want our recommendations, you can skip to the bottom. What is Dependency Pinning? To ensure we're all talking about the same thing, it's important to define exactly what we mean by dependency \"pinning\". Historically, projects use SemVer ranges in their package.json . For instance, if you run npm install foobar you will see an entry like \"foobar\": \"^1.1.0\" added to your package.json . Verbosely, this means \"any foobar version greater than or equal to 1.1.0 but less than 2\". Therefore the project will automatically use 1.1.1 if it's released, or 1.2.0, or 1.2.1, etc - meaning you will get not only patch updates but also feature (minor) releases too. Another alternative is ranges like \"foobar\": \"~1.1.0\" which means \"any foobar version greater than or equal to 1.1.0 but less than 1.2\". This narrows the range to only patch updates to the 1.1 range. If instead you \"pin\" your dependencies rather than use ranges, it means you use exact entries like \"foobar\": \"1.1.0\" which means \"use only foobar version 1.1.0 and no other\". Why use ranges? For projects of any type, the main reason to use ranges is so that you can \"automatically\" get updated releases - which may even include security fixes. By \"automatically\", we mean that any time you run npm install you will get the very latest version matching your SemVer - assuming you're not using a lock file, that is. Tilde vs Caret If you're familiar with the theory of SemVer, you might think that you only need to use tilde ranges (e.g. \"~1.1.0\" ) to get bug fixes, rather than caret ranges (e.g. \"^1.1.0\" ). This is true in theory but not in practice. The reality is that for most projects, fixes are not \"backported\" to previous minor releases, and minor releases themselves may include fixes. So for example release 1.2.0 may include one new feature and one fix, so if you stick with 1.1.0 then you will miss out on the fix as there will never be a 1.1.1 once 1.2.0 is already released. This is the reality of most open source packages. Ranges for Libraries A second reason for using ranges applies to \"libraries\" that are published as npm packages with the intention that they are used/ require() 'd by other packages. In this case, it is usually a bad idea to pin all your dependencies because it will introduce an unnecessarily narrow range (one release!) and cause most users of your package to bloat their node_modules with duplicates. For example, you might have pinned foobar to version 1.1.0 and another author pinned his/her foobar dependency to 1.2.2 . Any user of both your packages will end up with npm attempting to install two separate versions of foobar , which might not even work. Even if both projects use a service like Renovate to keep their pinned dependencies up to date with the very latest versions, it's still not a good idea - there will always be times when one package has updated/released before the other one and they will be out of sync. e.g. there might be a space of 30 minutes where your package specifies foobar 1.1.0 and the other one specifies 1.1.1 and your joint downstream users end up with a duplicate. Why pin dependencies? You mainly pin versions for certainty, and visibility. When you have a pinned version of each dependency in your package.json , you know exactly which version of each dependency is installed at any time. This benefits when upgrading versions as well as when rolling back in case of problems. Note: we'll cover lock files later, don't worry. Upgrading pinned versions Let's say that a \"faulty\" version 1.2.0 of foobar is released and it breaks one of your tests. If you were using default caret SemVer ranges, then your master branch is now \"broken\" because its package.json says that any version 1.x above 1.1.0 is acceptable, and npm will choose the latest ( 1.2.0 ). You would need to manually check and work out which dependency caused the failure ( foobar may not have been the only dependency to have \"automatically\" upgraded since the last time your tests passed) and then you would need to pin the dependency yourself to stop npm installing 1.2.0 . Consider the same situation if instead you were pinning dependency versions. Your master would not be broken because it's pinned to foobar@1.1.0 - instead you'd just have a Pull Request for upgrading to foobar@1.2.0 which would fail. You'd know not to merge it and can wait for foobar@1.2.1 or later when it's fixed. Therefore you know exactly what you're running and you know exactly what failed - you have great \"visibility\". Now consider a similar theoretical scenario where foobar@1.2.0 is faulty but it is not caught by any of your automated tests. This is more common and more dangerous. If you were using SemVer ranges then this new version of foobar will likely be deployed to production automatically one day, sometime after which you notice errors and realise you need to fix it. Like before, you need to manually work out which dependency caused it - assuming you guess correctly that it was a new dependency version at fault - and pin it manually by editing package.json one dependency at a time. Alternatively, if you were instead pinning foobar then you would receive a PR for foobar@1.2.0 which awaits your approval. So first of all, you can choose to read the release notes and/or visually inspect the branch yourself before merging, hopefully saving you from pushing this faulty code to production. If you did not catch the fault before merging, you are still better off with a pinned version. If you discover something wrong in production, you can easily \"roll back\" commits in your development environment until you find which rollback fixes the problem. Then you can simply revert that commit (reversing foobar@1.1.0 -> foobar@1.2.0 ) and push that to master . When the next release of foobar comes out (e.g. 1.2.1 ) you will be prompted with a new PR and hopefully inspect it carefully this time before merge! As you can see in the above, pinning dependencies makes your build more consistent and predictable as a developer. Downside of pinned dependencies - upgrade \"noise\" The one major downside to your development workflow of pinning dependencies is the potential for increased \"noise\" in your repository. As mentioned above, you can expect to receive Pull Requests whenever there is a new version of your dependencies available. Depending on how many repositories you maintain, and how many dependencies are in each, you may find this default approach to be overwhelming (e.g. waking up to 10 new Pull Requests each day). Reducing the \"noise\" of dependency updates The increased volume of Pull Requests for upgrading dependencies may be considered by some to be undesirable \"noise\" in their day. To some extent this is simply a trade-off for having your dependencies pinned and predictable, however there are also ways you can reduce this noise while still gaining the majority of the benefits: Pull Request automerging There are some dependencies that either (a) don't have the potential to break something in production, or (b) are fully tested by your tests. For example, it's very hard for eslint to break anything in production. If your build/tests pass, then you are fine. Therefore you should consider enabling automerge for all lint packages to save yourself the pointless click when you manually approve them each time. In this case you might wake up to 5/10 of your overnight Pull Requests having already merged themselves. Another example of a good candidate for automerging might be a database driver like node-postgres ( pg on npm), if you have 100% test coverage of your API. In that case if the pg package has a minor or patch update and passes all tests then you may as well merge it automatically if you were not going to do a manual inspection anyway. Branch automerging In the above suggestion of Pull Request automerging, you might still find it annoying if you receive GitHub Notifications for every PR that is created and merged. In that case, you could set automergeType to branch , which means Renovate will: Create a new branch for testing Wait until after tests have completed Push the commit directly to master if tests pass, or Raise a PR only if tests failed With this approach, updates will be essentially \"silent\" - causing no notifications - but you will be able to see each commit on master of course. Scheduling Although it can feel satisfying to receive updates \"immediately\" when they're available, the reality is that you usually don't need updates so frequently. And worse still, npm package versions that are less than 24 hours can be unpublished , which would really break your build if you've pinned to a version that no longer exists. So to reduce the interruptions of automated dependency updates, consider putting Renovate on a schedule, such as: Update only on weekends? This way you update packages at most once per week, and your CI build runners are likely to be idle anyway Update daily, but between hours like midnight and 5am? That way notifications don't pop up in people's feed while they're working, and you also get the benefit of not tying up build machines when developers need to use them Grouping related packages Although it's good to isolate each dependency update for ease of troubleshooting, there are times when the extra noise isn't worth it, or when packages naturally belong together anyway (such as all babel packages). You can add a package rule in our Renovate configuration to group these together and you'll get just one branch combined even if multiple packages have updates available. Pinning Dependencies and Lock Files Since both yarn and npm@5 both support lock files, it's a common question to ask \"Why should I pin dependencies if I'm already using a lock file?\". It's a good question! Lock files are a great companion to SemVer ranges or pinning dependencies, because these files lock (pin) deeper into your dependency tree than you see in package.json . What a lock file will do for you When kept in sync with its associated package.json , a lock file will further lock down the exact dependencies and sub -dependencies that your project uses, so that everyone running npm install or yarn install will install the exact same dependencies as the person or bot that last updated the lock file. To reuse an earlier example, this means that you could have foobar@^1.1.0 in your package.json and be locked to 1.1.0 in your lock file, so that when the broken foobar@1.2.0 is released, nobody on the team installs it. What a lock file doesn't do for you If a lock file gets out of sync with its package.json , it can no longer be guaranteed to lock anything, and the package.json will be the source of truth for installs. The lock file has only delayed the inevitable problem, and provides much less visibility than package.json , because it's not designed to be human readable and is quite dense. If the package.json contains a range, and a new in-range version is released that would break the build, then essentially your package.json is in a state of \"broken\", even if the lock file is still holding things together. The upside is that the lockfile will hold back foobar to 1.1.0 unless it's forced to upgrade, so the break is postponed. The downside is how you will discover the break eventually. The easiest case is if for some reason you need to upgrade foobar , e.g. for a new feature it contains, so you might run something like yarn upgrade foobar . Then you might either discover the break during your development or when you push your new development to CI for testing. In this case, hopefully you'll guess it's foobar that broke it and not your own code. Alternatively, maybe someone thinks \"This lockfile is probably really out of date and might be missing some essential patches\" and decides to yarn upgrade the whole thing in one go. No doubt the diff will be full of green and red as many direct and indirect dependencies will have changed versions. Then it's pushed to CI for testing, fails, and you have to guess which of the changes caused it until you eventually narrow it down to foobar . This might require even manually looking through the lock file diffs line by line. Maybe dep blahblah also broke at the same time, to make it even harder. By ceding control of direct dependency versions to the lock file, you have lost the ability to know when things are updated. You also may be missing out on really important patches you're not even aware of, because they're \"in range\" yet locked back to vulnerable or buggy versions in the lock file. Reconsider the same scenario if foobar had instead been pinned to 1.1.0 in package.json . The (broken) upgrade to 1.2.0 would have been explicitly proposed to you via a Renovate PR, you would see the break, and know that the version is bad. Meanwhile you could be upgrading all the other essential fixes of other dependencies without worrying about foobar . You could even be running yarn upgrade regularly to be getting indirect package updates in the lockfile and seeing if everything still passes. Therefore, the lock file does not solve the same SemVer problems that pinning solves - but it compliments it. For this reason our usual recommendation using a lock file regardless of whether you pin dependencies or not, and pinning even if you have a lock file. Don't forget though that our motto is \"Flexible, so you don't need to be\", so go ahead and configure however you want. Also, we're open to ideas for how to make lock file updates more \"visible\" too. e.g. are you interested in a Renovate feature where you get a lockfile-only PR any time a direct dependency gets an in-range update? What about indirect/sub-dependencies? A good argument made by @LinusU is: pinning will only protect you against breakage in a, in many cases, small percentage of your packages. If you for example have installed express and pinned it, you will only protect yourself against a bad express release, it will not help with the 30 dependencies that express has. Because of this, I personally think that pinning dependencies just creates a false sense of security, and that using a lock file is superior in every way. It is true that pinning applies only to direct dependencies, and \"indirect\" dependencies typically count for a lot more in total in your lockfile than direct. e.g. those 30 ones that Express relies on. Does pinning give you \"increased\" security? Undeniably. The question is not whether it does, but whether that increased security comes at a cost (e.g. \"noise\"). But Linus also points out that a false sense of security is a cost too. Don't forget that there is some form of transitive trust too. You need to pick your direct dependencies carefully, and which versions of them you use. Hopefully in doing that you pick dependencies partly for how well they look after their own dependencies and versions (e.g. do they have good enough test coverage, do they use something like Renovate to keep updated, etc?). So the reality is that even if 90% of the entries in your lock file are indirect dependencies, those are ones you have somewhat \"delegated\" responsibility for to your dependencies. e.g. I'd hope that Express are even better at watching their deps for breaks than I am, to use the example above. But certainly \"does it give a false sense of security\" is not a question we can really answer quantifiably. So what's best? We recommend: Any apps (web or Node.js) that aren't require() 'd by other packages should pin all types of dependencies for greatest reliability/predictability Browser or dual browser/node.js libraries that are consumed/ required() 'd by others should keep using SemVer ranges for dependencies but can use pinned dependencies for devDependencies Node.js-only libraries can consider pinning all dependencies, because application size/duplicate dependencies are not as much a concern in Node.js compared to the browser. Of course, don't do that if your library is a micro one likely to be consumed in disk-sensitive environments Use a lock file As noted earlier, when you pin dependencies then you will see an increase in the raw volume of dependency updates, compared to if you use ranges. If/when this starts bothering you, add Renovate rules to reduce the volume, such as scheduling updates, grouping them, or automerging \"safe\" ones. References This is a \"living\" document and we plan to update it whenever we think of something new or someone makes a valid point we've missed or misunderstood. GitHub Location Updated 2018-01-19 after excellent feedback on lockfiles by @LinusU","title":"Should you Pin your Javascript Dependencies?"},{"location":"dependency-pinning/#should-you-pin-your-javascript-dependencies","text":"Once you start using a tool/service like Renovate, probably the biggest decision you need to make is whether to \"pin\" your dependencies instead of using SemVer ranges. The answer is \"It's your choice\", however we can certainly make some generalisations/recommendations to help you. If you do not want to read the in-depth discussion, and just want our recommendations, you can skip to the bottom.","title":"Should you Pin your JavaScript Dependencies?"},{"location":"dependency-pinning/#what-is-dependency-pinning","text":"To ensure we're all talking about the same thing, it's important to define exactly what we mean by dependency \"pinning\". Historically, projects use SemVer ranges in their package.json . For instance, if you run npm install foobar you will see an entry like \"foobar\": \"^1.1.0\" added to your package.json . Verbosely, this means \"any foobar version greater than or equal to 1.1.0 but less than 2\". Therefore the project will automatically use 1.1.1 if it's released, or 1.2.0, or 1.2.1, etc - meaning you will get not only patch updates but also feature (minor) releases too. Another alternative is ranges like \"foobar\": \"~1.1.0\" which means \"any foobar version greater than or equal to 1.1.0 but less than 1.2\". This narrows the range to only patch updates to the 1.1 range. If instead you \"pin\" your dependencies rather than use ranges, it means you use exact entries like \"foobar\": \"1.1.0\" which means \"use only foobar version 1.1.0 and no other\".","title":"What is Dependency Pinning?"},{"location":"dependency-pinning/#why-use-ranges","text":"For projects of any type, the main reason to use ranges is so that you can \"automatically\" get updated releases - which may even include security fixes. By \"automatically\", we mean that any time you run npm install you will get the very latest version matching your SemVer - assuming you're not using a lock file, that is.","title":"Why use ranges?"},{"location":"dependency-pinning/#tilde-vs-caret","text":"If you're familiar with the theory of SemVer, you might think that you only need to use tilde ranges (e.g. \"~1.1.0\" ) to get bug fixes, rather than caret ranges (e.g. \"^1.1.0\" ). This is true in theory but not in practice. The reality is that for most projects, fixes are not \"backported\" to previous minor releases, and minor releases themselves may include fixes. So for example release 1.2.0 may include one new feature and one fix, so if you stick with 1.1.0 then you will miss out on the fix as there will never be a 1.1.1 once 1.2.0 is already released. This is the reality of most open source packages.","title":"Tilde vs Caret"},{"location":"dependency-pinning/#ranges-for-libraries","text":"A second reason for using ranges applies to \"libraries\" that are published as npm packages with the intention that they are used/ require() 'd by other packages. In this case, it is usually a bad idea to pin all your dependencies because it will introduce an unnecessarily narrow range (one release!) and cause most users of your package to bloat their node_modules with duplicates. For example, you might have pinned foobar to version 1.1.0 and another author pinned his/her foobar dependency to 1.2.2 . Any user of both your packages will end up with npm attempting to install two separate versions of foobar , which might not even work. Even if both projects use a service like Renovate to keep their pinned dependencies up to date with the very latest versions, it's still not a good idea - there will always be times when one package has updated/released before the other one and they will be out of sync. e.g. there might be a space of 30 minutes where your package specifies foobar 1.1.0 and the other one specifies 1.1.1 and your joint downstream users end up with a duplicate.","title":"Ranges for Libraries"},{"location":"dependency-pinning/#why-pin-dependencies","text":"You mainly pin versions for certainty, and visibility. When you have a pinned version of each dependency in your package.json , you know exactly which version of each dependency is installed at any time. This benefits when upgrading versions as well as when rolling back in case of problems. Note: we'll cover lock files later, don't worry.","title":"Why pin dependencies?"},{"location":"dependency-pinning/#upgrading-pinned-versions","text":"Let's say that a \"faulty\" version 1.2.0 of foobar is released and it breaks one of your tests. If you were using default caret SemVer ranges, then your master branch is now \"broken\" because its package.json says that any version 1.x above 1.1.0 is acceptable, and npm will choose the latest ( 1.2.0 ). You would need to manually check and work out which dependency caused the failure ( foobar may not have been the only dependency to have \"automatically\" upgraded since the last time your tests passed) and then you would need to pin the dependency yourself to stop npm installing 1.2.0 . Consider the same situation if instead you were pinning dependency versions. Your master would not be broken because it's pinned to foobar@1.1.0 - instead you'd just have a Pull Request for upgrading to foobar@1.2.0 which would fail. You'd know not to merge it and can wait for foobar@1.2.1 or later when it's fixed. Therefore you know exactly what you're running and you know exactly what failed - you have great \"visibility\". Now consider a similar theoretical scenario where foobar@1.2.0 is faulty but it is not caught by any of your automated tests. This is more common and more dangerous. If you were using SemVer ranges then this new version of foobar will likely be deployed to production automatically one day, sometime after which you notice errors and realise you need to fix it. Like before, you need to manually work out which dependency caused it - assuming you guess correctly that it was a new dependency version at fault - and pin it manually by editing package.json one dependency at a time. Alternatively, if you were instead pinning foobar then you would receive a PR for foobar@1.2.0 which awaits your approval. So first of all, you can choose to read the release notes and/or visually inspect the branch yourself before merging, hopefully saving you from pushing this faulty code to production. If you did not catch the fault before merging, you are still better off with a pinned version. If you discover something wrong in production, you can easily \"roll back\" commits in your development environment until you find which rollback fixes the problem. Then you can simply revert that commit (reversing foobar@1.1.0 -> foobar@1.2.0 ) and push that to master . When the next release of foobar comes out (e.g. 1.2.1 ) you will be prompted with a new PR and hopefully inspect it carefully this time before merge! As you can see in the above, pinning dependencies makes your build more consistent and predictable as a developer.","title":"Upgrading pinned versions"},{"location":"dependency-pinning/#downside-of-pinned-dependencies-upgrade-noise","text":"The one major downside to your development workflow of pinning dependencies is the potential for increased \"noise\" in your repository. As mentioned above, you can expect to receive Pull Requests whenever there is a new version of your dependencies available. Depending on how many repositories you maintain, and how many dependencies are in each, you may find this default approach to be overwhelming (e.g. waking up to 10 new Pull Requests each day).","title":"Downside of pinned dependencies - upgrade \"noise\""},{"location":"dependency-pinning/#reducing-the-noise-of-dependency-updates","text":"The increased volume of Pull Requests for upgrading dependencies may be considered by some to be undesirable \"noise\" in their day. To some extent this is simply a trade-off for having your dependencies pinned and predictable, however there are also ways you can reduce this noise while still gaining the majority of the benefits:","title":"Reducing the \"noise\" of dependency updates"},{"location":"dependency-pinning/#pull-request-automerging","text":"There are some dependencies that either (a) don't have the potential to break something in production, or (b) are fully tested by your tests. For example, it's very hard for eslint to break anything in production. If your build/tests pass, then you are fine. Therefore you should consider enabling automerge for all lint packages to save yourself the pointless click when you manually approve them each time. In this case you might wake up to 5/10 of your overnight Pull Requests having already merged themselves. Another example of a good candidate for automerging might be a database driver like node-postgres ( pg on npm), if you have 100% test coverage of your API. In that case if the pg package has a minor or patch update and passes all tests then you may as well merge it automatically if you were not going to do a manual inspection anyway.","title":"Pull Request automerging"},{"location":"dependency-pinning/#branch-automerging","text":"In the above suggestion of Pull Request automerging, you might still find it annoying if you receive GitHub Notifications for every PR that is created and merged. In that case, you could set automergeType to branch , which means Renovate will: Create a new branch for testing Wait until after tests have completed Push the commit directly to master if tests pass, or Raise a PR only if tests failed With this approach, updates will be essentially \"silent\" - causing no notifications - but you will be able to see each commit on master of course.","title":"Branch automerging"},{"location":"dependency-pinning/#scheduling","text":"Although it can feel satisfying to receive updates \"immediately\" when they're available, the reality is that you usually don't need updates so frequently. And worse still, npm package versions that are less than 24 hours can be unpublished , which would really break your build if you've pinned to a version that no longer exists. So to reduce the interruptions of automated dependency updates, consider putting Renovate on a schedule, such as: Update only on weekends? This way you update packages at most once per week, and your CI build runners are likely to be idle anyway Update daily, but between hours like midnight and 5am? That way notifications don't pop up in people's feed while they're working, and you also get the benefit of not tying up build machines when developers need to use them","title":"Scheduling"},{"location":"dependency-pinning/#grouping-related-packages","text":"Although it's good to isolate each dependency update for ease of troubleshooting, there are times when the extra noise isn't worth it, or when packages naturally belong together anyway (such as all babel packages). You can add a package rule in our Renovate configuration to group these together and you'll get just one branch combined even if multiple packages have updates available.","title":"Grouping related packages"},{"location":"dependency-pinning/#pinning-dependencies-and-lock-files","text":"Since both yarn and npm@5 both support lock files, it's a common question to ask \"Why should I pin dependencies if I'm already using a lock file?\". It's a good question! Lock files are a great companion to SemVer ranges or pinning dependencies, because these files lock (pin) deeper into your dependency tree than you see in package.json .","title":"Pinning Dependencies and Lock Files"},{"location":"dependency-pinning/#what-a-lock-file-will-do-for-you","text":"When kept in sync with its associated package.json , a lock file will further lock down the exact dependencies and sub -dependencies that your project uses, so that everyone running npm install or yarn install will install the exact same dependencies as the person or bot that last updated the lock file. To reuse an earlier example, this means that you could have foobar@^1.1.0 in your package.json and be locked to 1.1.0 in your lock file, so that when the broken foobar@1.2.0 is released, nobody on the team installs it.","title":"What a lock file will do for you"},{"location":"dependency-pinning/#what-a-lock-file-doesnt-do-for-you","text":"If a lock file gets out of sync with its package.json , it can no longer be guaranteed to lock anything, and the package.json will be the source of truth for installs. The lock file has only delayed the inevitable problem, and provides much less visibility than package.json , because it's not designed to be human readable and is quite dense. If the package.json contains a range, and a new in-range version is released that would break the build, then essentially your package.json is in a state of \"broken\", even if the lock file is still holding things together. The upside is that the lockfile will hold back foobar to 1.1.0 unless it's forced to upgrade, so the break is postponed. The downside is how you will discover the break eventually. The easiest case is if for some reason you need to upgrade foobar , e.g. for a new feature it contains, so you might run something like yarn upgrade foobar . Then you might either discover the break during your development or when you push your new development to CI for testing. In this case, hopefully you'll guess it's foobar that broke it and not your own code. Alternatively, maybe someone thinks \"This lockfile is probably really out of date and might be missing some essential patches\" and decides to yarn upgrade the whole thing in one go. No doubt the diff will be full of green and red as many direct and indirect dependencies will have changed versions. Then it's pushed to CI for testing, fails, and you have to guess which of the changes caused it until you eventually narrow it down to foobar . This might require even manually looking through the lock file diffs line by line. Maybe dep blahblah also broke at the same time, to make it even harder. By ceding control of direct dependency versions to the lock file, you have lost the ability to know when things are updated. You also may be missing out on really important patches you're not even aware of, because they're \"in range\" yet locked back to vulnerable or buggy versions in the lock file. Reconsider the same scenario if foobar had instead been pinned to 1.1.0 in package.json . The (broken) upgrade to 1.2.0 would have been explicitly proposed to you via a Renovate PR, you would see the break, and know that the version is bad. Meanwhile you could be upgrading all the other essential fixes of other dependencies without worrying about foobar . You could even be running yarn upgrade regularly to be getting indirect package updates in the lockfile and seeing if everything still passes. Therefore, the lock file does not solve the same SemVer problems that pinning solves - but it compliments it. For this reason our usual recommendation using a lock file regardless of whether you pin dependencies or not, and pinning even if you have a lock file. Don't forget though that our motto is \"Flexible, so you don't need to be\", so go ahead and configure however you want. Also, we're open to ideas for how to make lock file updates more \"visible\" too. e.g. are you interested in a Renovate feature where you get a lockfile-only PR any time a direct dependency gets an in-range update?","title":"What a lock file doesn't do for you"},{"location":"dependency-pinning/#what-about-indirectsub-dependencies","text":"A good argument made by @LinusU is: pinning will only protect you against breakage in a, in many cases, small percentage of your packages. If you for example have installed express and pinned it, you will only protect yourself against a bad express release, it will not help with the 30 dependencies that express has. Because of this, I personally think that pinning dependencies just creates a false sense of security, and that using a lock file is superior in every way. It is true that pinning applies only to direct dependencies, and \"indirect\" dependencies typically count for a lot more in total in your lockfile than direct. e.g. those 30 ones that Express relies on. Does pinning give you \"increased\" security? Undeniably. The question is not whether it does, but whether that increased security comes at a cost (e.g. \"noise\"). But Linus also points out that a false sense of security is a cost too. Don't forget that there is some form of transitive trust too. You need to pick your direct dependencies carefully, and which versions of them you use. Hopefully in doing that you pick dependencies partly for how well they look after their own dependencies and versions (e.g. do they have good enough test coverage, do they use something like Renovate to keep updated, etc?). So the reality is that even if 90% of the entries in your lock file are indirect dependencies, those are ones you have somewhat \"delegated\" responsibility for to your dependencies. e.g. I'd hope that Express are even better at watching their deps for breaks than I am, to use the example above. But certainly \"does it give a false sense of security\" is not a question we can really answer quantifiably.","title":"What about indirect/sub-dependencies?"},{"location":"dependency-pinning/#so-whats-best","text":"We recommend: Any apps (web or Node.js) that aren't require() 'd by other packages should pin all types of dependencies for greatest reliability/predictability Browser or dual browser/node.js libraries that are consumed/ required() 'd by others should keep using SemVer ranges for dependencies but can use pinned dependencies for devDependencies Node.js-only libraries can consider pinning all dependencies, because application size/duplicate dependencies are not as much a concern in Node.js compared to the browser. Of course, don't do that if your library is a micro one likely to be consumed in disk-sensitive environments Use a lock file As noted earlier, when you pin dependencies then you will see an increase in the raw volume of dependency updates, compared to if you use ranges. If/when this starts bothering you, add Renovate rules to reduce the volume, such as scheduling updates, grouping them, or automerging \"safe\" ones.","title":"So what's best?"},{"location":"dependency-pinning/#references","text":"This is a \"living\" document and we plan to update it whenever we think of something new or someone makes a valid point we've missed or misunderstood. GitHub Location Updated 2018-01-19 after excellent feedback on lockfiles by @LinusU","title":"References"},{"location":"docker/","text":"Docker Renovate supports upgrading dependencies in various types of Docker definition files: Docker's Dockerfile files Docker Compose docker-compose.yml files CircleCI config files Kubernetes manifest files Ansible configuration files How It Works Renovate searches in each repository for any files matching each manager's configured fileMatch pattern(s) Matching files are parsed, Renovate checks if the file(s) contain any Docker image references (e.g. FROM lines in a Dockerfile ) If the image tag in use \"looks\" like a version (e.g. myimage:1 , myimage:1.1 , myimage:1.1.0 , myimage:1-onbuild ) then Renovate checks the Docker registry for upgrades (e.g. from myimage:1.1.0 to myimage:1.2.0 ) Preservation of Version Precision By default, Renovate preserves the precision level specified in the Docker images. For example, if the existing image is pinned at myimage:1.1 then Renovate only proposes upgrades to myimage:1.2 or myimage:1.3 . This means that you will not get upgrades to a more specific versions like myimage:1.2.0 or myimage:1.3.0 . Renovate does not yet support \"pinning\" an imprecise version to a precise version, e.g. from myimage:1.2 to myimage:1.2.0 , however it's a feature we'd like to implement one day. Version compatibility Although suffixes in SemVer indicate pre-releases (e.g. v1.2.0-alpha.2 ), in Docker they typically indicate compatibility, e.g. 1.2.0-alpine . By default Renovate assumes suffixes indicate compatibility, for this reason Renovate will not change any suffixes. Renovate will update 1.2.0-alpine to 1.2.1-alpine but never updates to 1.2.1 or 1.2.1-stretch as that would change the suffix. If this behavior does not suit a particular package you have, Renovate allows you to customize the versioning scheme it uses. For example, you have a Docker image foo/bar that sticks to SemVer versioning. This means that you need to tell Renovate that suffixes indicate pre-release versions, and not compatibility. You could then use this packageRules array, to tell Renovate to use semver versioning for the foo/bar package: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"foo/bar\"], \"versioning\": \"semver\" } ] } Another example is the official python image, which follows pep440 versioning. You can tell Renovate to use the pep440 versioning scheme with this set of packageRules : { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"pep440\" } ] } If traditional versioning doesn't work, try Renovate's built-in loose versioning . Renovate will perform a best-effort sort of the versions, regardless of whether they contain letters or digits. If both the traditional versioning, and the loose versioning do not give the results you want, try the regex versioning . This approach uses regex capture group syntax to specify which part of the version string is major, minor, patch, pre-release, or compatibility. See the docs for versioning for documentation and examples of regex versioning in action. Digest Pinning We recommend that you pin your Docker images to an exact digest. By pinning to a digest you ensure your Docker builds are immutable : every time you do a pull you get the same content. If you have experience with the way dependency versioning is handled in the JavaScript/npm ecosystem, you might be used to exact versions being immutable. e.g. if you specify a version like 2.0.1 , you and your colleagues always get the exact same \"code\". What you may not know is that Docker's tags are not immutable versions, even if they look like a version. e.g. you probably expect myimage:1 and myimage:1.2 to change over time, but you might incorrectly assume that myimage:1.2.0 never changes. Although it probably shouldn't , the reality is that any Docker image tag can change content, and potentially break. Using a Docker digest as the image's primary identifier instead of using a Docker tag will achieve immutability. It's not easy to work with strings like FROM node@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Luckily Renovate can update the digests for you, so you don't have to. To keep things simple, Renovate retains the Docker tag in the FROM line, e.g. FROM node:14.15.1@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Read on to see how Renovate updates Docker digests. Digest Updating If you follow our advice to go from a simple tag like node:14 to using a pinned digest node:14@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e , you will receive Renovate PRs whenever the node:14 image is updated on Docker Hub. Previously this update would have been \"invisible\" to you - one day you pull code that represents node:14.15.0 and the next day you get code that represents node:14.15.1 . But you can never be sure, especially as Docker caches. Perhaps some of your colleagues or worse still your build machine are stuck on an older version with a security vulnerability. By pinning to a digest instead, you will receive these updates via Pull Requests, or even committed directly to your repository if you enable branch automerge for convenience. This ensures everyone on the team uses the latest versions and is in sync. Version Upgrading Renovate also supports upgrading versions in Docker tags, e.g. from myimage:1.2.0 to myimage:1.2.1 or myimage:1.2 to myimage:1.3 . If a tag looks like a version, Renovate will upgrade it like a version. We recommend you use the major.minor.patch tagging scheme e.g. change from myimage:1 to myimage:1.1.1 . This way it's easy to see what the Renovate PR is going to change. You can see the difference between a PR that upgrades myimage from 1.1.1 to 1.1.2 . and a PR that changes the contents of the version you already use ( 1.1.1 ). Currently, Renovate will upgrade minor/patch versions (e.g. from 1.2.0 to 1.2.1 ) by default, but not upgrade major versions. If you wish to enable major versions then add the preset docker:enableMajor to your extends array in your renovate.json . Renovate has some Docker-specific intelligence when it comes to versions. For example: Configuring/Disabling If you wish to make changes that apply to all Docker managers, then add them to the docker config object. This is not foolproof, because some managers like circleci and ansible support multiple datasources that do not inherit from the docker config object. If you wish to override Docker settings for one particular type of manager, use that manager's config object instead. For example, to disable digest updates for Docker Compose only but leave them for other managers like Dockerfile , you would use this: \"docker-compose\": { \"digest\": { \"enabled\": false } } The following configuration options are applicable to Docker: Disable all Docker Renovation Add \"docker:disable\" to your extends array. Disable Renovate for only certain Dockerfiles Add all paths to ignore into the ignorePaths configuration field. e.g. { \"extends\": [\"config:base\"], \"ignorePaths\": [\"docker/old-files/\"] } Enable Docker major updates Add \"docker:enableMajor\" to your extends array. Disable digest pinning Add \"default:pinDigestsDisabled\" to your extends array. Automerge digest updates Add \"default:automergeDigest\" to your extends array. If you want Renovate to commit directly to your base branch without opening a PR first, add \"default:automergeBranchPush\" to the extends array. Registry authentication There are many different registries, and many ways to authenticate to those registries. We will explain how to authenticate for the most common registries. DockerHub Here is an example of configuring a default Docker username/password in config.js . The Docker Hub password is stored in a process environment variable. module.exports = { hostRules: [ { hostType: 'docker', username: '<your-username>', password: process.env.DOCKER_HUB_PASSWORD, }, ], }; You can add additional host rules, read the hostrules documentation for more information. Self-hosted Docker registry Say you host some Docker images yourself, and use a password to access your self-hosted Docker images. In addition to self-hosting, you also pull images from Docker Hub, without a password. In this example you would configure a specific Docker host like this: module.exports = { hostRules: [ { hostType: 'docker', hostName: 'your.host.io', username: '<your-username>', password: process.env.SELF_HOSTED_DOCKER_IMAGES_PASSWORD, }, ], }; ChartMuseum Maybe you're running your own ChartMuseum server to host your private Helm Charts. This is how you connect to a private Helm repository: module.exports = { hostRules: [ { hostName: 'your.host.io', username: '<your-username>', password: process.env.SELF_HOSTED_HELM_CHARTS_PASSWORD, }, ], }; If you need to configure per-repository credentials then you can also configure the above within a repository's Renovate config (e.g. renovate.json ).","title":"Docker"},{"location":"docker/#docker","text":"Renovate supports upgrading dependencies in various types of Docker definition files: Docker's Dockerfile files Docker Compose docker-compose.yml files CircleCI config files Kubernetes manifest files Ansible configuration files","title":"Docker"},{"location":"docker/#how-it-works","text":"Renovate searches in each repository for any files matching each manager's configured fileMatch pattern(s) Matching files are parsed, Renovate checks if the file(s) contain any Docker image references (e.g. FROM lines in a Dockerfile ) If the image tag in use \"looks\" like a version (e.g. myimage:1 , myimage:1.1 , myimage:1.1.0 , myimage:1-onbuild ) then Renovate checks the Docker registry for upgrades (e.g. from myimage:1.1.0 to myimage:1.2.0 )","title":"How It Works"},{"location":"docker/#preservation-of-version-precision","text":"By default, Renovate preserves the precision level specified in the Docker images. For example, if the existing image is pinned at myimage:1.1 then Renovate only proposes upgrades to myimage:1.2 or myimage:1.3 . This means that you will not get upgrades to a more specific versions like myimage:1.2.0 or myimage:1.3.0 . Renovate does not yet support \"pinning\" an imprecise version to a precise version, e.g. from myimage:1.2 to myimage:1.2.0 , however it's a feature we'd like to implement one day.","title":"Preservation of Version Precision"},{"location":"docker/#version-compatibility","text":"Although suffixes in SemVer indicate pre-releases (e.g. v1.2.0-alpha.2 ), in Docker they typically indicate compatibility, e.g. 1.2.0-alpine . By default Renovate assumes suffixes indicate compatibility, for this reason Renovate will not change any suffixes. Renovate will update 1.2.0-alpine to 1.2.1-alpine but never updates to 1.2.1 or 1.2.1-stretch as that would change the suffix. If this behavior does not suit a particular package you have, Renovate allows you to customize the versioning scheme it uses. For example, you have a Docker image foo/bar that sticks to SemVer versioning. This means that you need to tell Renovate that suffixes indicate pre-release versions, and not compatibility. You could then use this packageRules array, to tell Renovate to use semver versioning for the foo/bar package: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"foo/bar\"], \"versioning\": \"semver\" } ] } Another example is the official python image, which follows pep440 versioning. You can tell Renovate to use the pep440 versioning scheme with this set of packageRules : { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"pep440\" } ] } If traditional versioning doesn't work, try Renovate's built-in loose versioning . Renovate will perform a best-effort sort of the versions, regardless of whether they contain letters or digits. If both the traditional versioning, and the loose versioning do not give the results you want, try the regex versioning . This approach uses regex capture group syntax to specify which part of the version string is major, minor, patch, pre-release, or compatibility. See the docs for versioning for documentation and examples of regex versioning in action.","title":"Version compatibility"},{"location":"docker/#digest-pinning","text":"We recommend that you pin your Docker images to an exact digest. By pinning to a digest you ensure your Docker builds are immutable : every time you do a pull you get the same content. If you have experience with the way dependency versioning is handled in the JavaScript/npm ecosystem, you might be used to exact versions being immutable. e.g. if you specify a version like 2.0.1 , you and your colleagues always get the exact same \"code\". What you may not know is that Docker's tags are not immutable versions, even if they look like a version. e.g. you probably expect myimage:1 and myimage:1.2 to change over time, but you might incorrectly assume that myimage:1.2.0 never changes. Although it probably shouldn't , the reality is that any Docker image tag can change content, and potentially break. Using a Docker digest as the image's primary identifier instead of using a Docker tag will achieve immutability. It's not easy to work with strings like FROM node@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Luckily Renovate can update the digests for you, so you don't have to. To keep things simple, Renovate retains the Docker tag in the FROM line, e.g. FROM node:14.15.1@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Read on to see how Renovate updates Docker digests.","title":"Digest Pinning"},{"location":"docker/#digest-updating","text":"If you follow our advice to go from a simple tag like node:14 to using a pinned digest node:14@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e , you will receive Renovate PRs whenever the node:14 image is updated on Docker Hub. Previously this update would have been \"invisible\" to you - one day you pull code that represents node:14.15.0 and the next day you get code that represents node:14.15.1 . But you can never be sure, especially as Docker caches. Perhaps some of your colleagues or worse still your build machine are stuck on an older version with a security vulnerability. By pinning to a digest instead, you will receive these updates via Pull Requests, or even committed directly to your repository if you enable branch automerge for convenience. This ensures everyone on the team uses the latest versions and is in sync.","title":"Digest Updating"},{"location":"docker/#version-upgrading","text":"Renovate also supports upgrading versions in Docker tags, e.g. from myimage:1.2.0 to myimage:1.2.1 or myimage:1.2 to myimage:1.3 . If a tag looks like a version, Renovate will upgrade it like a version. We recommend you use the major.minor.patch tagging scheme e.g. change from myimage:1 to myimage:1.1.1 . This way it's easy to see what the Renovate PR is going to change. You can see the difference between a PR that upgrades myimage from 1.1.1 to 1.1.2 . and a PR that changes the contents of the version you already use ( 1.1.1 ). Currently, Renovate will upgrade minor/patch versions (e.g. from 1.2.0 to 1.2.1 ) by default, but not upgrade major versions. If you wish to enable major versions then add the preset docker:enableMajor to your extends array in your renovate.json . Renovate has some Docker-specific intelligence when it comes to versions. For example:","title":"Version Upgrading"},{"location":"docker/#configuringdisabling","text":"If you wish to make changes that apply to all Docker managers, then add them to the docker config object. This is not foolproof, because some managers like circleci and ansible support multiple datasources that do not inherit from the docker config object. If you wish to override Docker settings for one particular type of manager, use that manager's config object instead. For example, to disable digest updates for Docker Compose only but leave them for other managers like Dockerfile , you would use this: \"docker-compose\": { \"digest\": { \"enabled\": false } } The following configuration options are applicable to Docker:","title":"Configuring/Disabling"},{"location":"docker/#disable-all-docker-renovation","text":"Add \"docker:disable\" to your extends array.","title":"Disable all Docker Renovation"},{"location":"docker/#disable-renovate-for-only-certain-dockerfiles","text":"Add all paths to ignore into the ignorePaths configuration field. e.g. { \"extends\": [\"config:base\"], \"ignorePaths\": [\"docker/old-files/\"] }","title":"Disable Renovate for only certain Dockerfiles"},{"location":"docker/#enable-docker-major-updates","text":"Add \"docker:enableMajor\" to your extends array.","title":"Enable Docker major updates"},{"location":"docker/#disable-digest-pinning","text":"Add \"default:pinDigestsDisabled\" to your extends array.","title":"Disable digest pinning"},{"location":"docker/#automerge-digest-updates","text":"Add \"default:automergeDigest\" to your extends array. If you want Renovate to commit directly to your base branch without opening a PR first, add \"default:automergeBranchPush\" to the extends array.","title":"Automerge digest updates"},{"location":"docker/#registry-authentication","text":"There are many different registries, and many ways to authenticate to those registries. We will explain how to authenticate for the most common registries.","title":"Registry authentication"},{"location":"docker/#dockerhub","text":"Here is an example of configuring a default Docker username/password in config.js . The Docker Hub password is stored in a process environment variable. module.exports = { hostRules: [ { hostType: 'docker', username: '<your-username>', password: process.env.DOCKER_HUB_PASSWORD, }, ], }; You can add additional host rules, read the hostrules documentation for more information.","title":"DockerHub"},{"location":"docker/#self-hosted-docker-registry","text":"Say you host some Docker images yourself, and use a password to access your self-hosted Docker images. In addition to self-hosting, you also pull images from Docker Hub, without a password. In this example you would configure a specific Docker host like this: module.exports = { hostRules: [ { hostType: 'docker', hostName: 'your.host.io', username: '<your-username>', password: process.env.SELF_HOSTED_DOCKER_IMAGES_PASSWORD, }, ], };","title":"Self-hosted Docker registry"},{"location":"docker/#chartmuseum","text":"Maybe you're running your own ChartMuseum server to host your private Helm Charts. This is how you connect to a private Helm repository: module.exports = { hostRules: [ { hostName: 'your.host.io', username: '<your-username>', password: process.env.SELF_HOSTED_HELM_CHARTS_PASSWORD, }, ], }; If you need to configure per-repository credentials then you can also configure the above within a repository's Renovate config (e.g. renovate.json ).","title":"ChartMuseum"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) What is the default behavior? Renovate will: Look for configuration options in a configuration file (e.g. renovate.json ) and in each package.json file Find and process all package files (e.g. package.json , composer.json , Dockerfile , etc) in each repository Use separate branches/PR for each dependency Use separate branches for each major version of each dependency Pin devDependencies to a single version, rather than use ranges Pin dependencies to a single version if it appears not to be a library Update yarn.lock and/or package-lock.json files if found Create Pull Requests immediately after branch creation What if I need to .. ? Use an alternative branch as my Pull Request target Say your repository's default branch is master but you want Renovate to use the next branch as its PR target. You can configure the PR target branch via the baseBranches option. Add this line to the renovate.json file that's in the default branch ( master in this example). { \"baseBranches\": [\"next\"] } You can set more than one PR target branch in the baseBranches array. Support private npm modules See the dedicated Private npm module support page. Control Renovate's schedule Renovate itself will run as often as its administrator has configured it (e.g. hourly, daily, etc). You may want to update certain repositories less often. Or you may even want to use different schedules for specific packages. To control the days of the week or times of day that Renovate updates packages, use the timezone and schedule configuration options. By default, Renovate schedules use the UTC timezone, but you can override this in the global config. You can set a specific time zone in your local config file as well: { \"timezone\": \"America/Los_Angeles\" } The timezone must be a valid IANA time zone . With the timezone set, you can define days of week or hours of the day in which Renovate will make changes. Renovate uses the later library to parse the text. The later library also handles the concepts of \"days\", time_before\", and \"time_after\". Examples of the kind of schedules you can create: every weekend before 5:00am [after 10pm, before 5:00am] [after 10pm every weekday, before 5am every weekday] on friday and saturday The scheduling feature can be very useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to weekly updates, you could add this package rule: \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"schedule\": [\"after 9pm on sunday\"] } ] The \"schedule\" propery must always be defined in an array, even if you only set a single schedule. Multiple entries in the array means \"or\". Disable Renovate for certain dependency types Define a packageRules entry which has the dependency type(s) in matchDepTypes and \"enabled\": false . Use a single branch/PR for all dependency upgrades Add a configuration for configuration option groupName set to value \"all\" , at the top level of your renovate.json or package.json . Use separate branches per dependency, but not one per major release Set configuration option separateMajorMinor to false . Keep using SemVer ranges, instead of pinning dependencies Set configuration option rangeStrategy to \"replace\" . Keep lock files (including sub-dependencies) up-to-date, even when package.json hasn't changed By default, if you enable lock-file maintenance, Renovate will update the lockfile [\"before 5am on monday\"] . If you want to update the lock file more often, update the schedule field inside the lockFileMaintenance object. Wait until tests have passed before creating the PR Set the configuration option prCreation to \"status-success\" . Branches with failing tests will remain in Git and continue to get updated if necessary, but no PR will be created until their tests pass. Wait until tests have passed before creating a PR, but create the PR even if they fail Set the configuration option prCreation to \"not-pending\" . Assign PRs to specific user(s) Set the configuration option assignees to an array of usernames. Add labels to PRs Set the configuration option labels to an array of labels to use. Apply a rule, but only to package abc ? Add a packageRules array to your configuration Create one object inside this array Set field matchPackageNames to value [\"abc\"] Add the configuration option to the same object e.g. \"packageRules\": [ { \"matchPackageNames\": [\"abc\"], \"assignees\": [\"importantreviewer\"] } ] Apply a rule, but only for packages starting with abc Do the same as above, but instead of using matchPackageNames , use matchPackagePatterns and a regex: \"packageRules\": [ { \"matchPackagePatterns\": \"^abc\", \"assignees\": [\"importantreviewer\"] } ] Group all packages starting with abc together in one PR As above, but apply a groupName : \"packageRules\": [ { \"matchPackagePatterns\": \"^abc\", \"groupName\": [\"abc packages\"] } ] Change the default branch name, commit message, PR title or PR description You can use the branchName , commitMessage , prTitle or prBody configuration options to change the defaults for those settings. Automatically merge passing Pull Requests Set the configuration option autoMerge to true . Nest it inside config objects patch or minor if you want it to apply to certain types only. Separate patch releases from minor releases Renovate's default behavior for major/minor releases Renovate's default behavior is to separate major and minor releases, patch releases are also considered \"minor\". Let's explain the default behavior with an example: Say you are using a package snorgleborf , it's the 0.8.0 version. The snorgleborf maintainers then release the following versions: 0.8.1 (patch) 0.9.0 (minor) 1.0.0 (major) Renovate would then open the following PRs: Update dependency snorgleborf to 0.9.0 (minor) Update dependency snorgleborf to 1.0.0 (major) Note how Renovate groups the patch and minor versions together into one PR. This means you only get a PR for the minor version, 0.9.0 . You can override the default behavior. To learn more read the section below. Overriding the default behavior for major/minor releases You can see in the example above that Renovate won't normally open a PR for the snorgleborf patch release. There are 2 ways to tell renovate to open a separate PR for the patch release: Set separateMinorPatch to true Set automerge to the value: \"patch\" In both cases, Renovate will open 3 PRs: Update dependency snorgleborf to 0.8.1 (patch) Update dependency snorgleborf to 0.9.0 (minor) Update dependency snorgleborf to 1.0.0 (major) Most people don't want more PRs though. But it can still be handy to get PRs for patches when using automerge: Get daily patch updates which are automerged once tests pass Get weekly updates for minor and major updates The end result would be that you barely notice Renovate during the week, while you still get the benefits of patch level updates.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#what-is-the-default-behavior","text":"Renovate will: Look for configuration options in a configuration file (e.g. renovate.json ) and in each package.json file Find and process all package files (e.g. package.json , composer.json , Dockerfile , etc) in each repository Use separate branches/PR for each dependency Use separate branches for each major version of each dependency Pin devDependencies to a single version, rather than use ranges Pin dependencies to a single version if it appears not to be a library Update yarn.lock and/or package-lock.json files if found Create Pull Requests immediately after branch creation","title":"What is the default behavior?"},{"location":"faq/#what-if-i-need-to","text":"","title":"What if I need to .. ?"},{"location":"faq/#use-an-alternative-branch-as-my-pull-request-target","text":"Say your repository's default branch is master but you want Renovate to use the next branch as its PR target. You can configure the PR target branch via the baseBranches option. Add this line to the renovate.json file that's in the default branch ( master in this example). { \"baseBranches\": [\"next\"] } You can set more than one PR target branch in the baseBranches array.","title":"Use an alternative branch as my Pull Request target"},{"location":"faq/#support-private-npm-modules","text":"See the dedicated Private npm module support page.","title":"Support private npm modules"},{"location":"faq/#control-renovates-schedule","text":"Renovate itself will run as often as its administrator has configured it (e.g. hourly, daily, etc). You may want to update certain repositories less often. Or you may even want to use different schedules for specific packages. To control the days of the week or times of day that Renovate updates packages, use the timezone and schedule configuration options. By default, Renovate schedules use the UTC timezone, but you can override this in the global config. You can set a specific time zone in your local config file as well: { \"timezone\": \"America/Los_Angeles\" } The timezone must be a valid IANA time zone . With the timezone set, you can define days of week or hours of the day in which Renovate will make changes. Renovate uses the later library to parse the text. The later library also handles the concepts of \"days\", time_before\", and \"time_after\". Examples of the kind of schedules you can create: every weekend before 5:00am [after 10pm, before 5:00am] [after 10pm every weekday, before 5am every weekday] on friday and saturday The scheduling feature can be very useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to weekly updates, you could add this package rule: \"packageRules\": [ { \"matchPackageNames\": [\"aws-sdk\"], \"schedule\": [\"after 9pm on sunday\"] } ] The \"schedule\" propery must always be defined in an array, even if you only set a single schedule. Multiple entries in the array means \"or\".","title":"Control Renovate's schedule"},{"location":"faq/#disable-renovate-for-certain-dependency-types","text":"Define a packageRules entry which has the dependency type(s) in matchDepTypes and \"enabled\": false .","title":"Disable Renovate for certain dependency types"},{"location":"faq/#use-a-single-branchpr-for-all-dependency-upgrades","text":"Add a configuration for configuration option groupName set to value \"all\" , at the top level of your renovate.json or package.json .","title":"Use a single branch/PR for all dependency upgrades"},{"location":"faq/#use-separate-branches-per-dependency-but-not-one-per-major-release","text":"Set configuration option separateMajorMinor to false .","title":"Use separate branches per dependency, but not one per major release"},{"location":"faq/#keep-using-semver-ranges-instead-of-pinning-dependencies","text":"Set configuration option rangeStrategy to \"replace\" .","title":"Keep using SemVer ranges, instead of pinning dependencies"},{"location":"faq/#keep-lock-files-including-sub-dependencies-up-to-date-even-when-packagejson-hasnt-changed","text":"By default, if you enable lock-file maintenance, Renovate will update the lockfile [\"before 5am on monday\"] . If you want to update the lock file more often, update the schedule field inside the lockFileMaintenance object.","title":"Keep lock files (including sub-dependencies) up-to-date, even when package.json hasn't changed"},{"location":"faq/#wait-until-tests-have-passed-before-creating-the-pr","text":"Set the configuration option prCreation to \"status-success\" . Branches with failing tests will remain in Git and continue to get updated if necessary, but no PR will be created until their tests pass.","title":"Wait until tests have passed before creating the PR"},{"location":"faq/#wait-until-tests-have-passed-before-creating-a-pr-but-create-the-pr-even-if-they-fail","text":"Set the configuration option prCreation to \"not-pending\" .","title":"Wait until tests have passed before creating a PR, but create the PR even if they fail"},{"location":"faq/#assign-prs-to-specific-users","text":"Set the configuration option assignees to an array of usernames.","title":"Assign PRs to specific user(s)"},{"location":"faq/#add-labels-to-prs","text":"Set the configuration option labels to an array of labels to use.","title":"Add labels to PRs"},{"location":"faq/#apply-a-rule-but-only-to-package-abc","text":"Add a packageRules array to your configuration Create one object inside this array Set field matchPackageNames to value [\"abc\"] Add the configuration option to the same object e.g. \"packageRules\": [ { \"matchPackageNames\": [\"abc\"], \"assignees\": [\"importantreviewer\"] } ]","title":"Apply a rule, but only to package abc?"},{"location":"faq/#apply-a-rule-but-only-for-packages-starting-with-abc","text":"Do the same as above, but instead of using matchPackageNames , use matchPackagePatterns and a regex: \"packageRules\": [ { \"matchPackagePatterns\": \"^abc\", \"assignees\": [\"importantreviewer\"] } ]","title":"Apply a rule, but only for packages starting with abc"},{"location":"faq/#group-all-packages-starting-with-abc-together-in-one-pr","text":"As above, but apply a groupName : \"packageRules\": [ { \"matchPackagePatterns\": \"^abc\", \"groupName\": [\"abc packages\"] } ]","title":"Group all packages starting with abc together in one PR"},{"location":"faq/#change-the-default-branch-name-commit-message-pr-title-or-pr-description","text":"You can use the branchName , commitMessage , prTitle or prBody configuration options to change the defaults for those settings.","title":"Change the default branch name, commit message, PR title or PR description"},{"location":"faq/#automatically-merge-passing-pull-requests","text":"Set the configuration option autoMerge to true . Nest it inside config objects patch or minor if you want it to apply to certain types only.","title":"Automatically merge passing Pull Requests"},{"location":"faq/#separate-patch-releases-from-minor-releases","text":"","title":"Separate patch releases from minor releases"},{"location":"faq/#renovates-default-behavior-for-majorminor-releases","text":"Renovate's default behavior is to separate major and minor releases, patch releases are also considered \"minor\". Let's explain the default behavior with an example: Say you are using a package snorgleborf , it's the 0.8.0 version. The snorgleborf maintainers then release the following versions: 0.8.1 (patch) 0.9.0 (minor) 1.0.0 (major) Renovate would then open the following PRs: Update dependency snorgleborf to 0.9.0 (minor) Update dependency snorgleborf to 1.0.0 (major) Note how Renovate groups the patch and minor versions together into one PR. This means you only get a PR for the minor version, 0.9.0 . You can override the default behavior. To learn more read the section below.","title":"Renovate's default behavior for major/minor releases"},{"location":"faq/#overriding-the-default-behavior-for-majorminor-releases","text":"You can see in the example above that Renovate won't normally open a PR for the snorgleborf patch release. There are 2 ways to tell renovate to open a separate PR for the patch release: Set separateMinorPatch to true Set automerge to the value: \"patch\" In both cases, Renovate will open 3 PRs: Update dependency snorgleborf to 0.8.1 (patch) Update dependency snorgleborf to 0.9.0 (minor) Update dependency snorgleborf to 1.0.0 (major) Most people don't want more PRs though. But it can still be handy to get PRs for patches when using automerge: Get daily patch updates which are automerged once tests pass Get weekly updates for minor and major updates The end result would be that you barely notice Renovate during the week, while you still get the benefits of patch level updates.","title":"Overriding the default behavior for major/minor releases"},{"location":"gitlab-bot-security/","text":"GitLab bot security You should understand GitLab's security model, before deciding to run a \"bot\" service like Renovate on GitLab, particularly the pipeline credentials. Important : If you have any doubts or concerns about this content that could affect other users, please follow our Security Policy and report them confidentially. CI_JOB_TOKEN permissions The concept of CI_JOB_TOKEN permissions was overhauled in GitLab release 8.12 , jobs are now run with the permissions of the user account which triggered the pipeline. For security reasons the token was limited to read-only permissions and a limited set of API endpoints, however it\u2019s since been extended to allow write access to the GitLab Package Registry . Any pipeline triggered by a user account thus has permissions to read any repository which that account has access to as well as publish packages to them. With the current GitLab CI permissions model, you should avoid committing to any project which you don\u2019t trust completely, because that project could maliciously steal repository data, publish fake releases, or spam releases. Risks of hosting a Renovate GitLab app/bot/service The GitLab security model means that the risks of running a public bot service on GitLab are too high, which is why the existing service has been suspended until an alternate security model is ready. It's also important to remember that when accounts are invited into projects or groups on GitLab, acceptance happens automatically (which was a useful feature to leverage for a shared service). If you are running a self-hosted Renovate service, it is advisable to: Run a shared service only within projects which have shared visibility/security within the users, or which have a low risk that a user would try to gain access to a private project they don't otherwise have access to If running with autodiscover , also configure a value for autodiscoverFilter so that the bot can't be invited to projects or groups you don't intend Security solutions and workarounds The following research notes may help you to assess the GitLab bot security risk. Public projects only If a bot service is run on public projects only, then the risk of private project data being accessed by unauthorized users is zero. However, malicious users can still spoof or spam packages to any other public project they themselves are not a member of, so that rules out this approach for a public hosted service. A public-visibility-only bot service should be low risk for most self-hosted GitLab instances. There is still a small problem that you can't prevent users from inviting the bot into private projects if they are not aware of the risks of doing so. Project Access Tokens Project Access Tokens are a recently added feature for GitLab. The main downsides to their use for a shared bot service are: It is not yet possible to provision them through the API , so project maintainers would need to provision a project bot account and then save it to Renovate manually and per-project Project Access Tokens are a paid-only feature for gitlab.com, which excludes a large percentage of the public service user base At the time of writing, there are still some issues with getting Project Access Tokens to trigger and authenticate CI Any service using such tokens would get MRs from a user like @project_123_bot which is less intuitive than @renovate-bot The big benefit of Project Access Tokens is their limited scope, users with write access to one project cannot read/write to other projects. Group Access Tokens Group Access Tokens are still in the planning stage, but may offer a more scalable way to manage a Renovate service. Tokens could be provisioned into Renovate per-group and permissions/visibility would need to be kept uniform throughout the group to ensure escalation of privileges is not possible. It should be noted though that many GitLab users do not have uniform permissions/visibility throughout groups today, so this is a risk of Group Access Tokens in general. Even https://gitlab.com/gitlab-org is a good example of how common it is to mix project visibility within a same group. Similarly with Project Access Tokens, if they are a paid-only feature then it would exclude free users from using such a service. Skipping CI The security problem described above is that if a user triggers a malicious pipeline then they can be exploited, so skipping CI altogether would seem to be a way to avoid that. If Renovate can reliably force CI skipping for both (a) branch push, and (b) MR creation/updating then there should be no security exploit risk, but of course then there are no tests run instead. A possibility in future could be to combine this with a force push from a user or project token to trigger tests. The above solution/workaround will be actively researched in collaboration with GitLab. OAuth An alternative to a bot service running with a bot PAT would be to have it run using user OAuth tokens. In this scenario, an OAuth app would be needed to allow users to \"install\" the bot into projects with members they trust not to exploit them, and then commits and Merge Requests would appear to be authored by the user , not any bot. Bot services are better if they are provisioned with a \"bot identity\" so that users can quickly distinguish bot activity from real user activity. Recommended migration Until the hosted app can be reactivated, we recommend users migrate to use self-hosted pipelines to run Renovate. Please see the renovate-bot/renovate-runner README on GitLab for instructions on how to set this up as easily as possible. The Renovate team is working to find a feasible design for the app so that we can reactive it securely in future. We welcome any ideas you may have. Acknowledgments Thank you to Nejc Habjan for bringing this security challenge to our attention, and also to his colleagues at Siemens for their assistance researching the risks. Thanks also to the GitLab security team for being responsive to our questions.","title":"GitLab bot security"},{"location":"gitlab-bot-security/#gitlab-bot-security","text":"You should understand GitLab's security model, before deciding to run a \"bot\" service like Renovate on GitLab, particularly the pipeline credentials. Important : If you have any doubts or concerns about this content that could affect other users, please follow our Security Policy and report them confidentially.","title":"GitLab bot security"},{"location":"gitlab-bot-security/#ci_job_token-permissions","text":"The concept of CI_JOB_TOKEN permissions was overhauled in GitLab release 8.12 , jobs are now run with the permissions of the user account which triggered the pipeline. For security reasons the token was limited to read-only permissions and a limited set of API endpoints, however it\u2019s since been extended to allow write access to the GitLab Package Registry . Any pipeline triggered by a user account thus has permissions to read any repository which that account has access to as well as publish packages to them. With the current GitLab CI permissions model, you should avoid committing to any project which you don\u2019t trust completely, because that project could maliciously steal repository data, publish fake releases, or spam releases.","title":"CI_JOB_TOKEN permissions"},{"location":"gitlab-bot-security/#risks-of-hosting-a-renovate-gitlab-appbotservice","text":"The GitLab security model means that the risks of running a public bot service on GitLab are too high, which is why the existing service has been suspended until an alternate security model is ready. It's also important to remember that when accounts are invited into projects or groups on GitLab, acceptance happens automatically (which was a useful feature to leverage for a shared service). If you are running a self-hosted Renovate service, it is advisable to: Run a shared service only within projects which have shared visibility/security within the users, or which have a low risk that a user would try to gain access to a private project they don't otherwise have access to If running with autodiscover , also configure a value for autodiscoverFilter so that the bot can't be invited to projects or groups you don't intend","title":"Risks of hosting a Renovate GitLab app/bot/service"},{"location":"gitlab-bot-security/#security-solutions-and-workarounds","text":"The following research notes may help you to assess the GitLab bot security risk.","title":"Security solutions and workarounds"},{"location":"gitlab-bot-security/#public-projects-only","text":"If a bot service is run on public projects only, then the risk of private project data being accessed by unauthorized users is zero. However, malicious users can still spoof or spam packages to any other public project they themselves are not a member of, so that rules out this approach for a public hosted service. A public-visibility-only bot service should be low risk for most self-hosted GitLab instances. There is still a small problem that you can't prevent users from inviting the bot into private projects if they are not aware of the risks of doing so.","title":"Public projects only"},{"location":"gitlab-bot-security/#project-access-tokens","text":"Project Access Tokens are a recently added feature for GitLab. The main downsides to their use for a shared bot service are: It is not yet possible to provision them through the API , so project maintainers would need to provision a project bot account and then save it to Renovate manually and per-project Project Access Tokens are a paid-only feature for gitlab.com, which excludes a large percentage of the public service user base At the time of writing, there are still some issues with getting Project Access Tokens to trigger and authenticate CI Any service using such tokens would get MRs from a user like @project_123_bot which is less intuitive than @renovate-bot The big benefit of Project Access Tokens is their limited scope, users with write access to one project cannot read/write to other projects.","title":"Project Access Tokens"},{"location":"gitlab-bot-security/#group-access-tokens","text":"Group Access Tokens are still in the planning stage, but may offer a more scalable way to manage a Renovate service. Tokens could be provisioned into Renovate per-group and permissions/visibility would need to be kept uniform throughout the group to ensure escalation of privileges is not possible. It should be noted though that many GitLab users do not have uniform permissions/visibility throughout groups today, so this is a risk of Group Access Tokens in general. Even https://gitlab.com/gitlab-org is a good example of how common it is to mix project visibility within a same group. Similarly with Project Access Tokens, if they are a paid-only feature then it would exclude free users from using such a service.","title":"Group Access Tokens"},{"location":"gitlab-bot-security/#skipping-ci","text":"The security problem described above is that if a user triggers a malicious pipeline then they can be exploited, so skipping CI altogether would seem to be a way to avoid that. If Renovate can reliably force CI skipping for both (a) branch push, and (b) MR creation/updating then there should be no security exploit risk, but of course then there are no tests run instead. A possibility in future could be to combine this with a force push from a user or project token to trigger tests. The above solution/workaround will be actively researched in collaboration with GitLab.","title":"Skipping CI"},{"location":"gitlab-bot-security/#oauth","text":"An alternative to a bot service running with a bot PAT would be to have it run using user OAuth tokens. In this scenario, an OAuth app would be needed to allow users to \"install\" the bot into projects with members they trust not to exploit them, and then commits and Merge Requests would appear to be authored by the user , not any bot. Bot services are better if they are provisioned with a \"bot identity\" so that users can quickly distinguish bot activity from real user activity.","title":"OAuth"},{"location":"gitlab-bot-security/#recommended-migration","text":"Until the hosted app can be reactivated, we recommend users migrate to use self-hosted pipelines to run Renovate. Please see the renovate-bot/renovate-runner README on GitLab for instructions on how to set this up as easily as possible. The Renovate team is working to find a feasible design for the app so that we can reactive it securely in future. We welcome any ideas you may have.","title":"Recommended migration"},{"location":"gitlab-bot-security/#acknowledgments","text":"Thank you to Nejc Habjan for bringing this security challenge to our attention, and also to his colleagues at Siemens for their assistance researching the risks. Thanks also to the GitLab security team for being responsive to our questions.","title":"Acknowledgments"},{"location":"golang/","text":"Automated Dependency Updates for Go Modules Renovate supports upgrading dependencies in go.mod files and their accompanying go.sum checksums. How It Works Renovate searches in each repository for any go.mod files Renovate extracts existing dependencies from require statements Renovate resolves the dependency's source repository and checks for SemVer tags if found. Otherwise commits and v0.0.0-.... syntax will be used If Renovate finds an update, Renovate will update go.mod to the new value Renovate runs go get to update the go.sum files If the user has enabled the option gomodTidy in the postUpdateOptions array, then Renovate runs go mod tidy , which itself can update go.mod and go.sum go mod vendor is run if vendored modules are detected A PR will be created with go.mod , go.sum , and any updated vendored files updated in the one commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR Enabling Go Modules Updating Renovate updates Go Modules by default. To install Renovate Bot itself, either enable the Renovate App on GitHub, or check out Renovate OSS for self-hosted. Technical Details Module Tidying Go Modules tidying is not enabled by default, and is opt-in via the postUpdateOptions config option. The reason for this is that a go mod tidy command may make changes to go.mod and go.sum that are completely unrelated to the updated module(s) in the PR, and so may be confusing to some users. Module Vendoring Vendoring of Go Modules is done automatically if vendor/modules.txt is present. Renovate will commit all files changed within the vendor/ folder. Go binary version By default, Renovate will keep up with the very latest version of go . You can \"pin\" the go version that Renovate uses. Say you want Renovate to use Go version 1.14, you can do this by adding go 1.14 to your go.mod file. We do not support pinning Go versions to a specific patch level, so you cannot use go 1.14.12 , but you can use go 1.14 in your go.mod file.","title":"Golang"},{"location":"golang/#automated-dependency-updates-for-go-modules","text":"Renovate supports upgrading dependencies in go.mod files and their accompanying go.sum checksums.","title":"Automated Dependency Updates for Go Modules"},{"location":"golang/#how-it-works","text":"Renovate searches in each repository for any go.mod files Renovate extracts existing dependencies from require statements Renovate resolves the dependency's source repository and checks for SemVer tags if found. Otherwise commits and v0.0.0-.... syntax will be used If Renovate finds an update, Renovate will update go.mod to the new value Renovate runs go get to update the go.sum files If the user has enabled the option gomodTidy in the postUpdateOptions array, then Renovate runs go mod tidy , which itself can update go.mod and go.sum go mod vendor is run if vendored modules are detected A PR will be created with go.mod , go.sum , and any updated vendored files updated in the one commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR","title":"How It Works"},{"location":"golang/#enabling-go-modules-updating","text":"Renovate updates Go Modules by default. To install Renovate Bot itself, either enable the Renovate App on GitHub, or check out Renovate OSS for self-hosted.","title":"Enabling Go Modules Updating"},{"location":"golang/#technical-details","text":"","title":"Technical Details"},{"location":"golang/#module-tidying","text":"Go Modules tidying is not enabled by default, and is opt-in via the postUpdateOptions config option. The reason for this is that a go mod tidy command may make changes to go.mod and go.sum that are completely unrelated to the updated module(s) in the PR, and so may be confusing to some users.","title":"Module Tidying"},{"location":"golang/#module-vendoring","text":"Vendoring of Go Modules is done automatically if vendor/modules.txt is present. Renovate will commit all files changed within the vendor/ folder.","title":"Module Vendoring"},{"location":"golang/#go-binary-version","text":"By default, Renovate will keep up with the very latest version of go . You can \"pin\" the go version that Renovate uses. Say you want Renovate to use Go version 1.14, you can do this by adding go 1.14 to your go.mod file. We do not support pinning Go versions to a specific patch level, so you cannot use go 1.14.12 , but you can use go 1.14 in your go.mod file.","title":"Go binary version"},{"location":"install-github-app/","text":"GitHub app installation Installing/enabling the Renovate GitHub App is simple. First, navigate to https://github.com/apps/renovate and click the Install button: The only choice you need to make is whether to run Renovate on all repositories or on selected repositories: Renovate will ignore any repositories that don't have known package files, as well as any forks, so you can enable Renovate for all your repositories with no problems. That said, most people run Renovate on selected repositories. Unfortunately GitHub doesn't offer a \"select all except X,Y,Z\" option, so you must select each repository where you want Renovate to run. Once you're done selecting repositories for Renovate to run on, click the green Install button at the bottom of the page and Renovate will be enabled for those repositories and start the onboarding process.","title":"GitHub App Installation"},{"location":"install-github-app/#github-app-installation","text":"Installing/enabling the Renovate GitHub App is simple. First, navigate to https://github.com/apps/renovate and click the Install button: The only choice you need to make is whether to run Renovate on all repositories or on selected repositories: Renovate will ignore any repositories that don't have known package files, as well as any forks, so you can enable Renovate for all your repositories with no problems. That said, most people run Renovate on selected repositories. Unfortunately GitHub doesn't offer a \"select all except X,Y,Z\" option, so you must select each repository where you want Renovate to run. Once you're done selecting repositories for Renovate to run on, click the green Install button at the bottom of the page and Renovate will be enabled for those repositories and start the onboarding process.","title":"GitHub app installation"},{"location":"install-gitlab-app/","text":"Hosted GitLab App The hosted Renovate App for GitLab is currently offline and will be restored later either as an OAuth app or once a viable security model for bots on GitLab.com is available. For more details on GitLab security for bots, please see the GitLab Bot Security doc.","title":"GitLab App Installation"},{"location":"install-gitlab-app/#hosted-gitlab-app","text":"The hosted Renovate App for GitLab is currently offline and will be restored later either as an OAuth app or once a viable security model for bots on GitLab.com is available. For more details on GitLab security for bots, please see the GitLab Bot Security doc.","title":"Hosted GitLab App"},{"location":"java/","text":"Java Dependency Updates Renovate can update Gradle and Maven dependencies. This includes libraries and plugins. Gradle Renovate detects versions that are specified in a string 'group:artifact:version' and those specified in a map (group:groupName, name:ArtifactName, version:Version) . Gradle File Support Renovate can update build.gradle / build.gradle.kts files in the root of the repository. It also updates any *.gradle / *.gradle.kts files in a subdirectory as multi-project configurations. Renovate does not support: Projects which do not have either a build.gradle or build.gradle.kts in the repository root Android projects that require extra configuration to run (e.g. setting the Android SDK) Gradle versions prior to version 5.0. How It Works Renovate uses a plugin to search and extract versions from projects. Once the Gradle plugin has detected the dependencies, lookups and updating will be performed like usual with datasources and direct patching of files. Maven Renovate can update dependency versions found in Maven pom.xml files. Maven File Support Renovate will search repositories for all pom.xml files and processes them independently. Custom registry support, and authentication This example shows how you can use a config.js file to configure Renovate for use with Artifactory. We're using environment variables to pass the Artifactory username and password to Renovate bot. module.exports = { hostRules: [ { hostType: 'maven', baseUrl: 'https://artifactory.yourcompany.com/', username: process.env.ARTIFACTORY_USERNAME, password: process.env.ARTIFACTORY_PASSWORD, }, ], };","title":"Java"},{"location":"java/#java-dependency-updates","text":"Renovate can update Gradle and Maven dependencies. This includes libraries and plugins.","title":"Java Dependency Updates"},{"location":"java/#gradle","text":"Renovate detects versions that are specified in a string 'group:artifact:version' and those specified in a map (group:groupName, name:ArtifactName, version:Version) .","title":"Gradle"},{"location":"java/#gradle-file-support","text":"Renovate can update build.gradle / build.gradle.kts files in the root of the repository. It also updates any *.gradle / *.gradle.kts files in a subdirectory as multi-project configurations. Renovate does not support: Projects which do not have either a build.gradle or build.gradle.kts in the repository root Android projects that require extra configuration to run (e.g. setting the Android SDK) Gradle versions prior to version 5.0.","title":"Gradle File Support"},{"location":"java/#how-it-works","text":"Renovate uses a plugin to search and extract versions from projects. Once the Gradle plugin has detected the dependencies, lookups and updating will be performed like usual with datasources and direct patching of files.","title":"How It Works"},{"location":"java/#maven","text":"Renovate can update dependency versions found in Maven pom.xml files.","title":"Maven"},{"location":"java/#maven-file-support","text":"Renovate will search repositories for all pom.xml files and processes them independently.","title":"Maven File Support"},{"location":"java/#custom-registry-support-and-authentication","text":"This example shows how you can use a config.js file to configure Renovate for use with Artifactory. We're using environment variables to pass the Artifactory username and password to Renovate bot. module.exports = { hostRules: [ { hostType: 'maven', baseUrl: 'https://artifactory.yourcompany.com/', username: process.env.ARTIFACTORY_USERNAME, password: process.env.ARTIFACTORY_PASSWORD, }, ], };","title":"Custom registry support, and authentication"},{"location":"javascript/","text":"JavaScript Renovate supports upgrading JavaScript dependencies specified in package.json files. npm , yarn , and pnpm are all supported.","title":"JavaScript"},{"location":"javascript/#javascript","text":"Renovate supports upgrading JavaScript dependencies specified in package.json files. npm , yarn , and pnpm are all supported.","title":"JavaScript"},{"location":"merge-confidence/","text":"Merge Confidence Merge Confidence identifies and flags undeclared breaking releases based on analysis of test and release adoption data across WhiteSource Renovate\u2019s early-adopting user base. The new feature was created to help users avoid the pain of un-mergeable Pull Requests or worse -- a broken dependency in production. Confidence Levels and their meaning Merge Confidence has four possible values: Low : If an update is classified as having low merge confidence, it means we think it contains breaking changes. Often this is because it's a Major version update so this is intentional, but sometimes it's unintentional or undeclared. Neutral : If we do not have enough data about an update, or the data is not conclusive about whether the update should be classified as High or Low, then we classify it as Neutral. High : Updates are classified as High Confidence once we believe that their combination of Age, Adoption and Test Compatibility means that there's a very low chance that there are breaking changes. Very High : This is reserved for updates which are months old and have either strong adoption or show very high test compatibility scores. Pull Request Badges Merge Confidence is currently available in the form of Pull Request badges. The badges available are: Age : How old the release is Adoption : The percentage of Renovate's user base which is using this library Passing : The percentage of updates which had successful test results Confidence : The confidence level for this update How Does It Work? WhiteSource's hosted Renovate App has enabled a diverse user base across github.com and gitlab.com to keep dependencies up-to-date since 2017, and generated millions of Pull Requests in the process. We found that by aggregating and analyzing metrics we already had, such as release age, release adoption, and Pull Request test results, we can accurately identify releases of open source packages that show signs of having undeclared breaking changes. The algorithm for determining values is private and is not something we plan to share. Similar to a search engine's algorithm, we plan to tweak and enhance it over time, like adding historical data to determine a baseline confidence level for packages. We plan to expose much more of the data via a companion website, such as number of users of a package and popular repositories which may have already updated to the version in question. Supported Platforms and Languages, Roadmap Merge Confidence badges for Pull Requests are available in beta on any supported Renovate platform today, including WhiteSource Remediate. Data is available for npm, Maven and PyPI packages only for now, we plan to support other languages soon. High-level information on planned enhancements is available in the Merge Confidence Roadmap Project on GitHub. Enabling and Disabling Merge Confidence badges are enabled automatically for anyone using the WhiteSource Renovate App. If you don't use the app, you can enable Merge Confidence badges by adding this to your Renovate config: \"extends\": [\"github>whitesource/merge-confidence:beta\"] If you\u2019d prefer to disable these badges in the app, add this to your config instead: \"ignorePresets\": [\"github>whitesource/merge-confidence:beta\"] Miscellaneous Clarifications npm packages are never classified as High Confidence until they are at least 3 days old. This is because npm packages less than 72 hours old can be unpublished , which could result in a service impact if you have already updated to it. Percentage values for Adoption and Passing are not raw percentages and instead are weighted towards Organizations, private repositories, and projects with high test reliability. Questions and Feedback You are invited to create an Issue if you have anything you'd like to discuss.","title":"Merge Confidence"},{"location":"merge-confidence/#merge-confidence","text":"Merge Confidence identifies and flags undeclared breaking releases based on analysis of test and release adoption data across WhiteSource Renovate\u2019s early-adopting user base. The new feature was created to help users avoid the pain of un-mergeable Pull Requests or worse -- a broken dependency in production.","title":"Merge Confidence"},{"location":"merge-confidence/#confidence-levels-and-their-meaning","text":"Merge Confidence has four possible values: Low : If an update is classified as having low merge confidence, it means we think it contains breaking changes. Often this is because it's a Major version update so this is intentional, but sometimes it's unintentional or undeclared. Neutral : If we do not have enough data about an update, or the data is not conclusive about whether the update should be classified as High or Low, then we classify it as Neutral. High : Updates are classified as High Confidence once we believe that their combination of Age, Adoption and Test Compatibility means that there's a very low chance that there are breaking changes. Very High : This is reserved for updates which are months old and have either strong adoption or show very high test compatibility scores.","title":"Confidence Levels and their meaning"},{"location":"merge-confidence/#pull-request-badges","text":"Merge Confidence is currently available in the form of Pull Request badges. The badges available are: Age : How old the release is Adoption : The percentage of Renovate's user base which is using this library Passing : The percentage of updates which had successful test results Confidence : The confidence level for this update","title":"Pull Request Badges"},{"location":"merge-confidence/#how-does-it-work","text":"WhiteSource's hosted Renovate App has enabled a diverse user base across github.com and gitlab.com to keep dependencies up-to-date since 2017, and generated millions of Pull Requests in the process. We found that by aggregating and analyzing metrics we already had, such as release age, release adoption, and Pull Request test results, we can accurately identify releases of open source packages that show signs of having undeclared breaking changes. The algorithm for determining values is private and is not something we plan to share. Similar to a search engine's algorithm, we plan to tweak and enhance it over time, like adding historical data to determine a baseline confidence level for packages. We plan to expose much more of the data via a companion website, such as number of users of a package and popular repositories which may have already updated to the version in question.","title":"How Does It Work?"},{"location":"merge-confidence/#supported-platforms-and-languages-roadmap","text":"Merge Confidence badges for Pull Requests are available in beta on any supported Renovate platform today, including WhiteSource Remediate. Data is available for npm, Maven and PyPI packages only for now, we plan to support other languages soon. High-level information on planned enhancements is available in the Merge Confidence Roadmap Project on GitHub.","title":"Supported Platforms and Languages, Roadmap"},{"location":"merge-confidence/#enabling-and-disabling","text":"Merge Confidence badges are enabled automatically for anyone using the WhiteSource Renovate App. If you don't use the app, you can enable Merge Confidence badges by adding this to your Renovate config: \"extends\": [\"github>whitesource/merge-confidence:beta\"] If you\u2019d prefer to disable these badges in the app, add this to your config instead: \"ignorePresets\": [\"github>whitesource/merge-confidence:beta\"]","title":"Enabling and Disabling"},{"location":"merge-confidence/#miscellaneous-clarifications","text":"npm packages are never classified as High Confidence until they are at least 3 days old. This is because npm packages less than 72 hours old can be unpublished , which could result in a service impact if you have already updated to it. Percentage values for Adoption and Passing are not raw percentages and instead are weighted towards Organizations, private repositories, and projects with high test reliability.","title":"Miscellaneous Clarifications"},{"location":"merge-confidence/#questions-and-feedback","text":"You are invited to create an Issue if you have anything you'd like to discuss.","title":"Questions and Feedback"},{"location":"node/","text":"Node.js Versions Renovate can upgrade the Node.js runtime used by your project. This way you're using the latest bug fixes, performance improvements, security mitigations, etc. File Support Renovate can manage the Node.js version in the following files: The engines field in package.json The volta field in package.json The .nvmrc file for the Node Version Manager The node_js field in .travis.yml How It Works Node.js renovation in package.json > engines and in .nvmrc is enabled by default, if your existing version is pinned. To enable .travis.yml renovation, you must: Enable Travis renovation explicitly by setting the following Renovate configuration: \"travis\": { \"enabled\": true } Optionally, configure a support policy (As documented below) When Renovate processes your project's repository it will look for the files listed above and submit a single pull request that upgrades all Node.js versions simultaneously. Configuring Support Policy Renovate supports a supportPolicy option that can be passed the following values and associated versions (current as of Feb 2021): Default: lts supportPolicy versions description all 10, 12, 14, 15 All releases that have not passed their end date lts 10, 12, 14 All releases classified as LTS, including in maintenance active 14, 15 All releases not in maintenance lts_active 14 All releases both LTS and active lts_latest 14 The latest LTS release current 15 The latest release from \"all\" The version numbers associated with each support policy will be updated as new versions of Node.js are released, moved to LTS or maintenance, etc. For example, to instruct Renovate to upgrade your project to the latest Long-term Support release, you can use the following configuration: \"supportPolicy\": [\"lts_latest\"] We recommend that you define this support policy inside the node configuration object. This way, it is applied to all Node.js-related files. For additional language support see the supportPolicy documentation . Configuring which version of npm Renovate uses When binarySource=docker , such as in the hosted WhiteSource Renovate App, Renovate will choose and install an npm version dynamically. To control which version or constraint is installed, you should use the engines.npm property in your package.json file. Renovate bot will then use that version constraint for npm when it creates a pull request. For example, if you want to use at least npm 6.14.11 and also allow newer versions of npm in the 6.x range, you would put this in your package.json file: { \"engines\": { \"npm\": \"^6.14.11\" } }","title":"Node.js Versions"},{"location":"node/#nodejs-versions","text":"Renovate can upgrade the Node.js runtime used by your project. This way you're using the latest bug fixes, performance improvements, security mitigations, etc.","title":"Node.js Versions"},{"location":"node/#file-support","text":"Renovate can manage the Node.js version in the following files: The engines field in package.json The volta field in package.json The .nvmrc file for the Node Version Manager The node_js field in .travis.yml","title":"File Support"},{"location":"node/#how-it-works","text":"Node.js renovation in package.json > engines and in .nvmrc is enabled by default, if your existing version is pinned. To enable .travis.yml renovation, you must: Enable Travis renovation explicitly by setting the following Renovate configuration: \"travis\": { \"enabled\": true } Optionally, configure a support policy (As documented below) When Renovate processes your project's repository it will look for the files listed above and submit a single pull request that upgrades all Node.js versions simultaneously.","title":"How It Works"},{"location":"node/#configuring-support-policy","text":"Renovate supports a supportPolicy option that can be passed the following values and associated versions (current as of Feb 2021): Default: lts supportPolicy versions description all 10, 12, 14, 15 All releases that have not passed their end date lts 10, 12, 14 All releases classified as LTS, including in maintenance active 14, 15 All releases not in maintenance lts_active 14 All releases both LTS and active lts_latest 14 The latest LTS release current 15 The latest release from \"all\" The version numbers associated with each support policy will be updated as new versions of Node.js are released, moved to LTS or maintenance, etc. For example, to instruct Renovate to upgrade your project to the latest Long-term Support release, you can use the following configuration: \"supportPolicy\": [\"lts_latest\"] We recommend that you define this support policy inside the node configuration object. This way, it is applied to all Node.js-related files. For additional language support see the supportPolicy documentation .","title":"Configuring Support Policy"},{"location":"node/#configuring-which-version-of-npm-renovate-uses","text":"When binarySource=docker , such as in the hosted WhiteSource Renovate App, Renovate will choose and install an npm version dynamically. To control which version or constraint is installed, you should use the engines.npm property in your package.json file. Renovate bot will then use that version constraint for npm when it creates a pull request. For example, if you want to use at least npm 6.14.11 and also allow newer versions of npm in the 6.x range, you would put this in your package.json file: { \"engines\": { \"npm\": \"^6.14.11\" } }","title":"Configuring which version of npm Renovate uses"},{"location":"noise-reduction/","text":"Noise Reduction Generally, the first reaction people have to automated dependency updates like Renovate is \"oh great/feel the power of automation\". The next reaction a few days or weeks later is often \"this is getting overwhelming\". Indeed, if you leave Renovate on its default settings of raising a PR every single time any dependency receives any update.. you will get a lot of PRs and related notifications. This document will give you some ideas of how to reduce the amount of \"noise\" in your repository and the Pros/Cons of each approach. Of course, please keep in mind that people's definitions of \"noise\" may differ. For some people, it's noisy only if they get a notification or email from GitHub. For others, too many commits in their master branch may be \"noise\". In other words, your mileage may vary. If you have any ideas on this topic, please contact the author by starting a new discussion on the Renovate repository . Package Grouping To reduce noise, you can reduce the number of updates in total, and a good way to do that is via intelligent grouping of related packages. As an example, our default \":app\" and \":library\" presets include the rule \"group:monorepos\" , which means that \"sibling\" packages from known monorepos will always be grouped into the same branch/PR by renovate. For example, all @angular/* packages that are updated at the same time will be raised in a \"Renovate angular monorepo packages\" PR. And every package in the React monorepo will be grouped together in a React monorepo PR too. You may wish to take this further, for example you might want to group together all packages related to eslint , even if they come from separate repositories/authors. In that case you might create a config like this: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\" } ] By setting matchPackagePatterns to \"eslint\", it means that any package with ESLint anywhere in its name will be grouped into a renovate/eslint branch and related PR. Caution : Any time you group dependencies together, you naturally increase the chance that the branch will have an error (\"break\" your build). When you have more than one package upgrade in a PR, it's going to take you longer to work out which one broke than if they were all in separate PRs. Also, you will be held up upgrading all those dependencies until they all pass. If you weren't grouping, then you could keep upgrading all dependencies except the one that fails, instead of being held up. You will also have less flexibility about what to do when one or more in the group have a major upgrade and may break the others. Scheduling Renovate On its own, the Renovate CLI tool runs once and then exits. Hence, it only runs as often as its administrator sets it to (e.g. via cron ). For the Renovate app on GitHub , it currently runs continuously using a job queue that gets refreshed hourly, or when you make relevant commits to your repository. Therefore, you can expect to get PRs at any time of the day, e.g. soon after versions are published to npm. Receiving PRs at any hour can increase the feeling of being \"overwhelmed\" by updates and possibly interrupt your flow during working hours, so many Renovate users also consider reducing Renovate's schedule to be outside their normal working hours, for example weeknights and weekends. This is achievable by configuring schedule in your Renovate config and optionally timezone (Renovate's default time zone is UTC, so you may find it easier to write schedules if you override timezone to your local one). Another example of adjusting schedules to fit with your workflow might be if your company performs releases every Monday. In that case, you might schedule Renovate to run every Tuesday after midnight to pick up new dependency updates that you can test over the following week before the next release. Caution : You need to make sure you leave yourself and Renovate enough time in a week to actually get all your updating and merging done. There are multiple reasons why Renovate may need to \"recreate\" PRs after you merge another: Conflict with package.json (sometimes) Conflict with lock files (often) If you have configured Renovate or GitHub that PRs must always be kept up-to-date with master Any of the above reasons can lead to a Renovate branch being considered \"stale\" and then Renovate needs to rebase it off master before you can test and merge again, and Renovate won't do this until it's back in schedule. Selective scheduling Don't think that you need to apply blanket rules to scheduling. Remember that Renovate's configuration is highly flexible so you can configure automerge anywhere from globally (entire repo) right down to a package/upgrade type level. You could even configure a nonsensical rule like: \"patch updates of jquery are for Mondays only\". Remember our example of grouping all eslint packages? If you think about it, updates to eslint rules don't exactly need to be applied in real time! You don't want to get too far behind, so how about we update eslint packages only once a month? \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"on the first day of the month\"] } ] Or perhaps at least weekly: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"before 2am on monday\"] } ] If you're wondering what is supported and not, under the hood, the schedule is parsed using later.js using the later.parse.text(scheduleString) API. This page explains the supported syntax or you can experiment on the RunKit playground . Automerging Automerging is a Renovate feature that can save you a lot of time/noise directly, while also benefiting grouping and scheduling. In short: it means that Renovate can merge PRs or even branches itself if they pass your tests. We recommend that you enable automerge for any type of dependency update where you would just click Merge anyway. We all know that there are some types of updates that we (nearly) always verify manually before merging, and plenty of others that we don't bother looking at unless tests fail. Every time you click Merge on a Renovate PR without manually testing it, you should consider if you can enable automerge and save yourself the time in future. Automerge works particularly well for devDependencies and for production dependencies that have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests: automerge them! If you have a linter like eslint or tslint and its update passes: automerge them! If you have an API with 100% test coverage and express is updated: automerge it! Branch automerging Those of you familiar with GitHub might note that even if you automerge PRs, you are still going to get notifications (noise) anyway - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to master without PR If tests fail, Renovate raises a PR for you to review The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your master branch. Automerging and scheduling Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to master The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Remember our running eslint example? Let's automerge it if all the linting updates pass: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"before 2am on monday\"], \"automerge\": true, \"automergeType\": \"branch\" } ] Have you come up with a rule that you think others would benefit from? How about a PR back to renovate-config with the above rule named \":automergeEslintWeekly\" ? Lock file considerations Using lock files greatly increases the chance that merging one PR will result in a second PR becoming conflicted with master . The table below highlights different noise reduction strategies and their effect on pull request and potential lock file conflicts: Action Effect on pull requests Chance of lock file conflicts Group dependencies together Decreases separate PRs Decreases Automerge dependencies Decreases concurrent PRs Decreases Decrease scheduled time for Renovate Increases concurrent PRs Increases The Future of Noise Reduction First of all, if you ever have any ideas about how to make Renovate less noisy, please raise or comment on issues in the main repository . Our philosophy is: Nearly everyone should use Renovate-like dependency update automation Over time, you should \"see\" Renovate less and less One of our hopes with preset configs is that a set of \"sensible\" configs can be maintained by the community that combine grouping, scheduling and automerging to reduce the amount of noise in repositories with little downside or increased risk. Such lists could be maintained and used somewhat like Adblock lists - kept up to date by maintainers but for the majority of users they are simply trusted/automatic/invisible.","title":"Noise Reduction"},{"location":"noise-reduction/#noise-reduction","text":"Generally, the first reaction people have to automated dependency updates like Renovate is \"oh great/feel the power of automation\". The next reaction a few days or weeks later is often \"this is getting overwhelming\". Indeed, if you leave Renovate on its default settings of raising a PR every single time any dependency receives any update.. you will get a lot of PRs and related notifications. This document will give you some ideas of how to reduce the amount of \"noise\" in your repository and the Pros/Cons of each approach. Of course, please keep in mind that people's definitions of \"noise\" may differ. For some people, it's noisy only if they get a notification or email from GitHub. For others, too many commits in their master branch may be \"noise\". In other words, your mileage may vary. If you have any ideas on this topic, please contact the author by starting a new discussion on the Renovate repository .","title":"Noise Reduction"},{"location":"noise-reduction/#package-grouping","text":"To reduce noise, you can reduce the number of updates in total, and a good way to do that is via intelligent grouping of related packages. As an example, our default \":app\" and \":library\" presets include the rule \"group:monorepos\" , which means that \"sibling\" packages from known monorepos will always be grouped into the same branch/PR by renovate. For example, all @angular/* packages that are updated at the same time will be raised in a \"Renovate angular monorepo packages\" PR. And every package in the React monorepo will be grouped together in a React monorepo PR too. You may wish to take this further, for example you might want to group together all packages related to eslint , even if they come from separate repositories/authors. In that case you might create a config like this: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\" } ] By setting matchPackagePatterns to \"eslint\", it means that any package with ESLint anywhere in its name will be grouped into a renovate/eslint branch and related PR. Caution : Any time you group dependencies together, you naturally increase the chance that the branch will have an error (\"break\" your build). When you have more than one package upgrade in a PR, it's going to take you longer to work out which one broke than if they were all in separate PRs. Also, you will be held up upgrading all those dependencies until they all pass. If you weren't grouping, then you could keep upgrading all dependencies except the one that fails, instead of being held up. You will also have less flexibility about what to do when one or more in the group have a major upgrade and may break the others.","title":"Package Grouping"},{"location":"noise-reduction/#scheduling-renovate","text":"On its own, the Renovate CLI tool runs once and then exits. Hence, it only runs as often as its administrator sets it to (e.g. via cron ). For the Renovate app on GitHub , it currently runs continuously using a job queue that gets refreshed hourly, or when you make relevant commits to your repository. Therefore, you can expect to get PRs at any time of the day, e.g. soon after versions are published to npm. Receiving PRs at any hour can increase the feeling of being \"overwhelmed\" by updates and possibly interrupt your flow during working hours, so many Renovate users also consider reducing Renovate's schedule to be outside their normal working hours, for example weeknights and weekends. This is achievable by configuring schedule in your Renovate config and optionally timezone (Renovate's default time zone is UTC, so you may find it easier to write schedules if you override timezone to your local one). Another example of adjusting schedules to fit with your workflow might be if your company performs releases every Monday. In that case, you might schedule Renovate to run every Tuesday after midnight to pick up new dependency updates that you can test over the following week before the next release. Caution : You need to make sure you leave yourself and Renovate enough time in a week to actually get all your updating and merging done. There are multiple reasons why Renovate may need to \"recreate\" PRs after you merge another: Conflict with package.json (sometimes) Conflict with lock files (often) If you have configured Renovate or GitHub that PRs must always be kept up-to-date with master Any of the above reasons can lead to a Renovate branch being considered \"stale\" and then Renovate needs to rebase it off master before you can test and merge again, and Renovate won't do this until it's back in schedule.","title":"Scheduling Renovate"},{"location":"noise-reduction/#selective-scheduling","text":"Don't think that you need to apply blanket rules to scheduling. Remember that Renovate's configuration is highly flexible so you can configure automerge anywhere from globally (entire repo) right down to a package/upgrade type level. You could even configure a nonsensical rule like: \"patch updates of jquery are for Mondays only\". Remember our example of grouping all eslint packages? If you think about it, updates to eslint rules don't exactly need to be applied in real time! You don't want to get too far behind, so how about we update eslint packages only once a month? \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"on the first day of the month\"] } ] Or perhaps at least weekly: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"before 2am on monday\"] } ] If you're wondering what is supported and not, under the hood, the schedule is parsed using later.js using the later.parse.text(scheduleString) API. This page explains the supported syntax or you can experiment on the RunKit playground .","title":"Selective scheduling"},{"location":"noise-reduction/#automerging","text":"Automerging is a Renovate feature that can save you a lot of time/noise directly, while also benefiting grouping and scheduling. In short: it means that Renovate can merge PRs or even branches itself if they pass your tests. We recommend that you enable automerge for any type of dependency update where you would just click Merge anyway. We all know that there are some types of updates that we (nearly) always verify manually before merging, and plenty of others that we don't bother looking at unless tests fail. Every time you click Merge on a Renovate PR without manually testing it, you should consider if you can enable automerge and save yourself the time in future. Automerge works particularly well for devDependencies and for production dependencies that have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests: automerge them! If you have a linter like eslint or tslint and its update passes: automerge them! If you have an API with 100% test coverage and express is updated: automerge it!","title":"Automerging"},{"location":"noise-reduction/#branch-automerging","text":"Those of you familiar with GitHub might note that even if you automerge PRs, you are still going to get notifications (noise) anyway - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to master without PR If tests fail, Renovate raises a PR for you to review The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your master branch.","title":"Branch automerging"},{"location":"noise-reduction/#automerging-and-scheduling","text":"Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to master The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Remember our running eslint example? Let's automerge it if all the linting updates pass: \"packageRules\": [ { \"matchPackagePatterns\": [ \"eslint\" ], \"groupName\": \"eslint\", \"schedule\": [\"before 2am on monday\"], \"automerge\": true, \"automergeType\": \"branch\" } ] Have you come up with a rule that you think others would benefit from? How about a PR back to renovate-config with the above rule named \":automergeEslintWeekly\" ?","title":"Automerging and scheduling"},{"location":"noise-reduction/#lock-file-considerations","text":"Using lock files greatly increases the chance that merging one PR will result in a second PR becoming conflicted with master . The table below highlights different noise reduction strategies and their effect on pull request and potential lock file conflicts: Action Effect on pull requests Chance of lock file conflicts Group dependencies together Decreases separate PRs Decreases Automerge dependencies Decreases concurrent PRs Decreases Decrease scheduled time for Renovate Increases concurrent PRs Increases","title":"Lock file considerations"},{"location":"noise-reduction/#the-future-of-noise-reduction","text":"First of all, if you ever have any ideas about how to make Renovate less noisy, please raise or comment on issues in the main repository . Our philosophy is: Nearly everyone should use Renovate-like dependency update automation Over time, you should \"see\" Renovate less and less One of our hopes with preset configs is that a set of \"sensible\" configs can be maintained by the community that combine grouping, scheduling and automerging to reduce the amount of noise in repositories with little downside or increased risk. Such lists could be maintained and used somewhat like Adblock lists - kept up to date by maintainers but for the majority of users they are simply trusted/automatic/invisible.","title":"The Future of Noise Reduction"},{"location":"nuget/","text":"Nuget Renovate supports upgrading dependencies in .csproj , .fsproj , and .vbproj files. Version Support Only SDK-style .csproj / .fsproj / .vbproj files are currently supported. By default, this includes: .NET Core 1.0 and above .NET Standard class libraries Any .csproj / .fsproj / .vbproj in the SDK-style syntax To convert your .NET Framework .csproj / .fsproj / .vbproj into an SDK-style project, one can follow the following guide . How It Works Renovate searches in each repository for any files with a .csproj , .fsproj , or .vbproj extension Existing dependencies are extracted from <PackageReference> and <PackageVersion> tags Renovate looks up the latest version on nuget.org (or on alternate feeds ) to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR Alternate feeds Renovate by default performs all lookups on https://api.nuget.org/v3/index.json , but it also supports alternative NuGet feeds. Alternative feeds can be specified either in a NuGet.config file within your repository (Renovate will not search outside the repository) or in Renovate configuration options: \"nuget\": { \"registryUrls\": [ \"https://api.nuget.org/v3/index.json\", \"http://example1.com/nuget/\" \"http://example2.com/nuget/v3/index.json\" ] } In this example we defined 3 NuGet feeds. The package resolving process uses the merge strategy to handle the 3 feeds. All feeds are checked for dependency updates, and duplicate updates are merged/joined together into a single dependency update. Protocol versions NuGet supports two protocol versions, v2 and v3 , the NuGet client and server must use the same protocol version. Renovate as a NuGet client supports both versions and will use v2 unless the configured feed URL ends with index.json (which mirrors the behavior of the official NuGet client). If you have a v3 feed that does not match this pattern (e.g. JFrog Artifactory) you need to help Renovate by appending #protocolVersion=3 to the registry URL: \"nuget\": { \"registryUrls\": [ \"http://myV3feed#protocolVersion=3\" ] } Authenticated feeds Credentials for authenticated/private feeds can be provided via host rules in the configuration options (file or command line parameter). \"hostRules\": [ { \"hostType\": \"nuget\", \"baseUrl\": \"http://example1.com/nuget\", \"username\": \"root\", \"password\": \"p4$$w0rd\" } ] Please note that at the moment only Basic HTTP authentication (via username and password) is supported. Future work Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Nuget"},{"location":"nuget/#nuget","text":"Renovate supports upgrading dependencies in .csproj , .fsproj , and .vbproj files.","title":"Nuget"},{"location":"nuget/#version-support","text":"Only SDK-style .csproj / .fsproj / .vbproj files are currently supported. By default, this includes: .NET Core 1.0 and above .NET Standard class libraries Any .csproj / .fsproj / .vbproj in the SDK-style syntax To convert your .NET Framework .csproj / .fsproj / .vbproj into an SDK-style project, one can follow the following guide .","title":"Version Support"},{"location":"nuget/#how-it-works","text":"Renovate searches in each repository for any files with a .csproj , .fsproj , or .vbproj extension Existing dependencies are extracted from <PackageReference> and <PackageVersion> tags Renovate looks up the latest version on nuget.org (or on alternate feeds ) to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR","title":"How It Works"},{"location":"nuget/#alternate-feeds","text":"Renovate by default performs all lookups on https://api.nuget.org/v3/index.json , but it also supports alternative NuGet feeds. Alternative feeds can be specified either in a NuGet.config file within your repository (Renovate will not search outside the repository) or in Renovate configuration options: \"nuget\": { \"registryUrls\": [ \"https://api.nuget.org/v3/index.json\", \"http://example1.com/nuget/\" \"http://example2.com/nuget/v3/index.json\" ] } In this example we defined 3 NuGet feeds. The package resolving process uses the merge strategy to handle the 3 feeds. All feeds are checked for dependency updates, and duplicate updates are merged/joined together into a single dependency update.","title":"Alternate feeds"},{"location":"nuget/#protocol-versions","text":"NuGet supports two protocol versions, v2 and v3 , the NuGet client and server must use the same protocol version. Renovate as a NuGet client supports both versions and will use v2 unless the configured feed URL ends with index.json (which mirrors the behavior of the official NuGet client). If you have a v3 feed that does not match this pattern (e.g. JFrog Artifactory) you need to help Renovate by appending #protocolVersion=3 to the registry URL: \"nuget\": { \"registryUrls\": [ \"http://myV3feed#protocolVersion=3\" ] }","title":"Protocol versions"},{"location":"nuget/#authenticated-feeds","text":"Credentials for authenticated/private feeds can be provided via host rules in the configuration options (file or command line parameter). \"hostRules\": [ { \"hostType\": \"nuget\", \"baseUrl\": \"http://example1.com/nuget\", \"username\": \"root\", \"password\": \"p4$$w0rd\" } ] Please note that at the moment only Basic HTTP authentication (via username and password) is supported.","title":"Authenticated feeds"},{"location":"nuget/#future-work","text":"Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Future work"},{"location":"php/","text":"Automated Dependency Updates for PHP Composer Dependencies Renovate can upgrade dependencies in PHP's composer.json and composer.lock files. How It Works Renovate searches in each repository for any composer.json files Existing dependencies are extracted from the relevant sections of the JSON Renovate resolves the dependency on Packagist (or elsewhere if configured), and filter for SemVer versions A PR is created with composer.json and composer.lock updated in the same commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR Enabling Either install the Renovate App on GitHub, or check out Renovate OSS for self-hosted. Private packages If you are using a privately hosted Composer package you can pass the credentials via the hostRules configuration. { \"hostRules\": [ { \"hostName\": \"some.vendor.com\", \"hostType\": \"packagist\", \"username\": \"<your-username>\", \"password\": \"<your-password>\" } ] } This host rule is best added to the bot's config.js config so that it is not visible to users of the repository. If you are using the hosted WhiteSource Renovate App then you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://renovatebot.com/encrypt , paste in the secret string you wish to encrypt, click Encrypt , then copy the encrypted result. You may encrypt your password only, but you can encrypt your username as well. { \"hostRules\": [ { \"hostName\": \"some.vendor.com\", \"hostType\": \"packagist\", \"encrypted\": { \"username\": \"<your-encrypted-password\", \"password\": \"<your-encrypted-password\" } } ] }","title":"PHP"},{"location":"php/#automated-dependency-updates-for-php-composer-dependencies","text":"Renovate can upgrade dependencies in PHP's composer.json and composer.lock files.","title":"Automated Dependency Updates for PHP Composer Dependencies"},{"location":"php/#how-it-works","text":"Renovate searches in each repository for any composer.json files Existing dependencies are extracted from the relevant sections of the JSON Renovate resolves the dependency on Packagist (or elsewhere if configured), and filter for SemVer versions A PR is created with composer.json and composer.lock updated in the same commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR","title":"How It Works"},{"location":"php/#enabling","text":"Either install the Renovate App on GitHub, or check out Renovate OSS for self-hosted.","title":"Enabling"},{"location":"php/#private-packages","text":"If you are using a privately hosted Composer package you can pass the credentials via the hostRules configuration. { \"hostRules\": [ { \"hostName\": \"some.vendor.com\", \"hostType\": \"packagist\", \"username\": \"<your-username>\", \"password\": \"<your-password>\" } ] } This host rule is best added to the bot's config.js config so that it is not visible to users of the repository. If you are using the hosted WhiteSource Renovate App then you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://renovatebot.com/encrypt , paste in the secret string you wish to encrypt, click Encrypt , then copy the encrypted result. You may encrypt your password only, but you can encrypt your username as well. { \"hostRules\": [ { \"hostName\": \"some.vendor.com\", \"hostType\": \"packagist\", \"encrypted\": { \"username\": \"<your-encrypted-password\", \"password\": \"<your-encrypted-password\" } } ] }","title":"Private packages"},{"location":"presets-config/","text":"config:base Default base configuration for all languages { \"extends\": [ \":separateMajorReleases\", \":combinePatchMinorReleases\", \":ignoreUnstable\", \":prImmediately\", \":semanticPrefixFixDepsChoreOthers\", \":updateNotScheduled\", \":automergeDisabled\", \":ignoreModulesAndTests\", \":autodetectPinVersions\", \":prHourlyLimit2\", \":prConcurrentLimit20\", \"group:monorepos\", \"group:recommended\", \"helpers:disableTypesNodeMajor\", \"workarounds:all\" ] } config:base-js Base configuration for Javascript (deprecated) { \"extends\": [ \"config:base\" ] } config:js-app Default configuration for webapps { \"extends\": [ \"config:base\", \":pinAllExceptPeerDependencies\" ] } config:js-lib Default configuration for libraries { \"extends\": [ \"config:base\", \":pinOnlyDevDependencies\" ] } config:semverAllMonthly Preserve semver ranges and update everything together once a month { \"separateMajorMinor\": false, \"extends\": [ \":preserveSemverRanges\", \"group:all\", \"schedule:monthly\", \":maintainLockFilesMonthly\" ], \"lockFileMaintenance\": { \"extends\": [ \"group:all\" ], \"commitMessageAction\": \"Update\" } }","title":"Full Config Presets"},{"location":"presets-config/#configbase","text":"Default base configuration for all languages { \"extends\": [ \":separateMajorReleases\", \":combinePatchMinorReleases\", \":ignoreUnstable\", \":prImmediately\", \":semanticPrefixFixDepsChoreOthers\", \":updateNotScheduled\", \":automergeDisabled\", \":ignoreModulesAndTests\", \":autodetectPinVersions\", \":prHourlyLimit2\", \":prConcurrentLimit20\", \"group:monorepos\", \"group:recommended\", \"helpers:disableTypesNodeMajor\", \"workarounds:all\" ] }","title":"config:base"},{"location":"presets-config/#configbase-js","text":"Base configuration for Javascript (deprecated) { \"extends\": [ \"config:base\" ] }","title":"config:base-js"},{"location":"presets-config/#configjs-app","text":"Default configuration for webapps { \"extends\": [ \"config:base\", \":pinAllExceptPeerDependencies\" ] }","title":"config:js-app"},{"location":"presets-config/#configjs-lib","text":"Default configuration for libraries { \"extends\": [ \"config:base\", \":pinOnlyDevDependencies\" ] }","title":"config:js-lib"},{"location":"presets-config/#configsemverallmonthly","text":"Preserve semver ranges and update everything together once a month { \"separateMajorMinor\": false, \"extends\": [ \":preserveSemverRanges\", \"group:all\", \"schedule:monthly\", \":maintainLockFilesMonthly\" ], \"lockFileMaintenance\": { \"extends\": [ \"group:all\" ], \"commitMessageAction\": \"Update\" } }","title":"config:semverAllMonthly"},{"location":"presets-default/","text":":enableRenovate Enable renovate { \"enabled\": true } :disableRenovate Disable renovate { \"enabled\": false } :disableMajorUpdates Disables major updates { \"major\": { \"enabled\": false } } :disableDomain( <arg0> ) Disable requests to a particular domain { \"hostRules\": [ { \"domainName\": \"arg0\", \"enabled\": false } ] } :disableHost( <arg0> ) Disable requests to a particular hostName { \"hostRules\": [ { \"hostName\": \"arg0\", \"enabled\": false } ] } :ignoreModulesAndTests Ignore node_modules , bower_components , vendor and various test/tests directories { \"ignorePaths\": [ \"**/node_modules/**\", \"**/bower_components/**\", \"**/vendor/**\", \"**/examples/**\", \"**/__tests__/**\", \"**/test/**\", \"**/tests/**\", \"**/__fixtures__/**\" ] } :includeNodeModules Include package.json files found within node_modules folders or bower_components . { \"ignorePaths\": [] } :pinVersions Use version pinning (maintain a single version only and not semver ranges) { \"rangeStrategy\": \"pin\" } :preserveSemverRanges Preserve (but continue to upgrade) any existing semver ranges { \"rangeStrategy\": \"replace\" } :pinAllExceptPeerDependencies Pin dependency versions for all except peerDependencies { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"rangeStrategy\": \"pin\" }, { \"matchDepTypes\": [ \"engines\", \"peerDependencies\" ], \"rangeStrategy\": \"auto\" } ] } :pinDependencies Pin dependency versions for dependencies { \"packageRules\": [ { \"matchDepTypes\": [ \"dependencies\" ], \"rangeStrategy\": \"pin\" } ] } :pinDevDependencies Pin dependency versions for devDependencies { \"packageRules\": [ { \"matchDepTypes\": [ \"devDependencies\" ], \"rangeStrategy\": \"pin\" } ] } :pinOnlyDevDependencies Pin dependency versions for devDependencies and retain semver ranges for others { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"rangeStrategy\": \"replace\" }, { \"matchDepTypes\": [ \"devDependencies\" ], \"rangeStrategy\": \"pin\" }, { \"matchDepTypes\": [ \"peerDependencies\" ], \"rangeStrategy\": \"widen\" } ] } :autodetectPinVersions Autodetect whether to pin dependencies or maintain ranges { \"rangeStrategy\": \"auto\" } :separateMajorReleases Separate major versions of dependencies into individual branches/PRs { \"separateMajorMinor\": true } :separateMultipleMajorReleases Separate each available major versions of dependencies into individual branches/PRs { \"separateMajorMinor\": true, \"separateMultipleMajor\": true } :separatePatchReleases Separate patch and minor releases of dependencies into separate PRs { \"separateMinorPatch\": true } :combinePatchMinorReleases Do not separate patch and minor upgrades into separate PRs for the same dependency { \"separateMinorPatch\": false } :renovatePrefix Use renovate/ as prefix for all branch names { \"branchPrefix\": \"renovate/\" } :semanticCommitType( <arg0> ) Use arg0 as semantic commit type for commit messages and PR titles { \"semanticCommitType\": \"arg0\" } :semanticPrefixChore Use chore as semantic commit type for commit messages and PR titles { \"extends\": [ \":semanticCommitType(chore)\" ] } :semanticPrefixFix Use fix as semantic commit type for commit messages and PR titles { \"extends\": [ \":semanticCommitType(fix)\" ] } :disablePeerDependencies Do not renovate peerDependencies versions/ranges { \"packageRules\": [ { \"matchDepTypes\": [ \"peerDependencies\" ], \"enabled\": false } ] } :disableDevDependencies Do not renovate devDependencies versions/ranges { \"packageRules\": [ { \"matchDepTypes\": [ \"devDependencies\" ], \"enabled\": false } ] } :disableDigestUpdates Disable digest and git hash updates { \"digest\": { \"enabled\": false } } :semanticPrefixFixDepsChoreOthers If semantic commits detected, use semantic commit type fix for dependencies and chore for all others { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"semanticCommitType\": \"chore\" }, { \"matchDepTypes\": [ \"dependencies\", \"require\" ], \"semanticCommitType\": \"fix\" } ] } :semanticCommitTypeAll( <arg0> ) If semantic commits detected, use semantic commit type arg0 for all { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"semanticCommitType\": \"arg0\" } ] } :rebaseStalePrs Rebase existing PRs any time the base branch has been updated { \"rebaseWhen\": \"behind-base-branch\" } :prImmediately Raise PRs immediately (after branch is created) { \"prCreation\": \"immediate\" } :prNotPending Wait until branch tests have passed or failed before creating the PR { \"prCreation\": \"not-pending\" } :prHourlyLimitNone Removes rate limit for PR creation per hour { \"prHourlyLimit\": 0 } :prHourlyLimit1 Rate limit PR creation to a maximum of one per hour { \"prHourlyLimit\": 1 } :prHourlyLimit2 Rate limit PR creation to a maximum of two per hour { \"prHourlyLimit\": 2 } :prHourlyLimit4 Rate limit PR creation to a maximum of four per hour { \"prHourlyLimit\": 4 } :prConcurrentLimitNone Remove limit for open PRs { \"prConcurrentLimit\": 0 } :prConcurrentLimit10 Limit to maximum 10 open PRs { \"prConcurrentLimit\": 10 } :prConcurrentLimit20 Limit to maximum 20 open PRs at any time { \"prConcurrentLimit\": 20 } :disableRateLimiting Remove hourly and concurrent rate limits { \"prConcurrentLimit\": 0, \"prHourlyLimit\": 0 } :automergeDisabled Disable automerging feature - wait for humans to merge all PRs { \"automerge\": false } :automergeDigest Automerge digest upgrades if they pass tests { \"digest\": { \"automerge\": true } } :automergePatch Automerge patch upgrades if they pass tests { \"separateMinorPatch\": true, \"patch\": { \"automerge\": true }, \"pin\": { \"automerge\": true }, \"lockFileMaintenance\": { \"automerge\": true } } :automergeMinor Automerge patch and minor upgrades if they pass tests { \"minor\": { \"automerge\": true }, \"patch\": { \"automerge\": true }, \"pin\": { \"automerge\": true }, \"lockFileMaintenance\": { \"automerge\": true } } :automergeMajor Automerge all upgrades (including major) if they pass tests { \"automerge\": true } :automergeAll Automerge all upgrades (including major) if they pass tests { \"automerge\": true } :automergeBranch If automerging, push the new commit directly to base branch (no PR) { \"automergeType\": \"branch\" } :automergeBranchMergeCommit If automerging, perform a merge-commit on branch (no PR) - deprecated, use :automergeBranch instead { \"automergeType\": \"branch-merge-commit\" } :automergeBranchPush If automerging, push the new commit directly to base branch (no PR) - deprecated, use :automergeBranch instead { \"automergeType\": \"branch-push\" } :automergePr Raise a PR first before any automerging { \"automergeType\": \"pr\" } :automergeRequireAllStatusChecks Require all status checks to pass before any automerging { \"requiredStatusChecks\": [] } :skipStatusChecks Skip status checks and automerge right away { \"requiredStatusChecks\": null } :maintainLockFilesDisabled Update existing lock files only when package.json is modified { \"lockFileMaintenance\": { \"enabled\": false } } :pinDigestsDisabled Disable pinning of docker dependency digests { \"pinDigests\": false } :maintainLockFilesWeekly Run lock file maintenance (updates) early Monday mornings { \"lockFileMaintenance\": { \"enabled\": true, \"extends\": [ \"schedule:weekly\" ] } } :maintainLockFilesMonthly Run lock file maintenance (updates) on the first day of each month { \"lockFileMaintenance\": { \"enabled\": true, \"extends\": [ \"schedule:monthly\" ] } } :ignoreUnstable Upgrade to unstable versions only if the existing version is unstable { \"ignoreUnstable\": true } :respectLatest Upgrade versions up to the \"latest\" tag in npm registry { \"respectLatest\": true } :updateNotScheduled Keep existing branches updated even when not scheduled { \"updateNotScheduled\": true } :noUnscheduledUpdates Make no updates to branches when not scheduled { \"updateNotScheduled\": false } :automergeLinters Update lint packages automatically if tests pass { \"packageRules\": [ { \"extends\": [ \"packages:linters\" ], \"automerge\": true } ] } :automergeTesters Update testing packages automatically if tests pass { \"packageRules\": [ { \"extends\": [ \"packages:test\" ], \"automerge\": true } ] } :automergeTypes Update @types/* packages automatically if tests pass { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^@types/\" ], \"automerge\": true } ] } :doNotPinPackage( <arg0> ) Disable version pinning for arg0 { \"packageRules\": [ { \"matchPackageNames\": [ \"arg0\" ], \"rangeStrategy\": \"replace\" } ] } :pinSkipCi Add [skip ci] to commit message body whenever pinning { \"pin\": { \"commitBody\": \"[skip ci]\" } } :gitSignOff Append git Signed-off-by signature to git commits. { \"commitBody\": \"Signed-off-by: {{{gitAuthor}}}\" } :npm Keep package.json npm dependencies updated { \"npm\": { \"enabled\": true } } :gomod Enable Go modules support { \"gomod\": { \"enabled\": true } } :onlyNpm Renovate only npm dependencies { \"docker\": { \"enabled\": false }, \"meteor\": { \"enabled\": false } } :docker Keep Dockerfile FROM sources updated { \"docker\": { \"enabled\": true } } :meteor Keep Meteor Npm.depends packages updated { \"meteor\": { \"enabled\": true } } :group( <arg0> , <arg1> ) Group arg1 packages into same branch/PR { \"packageRules\": [ { \"extends\": [ \"arg0\" ], \"groupName\": \"arg1\" } ] } :label( <arg0> ) Apply label arg0 to PRs { \"labels\": [ \"arg0\" ] } :labels( <arg0> , <arg1> ) Apply labels arg0 and arg1 to PRs { \"labels\": [ \"arg0\", \"arg1\" ] } :assignee( <arg0> ) Assign PRs to arg0 { \"assignees\": [ \"arg0\" ] } :reviewer( <arg0> ) Add arg0 as reviewer for PRs { \"reviewers\": [ \"arg0\" ] } :assignAndReview( <arg0> ) Set arg0 as assignee and reviewer of PRs { \"extends\": [ \":assignee(arg0)\", \":reviewer(arg0)\" ] } :enableVulnerabilityAlerts Raise PR when vulnerability alerts are detected { \"vulnerabilityAlerts\": { \"enabled\": true } } :enableVulnerabilityAlertsWithLabel( <arg0> ) Raise PR when vulnerability alerts are detected with label arg0 { \"vulnerabilityAlerts\": { \"enabled\": true, \"labels\": [ \"arg0\" ] } } :disableVulnerabilityAlerts Disable vulnerability alerts completely { \"vulnerabilityAlerts\": { \"enabled\": false } } :semanticCommits Use semantic prefixes for commit messages and PR titles { \"semanticCommits\": \"enabled\" } :semanticCommitsDisabled Disable semantic prefixes for commit messages and PR titles { \"semanticCommits\": \"disabled\" } :disableLockFiles Disable lock file updates { \"updateLockFiles\": false } :semanticCommitScope( <arg0> ) Use semantic commit scope arg0 for all commits and PR titles { \"semanticCommitScope\": \"arg0\" } :semanticCommitScopeDisabled Disable semantic commit scope for all commits and PR titles { \"semanticCommitScope\": null } :widenPeerDependencies Always widen peerDependencies semver ranges when updating, instead of replacing { \"packageRules\": [ { \"matchDepTypes\": [ \"peerDependencies\" ], \"rangeStrategy\": \"widen\" } ] } :dependencyDashboard Enable Renovate Dependency Dashboard creation { \"dependencyDashboard\": true } :dependencyDashboardApproval Enable Renovate Dependency Dashboard approval workflow { \"dependencyDashboardApproval\": true } :timezone( <arg0> ) Evaluate schedules according to timezone arg0 { \"timezone\": \"arg0\" } :pathSemanticCommitType( <arg0> , <arg1> ) Use semanticCommitType arg0 for all package files matching path arg1 { \"packageRules\": [ { \"matchPaths\": [ \"arg0\" ], \"semanticCommitType\": \"arg1\" } ] } :followTag( <arg0> , <arg1> ) For package arg0 , strictly follow release tag arg1 { \"packageRules\": [ { \"matchPackageNames\": [ \"arg0\" ], \"followTag\": \"arg1\" } ] } :githubComToken( <arg0> ) Use provided token for github.com lookups { \"hostRules\": [ { \"domainName\": \"github.com\", \"encrypted\": { \"token\": \"arg0\" } } ] } :base deprecated alias for config:base { \"extends\": [ \"config:base\" ] } :app deprecated alias for config:js-app { \"extends\": [ \"config:js-app\" ] } :library deprecated alias for config:js-lib { \"extends\": [ \"config:js-lib\" ] } :disablePrControls Remove the checkbox controls from PRs { \"prBodyTemplate\": \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{footer}}}\" } :enableGradleLite Enable the gradle-lite manager { \"gradle-lite\": { \"enabled\": true } } :switchToGradleLite Enable the gradle-lite manager and disable gradle { \"gradle\": { \"enabled\": false }, \"gradle-lite\": { \"enabled\": true } }","title":"Default Presets"},{"location":"presets-default/#enablerenovate","text":"Enable renovate { \"enabled\": true }","title":":enableRenovate"},{"location":"presets-default/#disablerenovate","text":"Disable renovate { \"enabled\": false }","title":":disableRenovate"},{"location":"presets-default/#disablemajorupdates","text":"Disables major updates { \"major\": { \"enabled\": false } }","title":":disableMajorUpdates"},{"location":"presets-default/#disabledomainltarg0gt","text":"Disable requests to a particular domain { \"hostRules\": [ { \"domainName\": \"arg0\", \"enabled\": false } ] }","title":":disableDomain(&lt;arg0&gt;)"},{"location":"presets-default/#disablehostltarg0gt","text":"Disable requests to a particular hostName { \"hostRules\": [ { \"hostName\": \"arg0\", \"enabled\": false } ] }","title":":disableHost(&lt;arg0&gt;)"},{"location":"presets-default/#ignoremodulesandtests","text":"Ignore node_modules , bower_components , vendor and various test/tests directories { \"ignorePaths\": [ \"**/node_modules/**\", \"**/bower_components/**\", \"**/vendor/**\", \"**/examples/**\", \"**/__tests__/**\", \"**/test/**\", \"**/tests/**\", \"**/__fixtures__/**\" ] }","title":":ignoreModulesAndTests"},{"location":"presets-default/#includenodemodules","text":"Include package.json files found within node_modules folders or bower_components . { \"ignorePaths\": [] }","title":":includeNodeModules"},{"location":"presets-default/#pinversions","text":"Use version pinning (maintain a single version only and not semver ranges) { \"rangeStrategy\": \"pin\" }","title":":pinVersions"},{"location":"presets-default/#preservesemverranges","text":"Preserve (but continue to upgrade) any existing semver ranges { \"rangeStrategy\": \"replace\" }","title":":preserveSemverRanges"},{"location":"presets-default/#pinallexceptpeerdependencies","text":"Pin dependency versions for all except peerDependencies { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"rangeStrategy\": \"pin\" }, { \"matchDepTypes\": [ \"engines\", \"peerDependencies\" ], \"rangeStrategy\": \"auto\" } ] }","title":":pinAllExceptPeerDependencies"},{"location":"presets-default/#pindependencies","text":"Pin dependency versions for dependencies { \"packageRules\": [ { \"matchDepTypes\": [ \"dependencies\" ], \"rangeStrategy\": \"pin\" } ] }","title":":pinDependencies"},{"location":"presets-default/#pindevdependencies","text":"Pin dependency versions for devDependencies { \"packageRules\": [ { \"matchDepTypes\": [ \"devDependencies\" ], \"rangeStrategy\": \"pin\" } ] }","title":":pinDevDependencies"},{"location":"presets-default/#pinonlydevdependencies","text":"Pin dependency versions for devDependencies and retain semver ranges for others { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"rangeStrategy\": \"replace\" }, { \"matchDepTypes\": [ \"devDependencies\" ], \"rangeStrategy\": \"pin\" }, { \"matchDepTypes\": [ \"peerDependencies\" ], \"rangeStrategy\": \"widen\" } ] }","title":":pinOnlyDevDependencies"},{"location":"presets-default/#autodetectpinversions","text":"Autodetect whether to pin dependencies or maintain ranges { \"rangeStrategy\": \"auto\" }","title":":autodetectPinVersions"},{"location":"presets-default/#separatemajorreleases","text":"Separate major versions of dependencies into individual branches/PRs { \"separateMajorMinor\": true }","title":":separateMajorReleases"},{"location":"presets-default/#separatemultiplemajorreleases","text":"Separate each available major versions of dependencies into individual branches/PRs { \"separateMajorMinor\": true, \"separateMultipleMajor\": true }","title":":separateMultipleMajorReleases"},{"location":"presets-default/#separatepatchreleases","text":"Separate patch and minor releases of dependencies into separate PRs { \"separateMinorPatch\": true }","title":":separatePatchReleases"},{"location":"presets-default/#combinepatchminorreleases","text":"Do not separate patch and minor upgrades into separate PRs for the same dependency { \"separateMinorPatch\": false }","title":":combinePatchMinorReleases"},{"location":"presets-default/#renovateprefix","text":"Use renovate/ as prefix for all branch names { \"branchPrefix\": \"renovate/\" }","title":":renovatePrefix"},{"location":"presets-default/#semanticcommittypeltarg0gt","text":"Use arg0 as semantic commit type for commit messages and PR titles { \"semanticCommitType\": \"arg0\" }","title":":semanticCommitType(&lt;arg0&gt;)"},{"location":"presets-default/#semanticprefixchore","text":"Use chore as semantic commit type for commit messages and PR titles { \"extends\": [ \":semanticCommitType(chore)\" ] }","title":":semanticPrefixChore"},{"location":"presets-default/#semanticprefixfix","text":"Use fix as semantic commit type for commit messages and PR titles { \"extends\": [ \":semanticCommitType(fix)\" ] }","title":":semanticPrefixFix"},{"location":"presets-default/#disablepeerdependencies","text":"Do not renovate peerDependencies versions/ranges { \"packageRules\": [ { \"matchDepTypes\": [ \"peerDependencies\" ], \"enabled\": false } ] }","title":":disablePeerDependencies"},{"location":"presets-default/#disabledevdependencies","text":"Do not renovate devDependencies versions/ranges { \"packageRules\": [ { \"matchDepTypes\": [ \"devDependencies\" ], \"enabled\": false } ] }","title":":disableDevDependencies"},{"location":"presets-default/#disabledigestupdates","text":"Disable digest and git hash updates { \"digest\": { \"enabled\": false } }","title":":disableDigestUpdates"},{"location":"presets-default/#semanticprefixfixdepschoreothers","text":"If semantic commits detected, use semantic commit type fix for dependencies and chore for all others { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"semanticCommitType\": \"chore\" }, { \"matchDepTypes\": [ \"dependencies\", \"require\" ], \"semanticCommitType\": \"fix\" } ] }","title":":semanticPrefixFixDepsChoreOthers"},{"location":"presets-default/#semanticcommittypeallltarg0gt","text":"If semantic commits detected, use semantic commit type arg0 for all { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"semanticCommitType\": \"arg0\" } ] }","title":":semanticCommitTypeAll(&lt;arg0&gt;)"},{"location":"presets-default/#rebasestaleprs","text":"Rebase existing PRs any time the base branch has been updated { \"rebaseWhen\": \"behind-base-branch\" }","title":":rebaseStalePrs"},{"location":"presets-default/#primmediately","text":"Raise PRs immediately (after branch is created) { \"prCreation\": \"immediate\" }","title":":prImmediately"},{"location":"presets-default/#prnotpending","text":"Wait until branch tests have passed or failed before creating the PR { \"prCreation\": \"not-pending\" }","title":":prNotPending"},{"location":"presets-default/#prhourlylimitnone","text":"Removes rate limit for PR creation per hour { \"prHourlyLimit\": 0 }","title":":prHourlyLimitNone"},{"location":"presets-default/#prhourlylimit1","text":"Rate limit PR creation to a maximum of one per hour { \"prHourlyLimit\": 1 }","title":":prHourlyLimit1"},{"location":"presets-default/#prhourlylimit2","text":"Rate limit PR creation to a maximum of two per hour { \"prHourlyLimit\": 2 }","title":":prHourlyLimit2"},{"location":"presets-default/#prhourlylimit4","text":"Rate limit PR creation to a maximum of four per hour { \"prHourlyLimit\": 4 }","title":":prHourlyLimit4"},{"location":"presets-default/#prconcurrentlimitnone","text":"Remove limit for open PRs { \"prConcurrentLimit\": 0 }","title":":prConcurrentLimitNone"},{"location":"presets-default/#prconcurrentlimit10","text":"Limit to maximum 10 open PRs { \"prConcurrentLimit\": 10 }","title":":prConcurrentLimit10"},{"location":"presets-default/#prconcurrentlimit20","text":"Limit to maximum 20 open PRs at any time { \"prConcurrentLimit\": 20 }","title":":prConcurrentLimit20"},{"location":"presets-default/#disableratelimiting","text":"Remove hourly and concurrent rate limits { \"prConcurrentLimit\": 0, \"prHourlyLimit\": 0 }","title":":disableRateLimiting"},{"location":"presets-default/#automergedisabled","text":"Disable automerging feature - wait for humans to merge all PRs { \"automerge\": false }","title":":automergeDisabled"},{"location":"presets-default/#automergedigest","text":"Automerge digest upgrades if they pass tests { \"digest\": { \"automerge\": true } }","title":":automergeDigest"},{"location":"presets-default/#automergepatch","text":"Automerge patch upgrades if they pass tests { \"separateMinorPatch\": true, \"patch\": { \"automerge\": true }, \"pin\": { \"automerge\": true }, \"lockFileMaintenance\": { \"automerge\": true } }","title":":automergePatch"},{"location":"presets-default/#automergeminor","text":"Automerge patch and minor upgrades if they pass tests { \"minor\": { \"automerge\": true }, \"patch\": { \"automerge\": true }, \"pin\": { \"automerge\": true }, \"lockFileMaintenance\": { \"automerge\": true } }","title":":automergeMinor"},{"location":"presets-default/#automergemajor","text":"Automerge all upgrades (including major) if they pass tests { \"automerge\": true }","title":":automergeMajor"},{"location":"presets-default/#automergeall","text":"Automerge all upgrades (including major) if they pass tests { \"automerge\": true }","title":":automergeAll"},{"location":"presets-default/#automergebranch","text":"If automerging, push the new commit directly to base branch (no PR) { \"automergeType\": \"branch\" }","title":":automergeBranch"},{"location":"presets-default/#automergebranchmergecommit","text":"If automerging, perform a merge-commit on branch (no PR) - deprecated, use :automergeBranch instead { \"automergeType\": \"branch-merge-commit\" }","title":":automergeBranchMergeCommit"},{"location":"presets-default/#automergebranchpush","text":"If automerging, push the new commit directly to base branch (no PR) - deprecated, use :automergeBranch instead { \"automergeType\": \"branch-push\" }","title":":automergeBranchPush"},{"location":"presets-default/#automergepr","text":"Raise a PR first before any automerging { \"automergeType\": \"pr\" }","title":":automergePr"},{"location":"presets-default/#automergerequireallstatuschecks","text":"Require all status checks to pass before any automerging { \"requiredStatusChecks\": [] }","title":":automergeRequireAllStatusChecks"},{"location":"presets-default/#skipstatuschecks","text":"Skip status checks and automerge right away { \"requiredStatusChecks\": null }","title":":skipStatusChecks"},{"location":"presets-default/#maintainlockfilesdisabled","text":"Update existing lock files only when package.json is modified { \"lockFileMaintenance\": { \"enabled\": false } }","title":":maintainLockFilesDisabled"},{"location":"presets-default/#pindigestsdisabled","text":"Disable pinning of docker dependency digests { \"pinDigests\": false }","title":":pinDigestsDisabled"},{"location":"presets-default/#maintainlockfilesweekly","text":"Run lock file maintenance (updates) early Monday mornings { \"lockFileMaintenance\": { \"enabled\": true, \"extends\": [ \"schedule:weekly\" ] } }","title":":maintainLockFilesWeekly"},{"location":"presets-default/#maintainlockfilesmonthly","text":"Run lock file maintenance (updates) on the first day of each month { \"lockFileMaintenance\": { \"enabled\": true, \"extends\": [ \"schedule:monthly\" ] } }","title":":maintainLockFilesMonthly"},{"location":"presets-default/#ignoreunstable","text":"Upgrade to unstable versions only if the existing version is unstable { \"ignoreUnstable\": true }","title":":ignoreUnstable"},{"location":"presets-default/#respectlatest","text":"Upgrade versions up to the \"latest\" tag in npm registry { \"respectLatest\": true }","title":":respectLatest"},{"location":"presets-default/#updatenotscheduled","text":"Keep existing branches updated even when not scheduled { \"updateNotScheduled\": true }","title":":updateNotScheduled"},{"location":"presets-default/#nounscheduledupdates","text":"Make no updates to branches when not scheduled { \"updateNotScheduled\": false }","title":":noUnscheduledUpdates"},{"location":"presets-default/#automergelinters","text":"Update lint packages automatically if tests pass { \"packageRules\": [ { \"extends\": [ \"packages:linters\" ], \"automerge\": true } ] }","title":":automergeLinters"},{"location":"presets-default/#automergetesters","text":"Update testing packages automatically if tests pass { \"packageRules\": [ { \"extends\": [ \"packages:test\" ], \"automerge\": true } ] }","title":":automergeTesters"},{"location":"presets-default/#automergetypes","text":"Update @types/* packages automatically if tests pass { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^@types/\" ], \"automerge\": true } ] }","title":":automergeTypes"},{"location":"presets-default/#donotpinpackageltarg0gt","text":"Disable version pinning for arg0 { \"packageRules\": [ { \"matchPackageNames\": [ \"arg0\" ], \"rangeStrategy\": \"replace\" } ] }","title":":doNotPinPackage(&lt;arg0&gt;)"},{"location":"presets-default/#pinskipci","text":"Add [skip ci] to commit message body whenever pinning { \"pin\": { \"commitBody\": \"[skip ci]\" } }","title":":pinSkipCi"},{"location":"presets-default/#gitsignoff","text":"Append git Signed-off-by signature to git commits. { \"commitBody\": \"Signed-off-by: {{{gitAuthor}}}\" }","title":":gitSignOff"},{"location":"presets-default/#npm","text":"Keep package.json npm dependencies updated { \"npm\": { \"enabled\": true } }","title":":npm"},{"location":"presets-default/#gomod","text":"Enable Go modules support { \"gomod\": { \"enabled\": true } }","title":":gomod"},{"location":"presets-default/#onlynpm","text":"Renovate only npm dependencies { \"docker\": { \"enabled\": false }, \"meteor\": { \"enabled\": false } }","title":":onlyNpm"},{"location":"presets-default/#docker","text":"Keep Dockerfile FROM sources updated { \"docker\": { \"enabled\": true } }","title":":docker"},{"location":"presets-default/#meteor","text":"Keep Meteor Npm.depends packages updated { \"meteor\": { \"enabled\": true } }","title":":meteor"},{"location":"presets-default/#groupltarg0gt-ltarg1gt","text":"Group arg1 packages into same branch/PR { \"packageRules\": [ { \"extends\": [ \"arg0\" ], \"groupName\": \"arg1\" } ] }","title":":group(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#labelltarg0gt","text":"Apply label arg0 to PRs { \"labels\": [ \"arg0\" ] }","title":":label(&lt;arg0&gt;)"},{"location":"presets-default/#labelsltarg0gt-ltarg1gt","text":"Apply labels arg0 and arg1 to PRs { \"labels\": [ \"arg0\", \"arg1\" ] }","title":":labels(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#assigneeltarg0gt","text":"Assign PRs to arg0 { \"assignees\": [ \"arg0\" ] }","title":":assignee(&lt;arg0&gt;)"},{"location":"presets-default/#reviewerltarg0gt","text":"Add arg0 as reviewer for PRs { \"reviewers\": [ \"arg0\" ] }","title":":reviewer(&lt;arg0&gt;)"},{"location":"presets-default/#assignandreviewltarg0gt","text":"Set arg0 as assignee and reviewer of PRs { \"extends\": [ \":assignee(arg0)\", \":reviewer(arg0)\" ] }","title":":assignAndReview(&lt;arg0&gt;)"},{"location":"presets-default/#enablevulnerabilityalerts","text":"Raise PR when vulnerability alerts are detected { \"vulnerabilityAlerts\": { \"enabled\": true } }","title":":enableVulnerabilityAlerts"},{"location":"presets-default/#enablevulnerabilityalertswithlabelltarg0gt","text":"Raise PR when vulnerability alerts are detected with label arg0 { \"vulnerabilityAlerts\": { \"enabled\": true, \"labels\": [ \"arg0\" ] } }","title":":enableVulnerabilityAlertsWithLabel(&lt;arg0&gt;)"},{"location":"presets-default/#disablevulnerabilityalerts","text":"Disable vulnerability alerts completely { \"vulnerabilityAlerts\": { \"enabled\": false } }","title":":disableVulnerabilityAlerts"},{"location":"presets-default/#semanticcommits","text":"Use semantic prefixes for commit messages and PR titles { \"semanticCommits\": \"enabled\" }","title":":semanticCommits"},{"location":"presets-default/#semanticcommitsdisabled","text":"Disable semantic prefixes for commit messages and PR titles { \"semanticCommits\": \"disabled\" }","title":":semanticCommitsDisabled"},{"location":"presets-default/#disablelockfiles","text":"Disable lock file updates { \"updateLockFiles\": false }","title":":disableLockFiles"},{"location":"presets-default/#semanticcommitscopeltarg0gt","text":"Use semantic commit scope arg0 for all commits and PR titles { \"semanticCommitScope\": \"arg0\" }","title":":semanticCommitScope(&lt;arg0&gt;)"},{"location":"presets-default/#semanticcommitscopedisabled","text":"Disable semantic commit scope for all commits and PR titles { \"semanticCommitScope\": null }","title":":semanticCommitScopeDisabled"},{"location":"presets-default/#widenpeerdependencies","text":"Always widen peerDependencies semver ranges when updating, instead of replacing { \"packageRules\": [ { \"matchDepTypes\": [ \"peerDependencies\" ], \"rangeStrategy\": \"widen\" } ] }","title":":widenPeerDependencies"},{"location":"presets-default/#dependencydashboard","text":"Enable Renovate Dependency Dashboard creation { \"dependencyDashboard\": true }","title":":dependencyDashboard"},{"location":"presets-default/#dependencydashboardapproval","text":"Enable Renovate Dependency Dashboard approval workflow { \"dependencyDashboardApproval\": true }","title":":dependencyDashboardApproval"},{"location":"presets-default/#timezoneltarg0gt","text":"Evaluate schedules according to timezone arg0 { \"timezone\": \"arg0\" }","title":":timezone(&lt;arg0&gt;)"},{"location":"presets-default/#pathsemanticcommittypeltarg0gt-ltarg1gt","text":"Use semanticCommitType arg0 for all package files matching path arg1 { \"packageRules\": [ { \"matchPaths\": [ \"arg0\" ], \"semanticCommitType\": \"arg1\" } ] }","title":":pathSemanticCommitType(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#followtagltarg0gt-ltarg1gt","text":"For package arg0 , strictly follow release tag arg1 { \"packageRules\": [ { \"matchPackageNames\": [ \"arg0\" ], \"followTag\": \"arg1\" } ] }","title":":followTag(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#githubcomtokenltarg0gt","text":"Use provided token for github.com lookups { \"hostRules\": [ { \"domainName\": \"github.com\", \"encrypted\": { \"token\": \"arg0\" } } ] }","title":":githubComToken(&lt;arg0&gt;)"},{"location":"presets-default/#base","text":"deprecated alias for config:base { \"extends\": [ \"config:base\" ] }","title":":base"},{"location":"presets-default/#app","text":"deprecated alias for config:js-app { \"extends\": [ \"config:js-app\" ] }","title":":app"},{"location":"presets-default/#library","text":"deprecated alias for config:js-lib { \"extends\": [ \"config:js-lib\" ] }","title":":library"},{"location":"presets-default/#disableprcontrols","text":"Remove the checkbox controls from PRs { \"prBodyTemplate\": \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{footer}}}\" }","title":":disablePrControls"},{"location":"presets-default/#enablegradlelite","text":"Enable the gradle-lite manager { \"gradle-lite\": { \"enabled\": true } }","title":":enableGradleLite"},{"location":"presets-default/#switchtogradlelite","text":"Enable the gradle-lite manager and disable gradle { \"gradle\": { \"enabled\": false }, \"gradle-lite\": { \"enabled\": true } }","title":":switchToGradleLite"},{"location":"presets-docker/","text":"docker:disable Disable docker updates { \"docker\": { \"enabled\": false }, \"docker-compose\": { \"enabled\": false }, \"circleci\": { \"enabled\": false } } docker:enableMajor Enable docker major updates { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": true } ] } docker:disableMajor Disable docker major updates { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": false } ] } docker:pinDigests Pin Docker digests { \"docker\": { \"pinDigests\": true } }","title":"Docker Presets"},{"location":"presets-docker/#dockerdisable","text":"Disable docker updates { \"docker\": { \"enabled\": false }, \"docker-compose\": { \"enabled\": false }, \"circleci\": { \"enabled\": false } }","title":"docker:disable"},{"location":"presets-docker/#dockerenablemajor","text":"Enable docker major updates { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": true } ] }","title":"docker:enableMajor"},{"location":"presets-docker/#dockerdisablemajor","text":"Disable docker major updates { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": false } ] }","title":"docker:disableMajor"},{"location":"presets-docker/#dockerpindigests","text":"Pin Docker digests { \"docker\": { \"pinDigests\": true } }","title":"docker:pinDigests"},{"location":"presets-group/","text":"group:all Group all updates together { \"groupName\": \"all dependencies\", \"separateMajorMinor\": false, \"groupSlug\": \"all\", \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"groupName\": \"all dependencies\", \"groupSlug\": \"all\" } ], \"lockFileMaintenance\": { \"enabled\": false } } group:allNonMajor Group all minor and patch updates together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"matchUpdateTypes\": [ \"minor\", \"patch\" ], \"groupName\": \"all non-major dependencies\", \"groupSlug\": \"all-minor-patch\" } ] } group:recommended Use curated list of recommended non-monorepo package groupings { \"extends\": [ \"group:allApollographql\", \"group:fortawesome\", \"group:fusionjs\", \"group:glimmer\", \"group:goOpenapi\", \"group:hibernateCore\", \"group:hibernateValidator\", \"group:hibernateOgm\", \"group:hibernateCommons\", \"group:illuminate\", \"group:jekyllEcosystem\", \"group:polymer\", \"group:resilience4j\", \"group:rubyOmniauth\", \"group:socketio\", \"group:springAmqp\", \"group:springAndroid\", \"group:springBatch\", \"group:springBoot\", \"group:springCloud\", \"group:springCore\", \"group:springData\", \"group:springHateoas\", \"group:springIntegration\", \"group:springKafka\", \"group:springLdap\", \"group:springMobile\", \"group:springOsgi\", \"group:springRestDocs\", \"group:springRoo\", \"group:springScala\", \"group:springSecurity\", \"group:springSession\", \"group:springShell\", \"group:springSocial\", \"group:springStatemachine\", \"group:springWebflow\", \"group:springWs\", \"group:symfony\" ], \"ignoreDeps\": [] } group:allApollographql Group all packages published by Apollo GraphQL together { \"packageRules\": [ { \"extends\": \"packages:apollographql\", \"groupName\": \"Apollo GraphQL packages\" } ] } group:definitelyTyped Group all @types packages together { \"packageRules\": [ { \"groupName\": \"definitelyTyped\", \"matchPackagePatterns\": [ \"^@types/\" ] } ] } group:dotNetCore .NET Core Docker containers { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchPackagePatterns\": [ \"^mcr.microsoft.com/dotnet/core/\" ], \"groupName\": \".NET Core Docker containers\" } ] } group:fortawesome Group all packages by Font Awesome together { \"packageRules\": [ { \"groupName\": \"Font Awesome\", \"matchPackagePatterns\": [ \"^@fortawesome/\" ] } ] } group:fusionjs Fusion.js packages { \"matchPackageNames\": [ \"fusion-cli\", \"fusion-core\", \"fusion-test-utils\", \"fusion-tokens\" ], \"matchPackagePatterns\": [ \"^fusion-plugin-*\", \"^fusion-react*\", \"^fusion-apollo*\" ] } group:glimmer Group Glimmer.js packages together { \"packageRules\": [ { \"groupName\": \"Glimmer.js packages\", \"groupSlug\": \"glimmer\", \"matchPackageNames\": [ \"@glimmer/component\", \"@glimmer/tracking\" ] } ] } group:illuminate Group PHP illuminate packages together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^illuminate/\" ], \"groupName\": \"illuminate packages\", \"groupSlug\": \"illuminate\" } ] } group:symfony Group PHP symfony packages together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^symfony/\" ], \"groupName\": \"symfony packages\", \"groupSlug\": \"symfony\" } ] } group:polymer Group all @polymer packages together { \"packageRules\": [ { \"groupName\": \"polymer packages\", \"matchPackagePatterns\": [ \"^@polymer/\" ] } ] } group:hibernateCore Group Java Hibernate Core packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate:\" ], \"groupName\": \"hibernate core\" } ] } group:hibernateValidator Group Java Hibernate Validator packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.validator:\" ], \"groupName\": \"hibernate validator\" } ] } group:hibernateOgm Group Java Hibernate OGM packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.ogm:\" ], \"groupName\": \"hibernate ogm\" } ] } group:hibernateCommons Group Java Hibernate Commons packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.common:\" ], \"groupName\": \"hibernate commons\" } ] } group:resilience4j Group Java Resilience4j packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^io.github.resilience4j:\" ], \"groupName\": \"resilience4j\" } ] } group:springAmqp Group Java Spring AMQP packages { \"packageRules\": [ { \"groupName\": \"spring amqp\", \"matchPackagePatterns\": [ \"^org.springframework.amqp:\" ] } ] } group:springAndroid Group Java Spring Android packages { \"packageRules\": [ { \"groupName\": \"spring android\", \"matchPackagePatterns\": [ \"^org.springframework.android:\" ] } ] } group:springBatch Group Java Spring Batch packages { \"packageRules\": [ { \"groupName\": \"spring batch\", \"matchPackagePatterns\": [ \"^org.springframework.batch:\" ] } ] } group:springBoot Group Java Spring Boot packages { \"packageRules\": [ { \"groupName\": \"spring boot\", \"matchPackagePatterns\": [ \"^org.springframework.boot:\" ] } ] } group:springCloud Group Java Spring Cloud packages { \"packageRules\": [ { \"groupName\": \"spring cloud\", \"matchPackagePatterns\": [ \"^org.springframework.cloud:\" ] } ] } group:springCore Group Java Spring Core packages { \"packageRules\": [ { \"groupName\": \"spring core\", \"matchPackagePatterns\": [ \"^org.springframework:\" ] } ] } group:springData Group Java Spring Data packages { \"packageRules\": [ { \"groupName\": \"spring data\", \"matchPackagePatterns\": [ \"^org.springframework.data:\" ] } ] } group:springHateoas Group Java Spring HATEOAS packages { \"packageRules\": [ { \"groupName\": \"spring hateoas\", \"matchPackagePatterns\": [ \"^org.springframework.hateoas:\" ] } ] } group:springIntegration Group Java Spring Integration packages { \"packageRules\": [ { \"groupName\": \"spring integration\", \"matchPackagePatterns\": [ \"^org.springframework.integration:\" ] } ] } group:springKafka Group Java Spring Kafka packages { \"packageRules\": [ { \"groupName\": \"spring kafka\", \"matchPackagePatterns\": [ \"^org.springframework.kafka:\" ] } ] } group:springLdap Group Java Spring LDAP packages { \"packageRules\": [ { \"groupName\": \"spring ldap\", \"matchPackagePatterns\": [ \"^org.springframework.ldap:\" ] } ] } group:springMobile Group Java Spring Mobile packages { \"packageRules\": [ { \"groupName\": \"spring mobile\", \"matchPackagePatterns\": [ \"^org.springframework.mobile:\" ] } ] } group:springOsgi Group Java Spring OSGi packages { \"packageRules\": [ { \"groupName\": \"spring osgi\", \"matchPackagePatterns\": [ \"^org.springframework.osgi:\" ] } ] } group:springRestDocs Group Java Spring REST Docs packages { \"packageRules\": [ { \"groupName\": \"spring restdocs\", \"matchPackagePatterns\": [ \"^org.springframework.restdocs:\" ] } ] } group:springRoo Group Java Spring Roo packages { \"packageRules\": [ { \"groupName\": \"spring roo\", \"matchPackagePatterns\": [ \"^org.springframework.roo:\" ] } ] } group:springScala Group Java Spring Scala packages { \"packageRules\": [ { \"groupName\": \"spring scala\", \"matchPackagePatterns\": [ \"^org.springframework.scala:\" ] } ] } group:springSecurity Group Java Spring Security packages { \"packageRules\": [ { \"groupName\": \"spring security\", \"matchPackagePatterns\": [ \"^org.springframework.security:\" ] } ] } group:springSession Group Java Spring Session packages { \"packageRules\": [ { \"groupName\": \"spring session\", \"matchPackagePatterns\": [ \"^org.springframework.session:\" ] } ] } group:springShell Group Java Spring Shell packages { \"packageRules\": [ { \"groupName\": \"spring shell\", \"matchPackagePatterns\": [ \"^org.springframework.shell:\" ] } ] } group:springSocial Group Java Spring Social packages { \"packageRules\": [ { \"groupName\": \"spring social\", \"matchPackagePatterns\": [ \"^org.springframework.social:\" ] } ] } group:springStatemachine Group Java Spring Statemachine packages { \"packageRules\": [ { \"groupName\": \"spring statemachine\", \"matchPackagePatterns\": [ \"^org.springframework.statemachine:\" ] } ] } group:springWebflow Group Java Spring WebFlow packages { \"packageRules\": [ { \"groupName\": \"spring webflow\", \"matchPackagePatterns\": [ \"^org.springframework.webflow:\" ] } ] } group:springWs Group Java Spring WS packages { \"packageRules\": [ { \"groupName\": \"spring ws\", \"matchPackagePatterns\": [ \"^org.springframework.ws:\" ] } ] } group:socketio Group socket.io packages { \"packageRules\": [ { \"groupName\": \"socket.io packages\", \"matchPackagePatterns\": [ \"^socket.io\" ] } ] } group:postcss Group postcss packages together { \"packageRules\": [ { \"extends\": \"packages:postcss\", \"groupName\": \"postcss packages\" } ] } group:jekyllEcosystem Group jekyll and related ruby packages together { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [ \"https://github.com/jekyll/\", \"https://github.com/github/pages-gem\" ], \"groupName\": \"jekyll ecosystem packages\" } ] } group:rubyOmniauth Group omniauth packages together { \"packageRules\": [ { \"matchDatasources\": [ \"rubygems\" ], \"matchPackagePatterns\": [ \"^omniauth\" ], \"groupName\": \"omniauth packages\" } ] } group:goOpenapi Group go-openapi packages together { \"packageRules\": [ { \"matchDatasources\": [ \"go\" ], \"groupName\": \"go-openapi packages\", \"groupSlug\": \"go-openapi\", \"matchPackagePatterns\": [ \"^github.com/go-openapi/\" ] } ] } group:googleapis Group googleapis packages together { \"packageRules\": [ { \"extends\": \"packages:googleapis\", \"groupName\": \"googleapis packages\" } ] } group:linters Group various lint packages together { \"packageRules\": [ { \"extends\": \"packages:linters\", \"groupName\": \"linters\" } ] } group:jsUnitTest Group JS unit test packages together { \"packageRules\": [ { \"extends\": \"packages:jsUnitTest\", \"groupName\": \"JS unit test packages\" } ] } group:jsUnitTestNonMajor Group JS unit test packages together { \"packageRules\": [ { \"extends\": \"packages:jsUnitTest\", \"minor\": { \"groupName\": \"JS unit test packages\" } } ] } group:unitTest Group all unit test packages together { \"packageRules\": [ { \"extends\": \"packages:unitTest\", \"groupName\": \"unit test packages\" } ] } group:unitTestNonMajor Group all unit test packages together { \"packageRules\": [ { \"extends\": \"packages:unitTest\", \"minor\": { \"groupName\": \"unit test packages\" } } ] } group:jsTest Group JS test packages together { \"packageRules\": [ { \"extends\": \"packages:jsTest\", \"groupName\": \"JS test packages\" } ] } group:jsTestMonMajor Group non-major JS test package updates together { \"packageRules\": [ { \"extends\": \"packages:jsTest\", \"minor\": { \"groupName\": \"JS test packages\" } } ] } group:test Group all test packages together { \"packageRules\": [ { \"extends\": \"packages:test\", \"groupName\": \"test packages\" } ] } group:testNonMajor Group all non-major test package updates together { \"packageRules\": [ { \"extends\": \"packages:test\", \"minor\": { \"groupName\": \"test packages\" } } ] } group:ag-gridMonorepo Group packages from ag-grid monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ag-grid\", \"groupName\": \"ag-grid monorepo\" } ] } group:arcus event-gridMonorepo Group packages from arcus event-grid monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus event-grid\", \"groupName\": \"arcus event-grid monorepo\" } ] } group:arcus securityMonorepo Group packages from arcus security monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus security\", \"groupName\": \"arcus security monorepo\" } ] } group:arcus messagingMonorepo Group packages from arcus messaging monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus messaging\", \"groupName\": \"arcus messaging monorepo\" } ] } group:arcus observabilityMonorepo Group packages from arcus observability monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus observability\", \"groupName\": \"arcus observability monorepo\" } ] } group:arcus webapiMonorepo Group packages from arcus webapi monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus webapi\", \"groupName\": \"arcus webapi monorepo\" } ] } group:arcus background-jobsMonorepo Group packages from arcus background-jobs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus background-jobs\", \"groupName\": \"arcus background-jobs monorepo\" } ] } group:algolia-react-instantsearchMonorepo Group packages from algolia-react-instantsearch monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:algolia-react-instantsearch\", \"groupName\": \"algolia-react-instantsearch monorepo\" } ] } group:angular-eslintMonorepo Group packages from angular-eslint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular-eslint\", \"groupName\": \"angular-eslint monorepo\" } ] } group:apollo-serverMonorepo Group packages from apollo-server monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apollo-server\", \"groupName\": \"apollo-server monorepo\" } ] } group:aspnet-api-versioningMonorepo Group packages from aspnet-api-versioning monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet-api-versioning\", \"groupName\": \"aspnet-api-versioning monorepo\" } ] } group:aspnet AspNetWebStackMonorepo Group packages from aspnet AspNetWebStack monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet AspNetWebStack\", \"groupName\": \"aspnet AspNetWebStack monorepo\" } ] } group:aspnet ExtensionsMonorepo Group packages from aspnet Extensions monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet Extensions\", \"groupName\": \"aspnet Extensions monorepo\" } ] } group:aws-cdkMonorepo Group packages from aws-cdk monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-cdk\", \"groupName\": \"aws-cdk monorepo\" } ] } group:aws-sdk-js-v3Monorepo Group packages from aws-sdk-js-v3 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-sdk-js-v3\", \"groupName\": \"aws-sdk-js-v3 monorepo\" } ] } group:azure azure-libraries-for-netMonorepo Group packages from azure azure-libraries-for-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-libraries-for-net\", \"groupName\": \"azure azure-libraries-for-net monorepo\" } ] } group:azure azure-sdk-for-netMonorepo Group packages from azure azure-sdk-for-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-sdk-for-net\", \"groupName\": \"azure azure-sdk-for-net monorepo\" } ] } group:azure azure-storage-netMonorepo Group packages from azure azure-storage-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-storage-net\", \"groupName\": \"azure azure-storage-net monorepo\" } ] } group:bugsnag-jsMonorepo Group packages from bugsnag-js monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:bugsnag-js\", \"groupName\": \"bugsnag-js monorepo\" } ] } group:date-ioMonorepo Group packages from date-io monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:date-io\", \"groupName\": \"date-io monorepo\" } ] } group:devextreme-reactiveMonorepo Group packages from devextreme-reactive monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:devextreme-reactive\", \"groupName\": \"devextreme-reactive monorepo\" } ] } group:electron-forgeMonorepo Group packages from electron-forge monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:electron-forge\", \"groupName\": \"electron-forge monorepo\" } ] } group:feathers-databasesMonorepo Group packages from feathers-databases monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:feathers-databases\", \"groupName\": \"feathers-databases monorepo\" } ] } group:ember-decoratorsMonorepo Group packages from ember-decorators monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ember-decorators\", \"groupName\": \"ember-decorators monorepo\" } ] } group:graphql-modulesMonorepo Group packages from graphql-modules monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-modules\", \"groupName\": \"graphql-modules monorepo\" } ] } group:ionic-nativeMonorepo Group packages from ionic-native monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ionic-native\", \"groupName\": \"ionic-native monorepo\" } ] } group:mdc-reactMonorepo Group packages from mdc-react monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mdc-react\", \"groupName\": \"mdc-react monorepo\" } ] } group:ngx-formlyMonorepo Group packages from ngx-formly monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngx-formly\", \"groupName\": \"ngx-formly monorepo\" } ] } group:ngxs-storeMonorepo Group packages from ngxs-store monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngxs-store\", \"groupName\": \"ngxs-store monorepo\" } ] } group:reach-uiMonorepo Group packages from reach-ui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reach-ui\", \"groupName\": \"reach-ui monorepo\" } ] } group:react-apolloMonorepo Group packages from react-apollo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-apollo\", \"groupName\": \"react-apollo monorepo\" } ] } group:react-dndMonorepo Group packages from react-dnd monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-dnd\", \"groupName\": \"react-dnd monorepo\" } ] } group:react-navigationMonorepo Group packages from react-navigation monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-navigation\", \"groupName\": \"react-navigation monorepo\" } ] } group:reactivestack-cookiesMonorepo Group packages from reactivestack-cookies monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reactivestack-cookies\", \"groupName\": \"reactivestack-cookies monorepo\" } ] } group:reg-suitMonorepo Group packages from reg-suit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reg-suit\", \"groupName\": \"reg-suit monorepo\" } ] } group:semantic-releaseMonorepo Group packages from semantic-release monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:semantic-release\", \"groupName\": \"semantic-release monorepo\" } ] } group:telus-tdsMonorepo Group packages from telus-tds monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:telus-tds\", \"groupName\": \"telus-tds monorepo\" } ] } group:typescript-eslintMonorepo Group packages from typescript-eslint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typescript-eslint\", \"groupName\": \"typescript-eslint monorepo\" } ] } group:typography-jsMonorepo Group packages from typography-js monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typography-js\", \"groupName\": \"typography-js monorepo\" } ] } group:vue-cliMonorepo Group packages from vue-cli monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vue-cli\", \"groupName\": \"vue-cli monorepo\" } ] } group:accountsMonorepo Group packages from accounts monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:accounts\", \"groupName\": \"accounts monorepo\" } ] } group:angular1Monorepo Group packages from angular1 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular1\", \"groupName\": \"angular1 monorepo\" } ] } group:angularMonorepo Group packages from angular monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular\", \"groupName\": \"angular monorepo\" } ] } group:angularcliMonorepo Group packages from angularcli monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularcli\", \"groupName\": \"angularcli monorepo\" } ] } group:angularfireMonorepo Group packages from angularfire monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularfire\", \"groupName\": \"angularfire monorepo\" } ] } group:apolloclientMonorepo Group packages from apolloclient monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apolloclient\", \"groupName\": \"apolloclient monorepo\" } ] } group:apollolinkMonorepo Group packages from apollolink monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apollolink\", \"groupName\": \"apollolink monorepo\" } ] } group:awsappsyncMonorepo Group packages from awsappsync monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:awsappsync\", \"groupName\": \"awsappsync monorepo\" } ] } group:babelMonorepo Group packages from babel monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:babel\", \"groupName\": \"babel monorepo\" } ] } group:basetMonorepo Group packages from baset monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:baset\", \"groupName\": \"baset monorepo\" } ] } group:braveMonorepo Group packages from brave monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:brave\", \"groupName\": \"brave monorepo\" } ] } group:capacitorMonorepo Group packages from capacitor monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:capacitor\", \"groupName\": \"capacitor monorepo\" } ] } group:chromelyMonorepo Group packages from chromely monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:chromely\", \"groupName\": \"chromely monorepo\" } ] } group:clarityMonorepo Group packages from clarity monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:clarity\", \"groupName\": \"clarity monorepo\" } ] } group:commitlintMonorepo Group packages from commitlint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:commitlint\", \"groupName\": \"commitlint monorepo\" } ] } group:docusaurusMonorepo Group packages from docusaurus monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:docusaurus\", \"groupName\": \"docusaurus monorepo\" } ] } group:dotnetMonorepo Group packages from dotnet monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:dotnet\", \"groupName\": \"dotnet monorepo\" } ] } group:dropwizardMonorepo Group packages from dropwizard monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:dropwizard\", \"groupName\": \"dropwizard monorepo\" } ] } group:emotionMonorepo Group packages from emotion monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:emotion\", \"groupName\": \"emotion monorepo\" } ] } group:expoMonorepo Group packages from expo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:expo\", \"groupName\": \"expo monorepo\" } ] } group:feathersMonorepo Group packages from feathers monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:feathers\", \"groupName\": \"feathers monorepo\" } ] } group:fimbullinterMonorepo Group packages from fimbullinter monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:fimbullinter\", \"groupName\": \"fimbullinter monorepo\" } ] } group:flopflipMonorepo Group packages from flopflip monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:flopflip\", \"groupName\": \"flopflip monorepo\" } ] } group:formatjsMonorepo Group packages from formatjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:formatjs\", \"groupName\": \"formatjs monorepo\" } ] } group:framework7Monorepo Group packages from framework7 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:framework7\", \"groupName\": \"framework7 monorepo\" } ] } group:gatsbyMonorepo Group packages from gatsby monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:gatsby\", \"groupName\": \"gatsby monorepo\" } ] } group:graphqlcodegeneratorMonorepo Group packages from graphqlcodegenerator monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphqlcodegenerator\", \"groupName\": \"graphqlcodegenerator monorepo\" } ] } group:graphql-meshMonorepo Group packages from graphql-mesh monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-mesh\", \"groupName\": \"graphql-mesh monorepo\" } ] } group:graphql-toolkitMonorepo Group packages from graphql-toolkit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-toolkit\", \"groupName\": \"graphql-toolkit monorepo\" } ] } group:graphql-toolsMonorepo Group packages from graphql-tools monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-tools\", \"groupName\": \"graphql-tools monorepo\" } ] } group:hamcrestMonorepo Group packages from hamcrest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:hamcrest\", \"groupName\": \"hamcrest monorepo\" } ] } group:HangfireMonorepo Group packages from Hangfire monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Hangfire\", \"groupName\": \"Hangfire monorepo\" } ] } group:hapijsMonorepo Group packages from hapijs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:hapijs\", \"groupName\": \"hapijs monorepo\" } ] } group:infrastructureMonorepo Group packages from infrastructure monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:infrastructure\", \"groupName\": \"infrastructure monorepo\" } ] } group:istanbuljsMonorepo Group packages from istanbuljs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:istanbuljs\", \"groupName\": \"istanbuljs monorepo\" } ] } group:jasmineMonorepo Group packages from jasmine monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jasmine\", \"groupName\": \"jasmine monorepo\" } ] } group:jerseyMonorepo Group packages from jersey monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jersey\", \"groupName\": \"jersey monorepo\" } ] } group:jestMonorepo Group packages from jest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jest\", \"groupName\": \"jest monorepo\" } ] } group:junit5Monorepo Group packages from junit5 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:junit5\", \"groupName\": \"junit5 monorepo\" } ] } group:lernaMonorepo Group packages from lerna monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lerna\", \"groupName\": \"lerna monorepo\" } ] } group:linguiMonorepo Group packages from lingui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lingui\", \"groupName\": \"lingui monorepo\" } ] } group:lodashMonorepo Group packages from lodash monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lodash\", \"groupName\": \"lodash monorepo\" } ] } group:loopbackMonorepo Group packages from loopback monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:loopback\", \"groupName\": \"loopback monorepo\" } ] } group:lrnwebcomponentsMonorepo Group packages from lrnwebcomponents monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lrnwebcomponents\", \"groupName\": \"lrnwebcomponents monorepo\" } ] } group:MassTransitMonorepo Group packages from MassTransit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:MassTransit\", \"groupName\": \"MassTransit monorepo\" } ] } group:materialMonorepo Group packages from material monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:material\", \"groupName\": \"material monorepo\" } ] } group:mdxMonorepo Group packages from mdx monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mdx\", \"groupName\": \"mdx monorepo\" } ] } group:muiMonorepo Group packages from mui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mui\", \"groupName\": \"mui monorepo\" } ] } group:nestMonorepo Group packages from nest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nest\", \"groupName\": \"nest monorepo\" } ] } group:neutrinoMonorepo Group packages from neutrino monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:neutrino\", \"groupName\": \"neutrino monorepo\" } ] } group:nextjsMonorepo Group packages from nextjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nextjs\", \"groupName\": \"nextjs monorepo\" } ] } group:nivoMonorepo Group packages from nivo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nivo\", \"groupName\": \"nivo monorepo\" } ] } group:ngrxMonorepo Group packages from ngrx monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngrx\", \"groupName\": \"ngrx monorepo\" } ] } group:nrwlMonorepo Group packages from nrwl monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nrwl\", \"groupName\": \"nrwl monorepo\" } ] } group:nuxtjsMonorepo Group packages from nuxtjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nuxtjs\", \"groupName\": \"nuxtjs monorepo\" } ] } group:openfeignMonorepo Group packages from openfeign monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:openfeign\", \"groupName\": \"openfeign monorepo\" } ] } group:opentelemetryMonorepo Group packages from opentelemetry monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:opentelemetry\", \"groupName\": \"opentelemetry monorepo\" } ] } group:picassoMonorepo Group packages from picasso monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:picasso\", \"groupName\": \"picasso monorepo\" } ] } group:pnpjsMonorepo Group packages from pnpjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pnpjs\", \"groupName\": \"pnpjs monorepo\" } ] } group:playwrightMonorepo Group packages from playwright monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:playwright\", \"groupName\": \"playwright monorepo\" } ] } group:pollyjsMonorepo Group packages from pollyjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pollyjs\", \"groupName\": \"pollyjs monorepo\" } ] } group:pouchdbMonorepo Group packages from pouchdb monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pouchdb\", \"groupName\": \"pouchdb monorepo\" } ] } group:prismaMonorepo Group packages from prisma monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:prisma\", \"groupName\": \"prisma monorepo\" } ] } group:reactMonorepo Group packages from react monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react\", \"groupName\": \"react monorepo\" } ] } group:reactrouterMonorepo Group packages from reactrouter monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reactrouter\", \"groupName\": \"reactrouter monorepo\" } ] } group:reakitMonorepo Group packages from reakit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reakit\", \"groupName\": \"reakit monorepo\" } ] } group:redwoodMonorepo Group packages from redwood monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:redwood\", \"groupName\": \"redwood monorepo\" } ] } group:remarkMonorepo Group packages from remark monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:remark\", \"groupName\": \"remark monorepo\" } ] } group:router5Monorepo Group packages from router5 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:router5\", \"groupName\": \"router5 monorepo\" } ] } group:sentryMonorepo Group packages from sentry monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:sentry\", \"groupName\": \"sentry monorepo\" } ] } group:springfoxMonorepo Group packages from springfox monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:springfox\", \"groupName\": \"springfox monorepo\" } ] } group:sanityMonorepo Group packages from sanity monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:sanity\", \"groupName\": \"sanity monorepo\" } ] } group:SteeltoeMonorepo Group packages from Steeltoe monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Steeltoe\", \"groupName\": \"Steeltoe monorepo\" } ] } group:storybookMonorepo Group packages from storybook monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:storybook\", \"groupName\": \"storybook monorepo\" } ] } group:strapiMonorepo Group packages from strapi monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:strapi\", \"groupName\": \"strapi monorepo\" } ] } group:strykerMonorepo Group packages from stryker monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:stryker\", \"groupName\": \"stryker monorepo\" } ] } group:surveyjsMonorepo Group packages from surveyjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:surveyjs\", \"groupName\": \"surveyjs monorepo\" } ] } group:SwashbuckleMonorepo Group packages from Swashbuckle monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Swashbuckle\", \"groupName\": \"Swashbuckle monorepo\" } ] } group:treatMonorepo Group packages from treat monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:treat\", \"groupName\": \"treat monorepo\" } ] } group:typefacesMonorepo Group packages from typefaces monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typefaces\", \"groupName\": \"typefaces monorepo\" } ] } group:uppyMonorepo Group packages from uppy monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:uppy\", \"groupName\": \"uppy monorepo\" } ] } group:vueMonorepo Group packages from vue monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vue\", \"groupName\": \"vue monorepo\" } ] } group:vuepressMonorepo Group packages from vuepress monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vuepress\", \"groupName\": \"vuepress monorepo\" } ] } group:webdriverioMonorepo Group packages from webdriverio monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:webdriverio\", \"groupName\": \"webdriverio monorepo\" } ] } group:workboxMonorepo Group packages from workbox monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:workbox\", \"groupName\": \"workbox monorepo\" } ] } group:babel6Monorepo Group packages from babel6 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:babel6\", \"groupName\": \"babel6 monorepo\" } ] } group:wordpressMonorepo Group packages from wordpress monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:wordpress\", \"groupName\": \"wordpress monorepo\" } ] } group:angularmaterialMonorepo Group packages from angularmaterial monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularmaterial\", \"groupName\": \"angularmaterial monorepo\" } ] } group:aws-java-sdkMonorepo Group packages from aws-java-sdk monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-java-sdk\", \"groupName\": \"aws-java-sdk monorepo\" } ] } group:embroiderMonorepo Group packages from embroider monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:embroider\", \"groupName\": \"embroider monorepo\" } ] } group:fullcalendarMonorepo Group packages from fullcalendar monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:fullcalendar\", \"groupName\": \"fullcalendar monorepo\" } ] } group:monorepos Group known monorepo packages together { \"ignoreDeps\": [], \"extends\": [ \"group:ag-gridMonorepo\", \"group:arcus event-gridMonorepo\", \"group:arcus securityMonorepo\", \"group:arcus messagingMonorepo\", \"group:arcus observabilityMonorepo\", \"group:arcus webapiMonorepo\", \"group:arcus background-jobsMonorepo\", \"group:algolia-react-instantsearchMonorepo\", \"group:angular-eslintMonorepo\", \"group:apollo-serverMonorepo\", \"group:aspnet-api-versioningMonorepo\", \"group:aspnet AspNetWebStackMonorepo\", \"group:aspnet ExtensionsMonorepo\", \"group:aws-cdkMonorepo\", \"group:aws-sdk-js-v3Monorepo\", \"group:azure azure-libraries-for-netMonorepo\", \"group:azure azure-sdk-for-netMonorepo\", \"group:azure azure-storage-netMonorepo\", \"group:bugsnag-jsMonorepo\", \"group:date-ioMonorepo\", \"group:devextreme-reactiveMonorepo\", \"group:electron-forgeMonorepo\", \"group:feathers-databasesMonorepo\", \"group:ember-decoratorsMonorepo\", \"group:graphql-modulesMonorepo\", \"group:ionic-nativeMonorepo\", \"group:mdc-reactMonorepo\", \"group:ngx-formlyMonorepo\", \"group:ngxs-storeMonorepo\", \"group:reach-uiMonorepo\", \"group:react-apolloMonorepo\", \"group:react-dndMonorepo\", \"group:react-navigationMonorepo\", \"group:reactivestack-cookiesMonorepo\", \"group:reg-suitMonorepo\", \"group:semantic-releaseMonorepo\", \"group:telus-tdsMonorepo\", \"group:typescript-eslintMonorepo\", \"group:typography-jsMonorepo\", \"group:vue-cliMonorepo\", \"group:accountsMonorepo\", \"group:angular1Monorepo\", \"group:angularMonorepo\", \"group:angularcliMonorepo\", \"group:angularfireMonorepo\", \"group:apolloclientMonorepo\", \"group:apollolinkMonorepo\", \"group:awsappsyncMonorepo\", \"group:babelMonorepo\", \"group:basetMonorepo\", \"group:braveMonorepo\", \"group:capacitorMonorepo\", \"group:chromelyMonorepo\", \"group:clarityMonorepo\", \"group:commitlintMonorepo\", \"group:docusaurusMonorepo\", \"group:dotnetMonorepo\", \"group:dropwizardMonorepo\", \"group:emotionMonorepo\", \"group:expoMonorepo\", \"group:feathersMonorepo\", \"group:fimbullinterMonorepo\", \"group:flopflipMonorepo\", \"group:formatjsMonorepo\", \"group:framework7Monorepo\", \"group:gatsbyMonorepo\", \"group:graphqlcodegeneratorMonorepo\", \"group:graphql-meshMonorepo\", \"group:graphql-toolkitMonorepo\", \"group:graphql-toolsMonorepo\", \"group:hamcrestMonorepo\", \"group:HangfireMonorepo\", \"group:hapijsMonorepo\", \"group:infrastructureMonorepo\", \"group:istanbuljsMonorepo\", \"group:jasmineMonorepo\", \"group:jerseyMonorepo\", \"group:jestMonorepo\", \"group:junit5Monorepo\", \"group:lernaMonorepo\", \"group:linguiMonorepo\", \"group:lodashMonorepo\", \"group:loopbackMonorepo\", \"group:lrnwebcomponentsMonorepo\", \"group:MassTransitMonorepo\", \"group:materialMonorepo\", \"group:mdxMonorepo\", \"group:muiMonorepo\", \"group:nestMonorepo\", \"group:neutrinoMonorepo\", \"group:nextjsMonorepo\", \"group:nivoMonorepo\", \"group:ngrxMonorepo\", \"group:nrwlMonorepo\", \"group:nuxtjsMonorepo\", \"group:openfeignMonorepo\", \"group:opentelemetryMonorepo\", \"group:picassoMonorepo\", \"group:pnpjsMonorepo\", \"group:playwrightMonorepo\", \"group:pollyjsMonorepo\", \"group:pouchdbMonorepo\", \"group:prismaMonorepo\", \"group:reactMonorepo\", \"group:reactrouterMonorepo\", \"group:reakitMonorepo\", \"group:redwoodMonorepo\", \"group:remarkMonorepo\", \"group:router5Monorepo\", \"group:sentryMonorepo\", \"group:springfoxMonorepo\", \"group:sanityMonorepo\", \"group:SteeltoeMonorepo\", \"group:storybookMonorepo\", \"group:strapiMonorepo\", \"group:strykerMonorepo\", \"group:surveyjsMonorepo\", \"group:SwashbuckleMonorepo\", \"group:treatMonorepo\", \"group:typefacesMonorepo\", \"group:uppyMonorepo\", \"group:vueMonorepo\", \"group:vuepressMonorepo\", \"group:webdriverioMonorepo\", \"group:workboxMonorepo\", \"group:babel6Monorepo\", \"group:wordpressMonorepo\", \"group:angularmaterialMonorepo\", \"group:aws-java-sdkMonorepo\", \"group:embroiderMonorepo\", \"group:fullcalendarMonorepo\" ] }","title":"Group Presets"},{"location":"presets-group/#groupall","text":"Group all updates together { \"groupName\": \"all dependencies\", \"separateMajorMinor\": false, \"groupSlug\": \"all\", \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"groupName\": \"all dependencies\", \"groupSlug\": \"all\" } ], \"lockFileMaintenance\": { \"enabled\": false } }","title":"group:all"},{"location":"presets-group/#groupallnonmajor","text":"Group all minor and patch updates together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"*\" ], \"matchUpdateTypes\": [ \"minor\", \"patch\" ], \"groupName\": \"all non-major dependencies\", \"groupSlug\": \"all-minor-patch\" } ] }","title":"group:allNonMajor"},{"location":"presets-group/#grouprecommended","text":"Use curated list of recommended non-monorepo package groupings { \"extends\": [ \"group:allApollographql\", \"group:fortawesome\", \"group:fusionjs\", \"group:glimmer\", \"group:goOpenapi\", \"group:hibernateCore\", \"group:hibernateValidator\", \"group:hibernateOgm\", \"group:hibernateCommons\", \"group:illuminate\", \"group:jekyllEcosystem\", \"group:polymer\", \"group:resilience4j\", \"group:rubyOmniauth\", \"group:socketio\", \"group:springAmqp\", \"group:springAndroid\", \"group:springBatch\", \"group:springBoot\", \"group:springCloud\", \"group:springCore\", \"group:springData\", \"group:springHateoas\", \"group:springIntegration\", \"group:springKafka\", \"group:springLdap\", \"group:springMobile\", \"group:springOsgi\", \"group:springRestDocs\", \"group:springRoo\", \"group:springScala\", \"group:springSecurity\", \"group:springSession\", \"group:springShell\", \"group:springSocial\", \"group:springStatemachine\", \"group:springWebflow\", \"group:springWs\", \"group:symfony\" ], \"ignoreDeps\": [] }","title":"group:recommended"},{"location":"presets-group/#groupallapollographql","text":"Group all packages published by Apollo GraphQL together { \"packageRules\": [ { \"extends\": \"packages:apollographql\", \"groupName\": \"Apollo GraphQL packages\" } ] }","title":"group:allApollographql"},{"location":"presets-group/#groupdefinitelytyped","text":"Group all @types packages together { \"packageRules\": [ { \"groupName\": \"definitelyTyped\", \"matchPackagePatterns\": [ \"^@types/\" ] } ] }","title":"group:definitelyTyped"},{"location":"presets-group/#groupdotnetcore","text":".NET Core Docker containers { \"packageRules\": [ { \"matchDatasources\": [ \"docker\" ], \"matchPackagePatterns\": [ \"^mcr.microsoft.com/dotnet/core/\" ], \"groupName\": \".NET Core Docker containers\" } ] }","title":"group:dotNetCore"},{"location":"presets-group/#groupfortawesome","text":"Group all packages by Font Awesome together { \"packageRules\": [ { \"groupName\": \"Font Awesome\", \"matchPackagePatterns\": [ \"^@fortawesome/\" ] } ] }","title":"group:fortawesome"},{"location":"presets-group/#groupfusionjs","text":"Fusion.js packages { \"matchPackageNames\": [ \"fusion-cli\", \"fusion-core\", \"fusion-test-utils\", \"fusion-tokens\" ], \"matchPackagePatterns\": [ \"^fusion-plugin-*\", \"^fusion-react*\", \"^fusion-apollo*\" ] }","title":"group:fusionjs"},{"location":"presets-group/#groupglimmer","text":"Group Glimmer.js packages together { \"packageRules\": [ { \"groupName\": \"Glimmer.js packages\", \"groupSlug\": \"glimmer\", \"matchPackageNames\": [ \"@glimmer/component\", \"@glimmer/tracking\" ] } ] }","title":"group:glimmer"},{"location":"presets-group/#groupilluminate","text":"Group PHP illuminate packages together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^illuminate/\" ], \"groupName\": \"illuminate packages\", \"groupSlug\": \"illuminate\" } ] }","title":"group:illuminate"},{"location":"presets-group/#groupsymfony","text":"Group PHP symfony packages together { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^symfony/\" ], \"groupName\": \"symfony packages\", \"groupSlug\": \"symfony\" } ] }","title":"group:symfony"},{"location":"presets-group/#grouppolymer","text":"Group all @polymer packages together { \"packageRules\": [ { \"groupName\": \"polymer packages\", \"matchPackagePatterns\": [ \"^@polymer/\" ] } ] }","title":"group:polymer"},{"location":"presets-group/#grouphibernatecore","text":"Group Java Hibernate Core packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate:\" ], \"groupName\": \"hibernate core\" } ] }","title":"group:hibernateCore"},{"location":"presets-group/#grouphibernatevalidator","text":"Group Java Hibernate Validator packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.validator:\" ], \"groupName\": \"hibernate validator\" } ] }","title":"group:hibernateValidator"},{"location":"presets-group/#grouphibernateogm","text":"Group Java Hibernate OGM packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.ogm:\" ], \"groupName\": \"hibernate ogm\" } ] }","title":"group:hibernateOgm"},{"location":"presets-group/#grouphibernatecommons","text":"Group Java Hibernate Commons packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^org.hibernate.common:\" ], \"groupName\": \"hibernate commons\" } ] }","title":"group:hibernateCommons"},{"location":"presets-group/#groupresilience4j","text":"Group Java Resilience4j packages { \"packageRules\": [ { \"matchPackagePatterns\": [ \"^io.github.resilience4j:\" ], \"groupName\": \"resilience4j\" } ] }","title":"group:resilience4j"},{"location":"presets-group/#groupspringamqp","text":"Group Java Spring AMQP packages { \"packageRules\": [ { \"groupName\": \"spring amqp\", \"matchPackagePatterns\": [ \"^org.springframework.amqp:\" ] } ] }","title":"group:springAmqp"},{"location":"presets-group/#groupspringandroid","text":"Group Java Spring Android packages { \"packageRules\": [ { \"groupName\": \"spring android\", \"matchPackagePatterns\": [ \"^org.springframework.android:\" ] } ] }","title":"group:springAndroid"},{"location":"presets-group/#groupspringbatch","text":"Group Java Spring Batch packages { \"packageRules\": [ { \"groupName\": \"spring batch\", \"matchPackagePatterns\": [ \"^org.springframework.batch:\" ] } ] }","title":"group:springBatch"},{"location":"presets-group/#groupspringboot","text":"Group Java Spring Boot packages { \"packageRules\": [ { \"groupName\": \"spring boot\", \"matchPackagePatterns\": [ \"^org.springframework.boot:\" ] } ] }","title":"group:springBoot"},{"location":"presets-group/#groupspringcloud","text":"Group Java Spring Cloud packages { \"packageRules\": [ { \"groupName\": \"spring cloud\", \"matchPackagePatterns\": [ \"^org.springframework.cloud:\" ] } ] }","title":"group:springCloud"},{"location":"presets-group/#groupspringcore","text":"Group Java Spring Core packages { \"packageRules\": [ { \"groupName\": \"spring core\", \"matchPackagePatterns\": [ \"^org.springframework:\" ] } ] }","title":"group:springCore"},{"location":"presets-group/#groupspringdata","text":"Group Java Spring Data packages { \"packageRules\": [ { \"groupName\": \"spring data\", \"matchPackagePatterns\": [ \"^org.springframework.data:\" ] } ] }","title":"group:springData"},{"location":"presets-group/#groupspringhateoas","text":"Group Java Spring HATEOAS packages { \"packageRules\": [ { \"groupName\": \"spring hateoas\", \"matchPackagePatterns\": [ \"^org.springframework.hateoas:\" ] } ] }","title":"group:springHateoas"},{"location":"presets-group/#groupspringintegration","text":"Group Java Spring Integration packages { \"packageRules\": [ { \"groupName\": \"spring integration\", \"matchPackagePatterns\": [ \"^org.springframework.integration:\" ] } ] }","title":"group:springIntegration"},{"location":"presets-group/#groupspringkafka","text":"Group Java Spring Kafka packages { \"packageRules\": [ { \"groupName\": \"spring kafka\", \"matchPackagePatterns\": [ \"^org.springframework.kafka:\" ] } ] }","title":"group:springKafka"},{"location":"presets-group/#groupspringldap","text":"Group Java Spring LDAP packages { \"packageRules\": [ { \"groupName\": \"spring ldap\", \"matchPackagePatterns\": [ \"^org.springframework.ldap:\" ] } ] }","title":"group:springLdap"},{"location":"presets-group/#groupspringmobile","text":"Group Java Spring Mobile packages { \"packageRules\": [ { \"groupName\": \"spring mobile\", \"matchPackagePatterns\": [ \"^org.springframework.mobile:\" ] } ] }","title":"group:springMobile"},{"location":"presets-group/#groupspringosgi","text":"Group Java Spring OSGi packages { \"packageRules\": [ { \"groupName\": \"spring osgi\", \"matchPackagePatterns\": [ \"^org.springframework.osgi:\" ] } ] }","title":"group:springOsgi"},{"location":"presets-group/#groupspringrestdocs","text":"Group Java Spring REST Docs packages { \"packageRules\": [ { \"groupName\": \"spring restdocs\", \"matchPackagePatterns\": [ \"^org.springframework.restdocs:\" ] } ] }","title":"group:springRestDocs"},{"location":"presets-group/#groupspringroo","text":"Group Java Spring Roo packages { \"packageRules\": [ { \"groupName\": \"spring roo\", \"matchPackagePatterns\": [ \"^org.springframework.roo:\" ] } ] }","title":"group:springRoo"},{"location":"presets-group/#groupspringscala","text":"Group Java Spring Scala packages { \"packageRules\": [ { \"groupName\": \"spring scala\", \"matchPackagePatterns\": [ \"^org.springframework.scala:\" ] } ] }","title":"group:springScala"},{"location":"presets-group/#groupspringsecurity","text":"Group Java Spring Security packages { \"packageRules\": [ { \"groupName\": \"spring security\", \"matchPackagePatterns\": [ \"^org.springframework.security:\" ] } ] }","title":"group:springSecurity"},{"location":"presets-group/#groupspringsession","text":"Group Java Spring Session packages { \"packageRules\": [ { \"groupName\": \"spring session\", \"matchPackagePatterns\": [ \"^org.springframework.session:\" ] } ] }","title":"group:springSession"},{"location":"presets-group/#groupspringshell","text":"Group Java Spring Shell packages { \"packageRules\": [ { \"groupName\": \"spring shell\", \"matchPackagePatterns\": [ \"^org.springframework.shell:\" ] } ] }","title":"group:springShell"},{"location":"presets-group/#groupspringsocial","text":"Group Java Spring Social packages { \"packageRules\": [ { \"groupName\": \"spring social\", \"matchPackagePatterns\": [ \"^org.springframework.social:\" ] } ] }","title":"group:springSocial"},{"location":"presets-group/#groupspringstatemachine","text":"Group Java Spring Statemachine packages { \"packageRules\": [ { \"groupName\": \"spring statemachine\", \"matchPackagePatterns\": [ \"^org.springframework.statemachine:\" ] } ] }","title":"group:springStatemachine"},{"location":"presets-group/#groupspringwebflow","text":"Group Java Spring WebFlow packages { \"packageRules\": [ { \"groupName\": \"spring webflow\", \"matchPackagePatterns\": [ \"^org.springframework.webflow:\" ] } ] }","title":"group:springWebflow"},{"location":"presets-group/#groupspringws","text":"Group Java Spring WS packages { \"packageRules\": [ { \"groupName\": \"spring ws\", \"matchPackagePatterns\": [ \"^org.springframework.ws:\" ] } ] }","title":"group:springWs"},{"location":"presets-group/#groupsocketio","text":"Group socket.io packages { \"packageRules\": [ { \"groupName\": \"socket.io packages\", \"matchPackagePatterns\": [ \"^socket.io\" ] } ] }","title":"group:socketio"},{"location":"presets-group/#grouppostcss","text":"Group postcss packages together { \"packageRules\": [ { \"extends\": \"packages:postcss\", \"groupName\": \"postcss packages\" } ] }","title":"group:postcss"},{"location":"presets-group/#groupjekyllecosystem","text":"Group jekyll and related ruby packages together { \"packageRules\": [ { \"matchSourceUrlPrefixes\": [ \"https://github.com/jekyll/\", \"https://github.com/github/pages-gem\" ], \"groupName\": \"jekyll ecosystem packages\" } ] }","title":"group:jekyllEcosystem"},{"location":"presets-group/#grouprubyomniauth","text":"Group omniauth packages together { \"packageRules\": [ { \"matchDatasources\": [ \"rubygems\" ], \"matchPackagePatterns\": [ \"^omniauth\" ], \"groupName\": \"omniauth packages\" } ] }","title":"group:rubyOmniauth"},{"location":"presets-group/#groupgoopenapi","text":"Group go-openapi packages together { \"packageRules\": [ { \"matchDatasources\": [ \"go\" ], \"groupName\": \"go-openapi packages\", \"groupSlug\": \"go-openapi\", \"matchPackagePatterns\": [ \"^github.com/go-openapi/\" ] } ] }","title":"group:goOpenapi"},{"location":"presets-group/#groupgoogleapis","text":"Group googleapis packages together { \"packageRules\": [ { \"extends\": \"packages:googleapis\", \"groupName\": \"googleapis packages\" } ] }","title":"group:googleapis"},{"location":"presets-group/#grouplinters","text":"Group various lint packages together { \"packageRules\": [ { \"extends\": \"packages:linters\", \"groupName\": \"linters\" } ] }","title":"group:linters"},{"location":"presets-group/#groupjsunittest","text":"Group JS unit test packages together { \"packageRules\": [ { \"extends\": \"packages:jsUnitTest\", \"groupName\": \"JS unit test packages\" } ] }","title":"group:jsUnitTest"},{"location":"presets-group/#groupjsunittestnonmajor","text":"Group JS unit test packages together { \"packageRules\": [ { \"extends\": \"packages:jsUnitTest\", \"minor\": { \"groupName\": \"JS unit test packages\" } } ] }","title":"group:jsUnitTestNonMajor"},{"location":"presets-group/#groupunittest","text":"Group all unit test packages together { \"packageRules\": [ { \"extends\": \"packages:unitTest\", \"groupName\": \"unit test packages\" } ] }","title":"group:unitTest"},{"location":"presets-group/#groupunittestnonmajor","text":"Group all unit test packages together { \"packageRules\": [ { \"extends\": \"packages:unitTest\", \"minor\": { \"groupName\": \"unit test packages\" } } ] }","title":"group:unitTestNonMajor"},{"location":"presets-group/#groupjstest","text":"Group JS test packages together { \"packageRules\": [ { \"extends\": \"packages:jsTest\", \"groupName\": \"JS test packages\" } ] }","title":"group:jsTest"},{"location":"presets-group/#groupjstestmonmajor","text":"Group non-major JS test package updates together { \"packageRules\": [ { \"extends\": \"packages:jsTest\", \"minor\": { \"groupName\": \"JS test packages\" } } ] }","title":"group:jsTestMonMajor"},{"location":"presets-group/#grouptest","text":"Group all test packages together { \"packageRules\": [ { \"extends\": \"packages:test\", \"groupName\": \"test packages\" } ] }","title":"group:test"},{"location":"presets-group/#grouptestnonmajor","text":"Group all non-major test package updates together { \"packageRules\": [ { \"extends\": \"packages:test\", \"minor\": { \"groupName\": \"test packages\" } } ] }","title":"group:testNonMajor"},{"location":"presets-group/#groupag-gridmonorepo","text":"Group packages from ag-grid monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ag-grid\", \"groupName\": \"ag-grid monorepo\" } ] }","title":"group:ag-gridMonorepo"},{"location":"presets-group/#grouparcus-event-gridmonorepo","text":"Group packages from arcus event-grid monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus event-grid\", \"groupName\": \"arcus event-grid monorepo\" } ] }","title":"group:arcus event-gridMonorepo"},{"location":"presets-group/#grouparcus-securitymonorepo","text":"Group packages from arcus security monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus security\", \"groupName\": \"arcus security monorepo\" } ] }","title":"group:arcus securityMonorepo"},{"location":"presets-group/#grouparcus-messagingmonorepo","text":"Group packages from arcus messaging monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus messaging\", \"groupName\": \"arcus messaging monorepo\" } ] }","title":"group:arcus messagingMonorepo"},{"location":"presets-group/#grouparcus-observabilitymonorepo","text":"Group packages from arcus observability monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus observability\", \"groupName\": \"arcus observability monorepo\" } ] }","title":"group:arcus observabilityMonorepo"},{"location":"presets-group/#grouparcus-webapimonorepo","text":"Group packages from arcus webapi monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus webapi\", \"groupName\": \"arcus webapi monorepo\" } ] }","title":"group:arcus webapiMonorepo"},{"location":"presets-group/#grouparcus-background-jobsmonorepo","text":"Group packages from arcus background-jobs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:arcus background-jobs\", \"groupName\": \"arcus background-jobs monorepo\" } ] }","title":"group:arcus background-jobsMonorepo"},{"location":"presets-group/#groupalgolia-react-instantsearchmonorepo","text":"Group packages from algolia-react-instantsearch monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:algolia-react-instantsearch\", \"groupName\": \"algolia-react-instantsearch monorepo\" } ] }","title":"group:algolia-react-instantsearchMonorepo"},{"location":"presets-group/#groupangular-eslintmonorepo","text":"Group packages from angular-eslint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular-eslint\", \"groupName\": \"angular-eslint monorepo\" } ] }","title":"group:angular-eslintMonorepo"},{"location":"presets-group/#groupapollo-servermonorepo","text":"Group packages from apollo-server monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apollo-server\", \"groupName\": \"apollo-server monorepo\" } ] }","title":"group:apollo-serverMonorepo"},{"location":"presets-group/#groupaspnet-api-versioningmonorepo","text":"Group packages from aspnet-api-versioning monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet-api-versioning\", \"groupName\": \"aspnet-api-versioning monorepo\" } ] }","title":"group:aspnet-api-versioningMonorepo"},{"location":"presets-group/#groupaspnet-aspnetwebstackmonorepo","text":"Group packages from aspnet AspNetWebStack monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet AspNetWebStack\", \"groupName\": \"aspnet AspNetWebStack monorepo\" } ] }","title":"group:aspnet AspNetWebStackMonorepo"},{"location":"presets-group/#groupaspnet-extensionsmonorepo","text":"Group packages from aspnet Extensions monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aspnet Extensions\", \"groupName\": \"aspnet Extensions monorepo\" } ] }","title":"group:aspnet ExtensionsMonorepo"},{"location":"presets-group/#groupaws-cdkmonorepo","text":"Group packages from aws-cdk monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-cdk\", \"groupName\": \"aws-cdk monorepo\" } ] }","title":"group:aws-cdkMonorepo"},{"location":"presets-group/#groupaws-sdk-js-v3monorepo","text":"Group packages from aws-sdk-js-v3 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-sdk-js-v3\", \"groupName\": \"aws-sdk-js-v3 monorepo\" } ] }","title":"group:aws-sdk-js-v3Monorepo"},{"location":"presets-group/#groupazure-azure-libraries-for-netmonorepo","text":"Group packages from azure azure-libraries-for-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-libraries-for-net\", \"groupName\": \"azure azure-libraries-for-net monorepo\" } ] }","title":"group:azure azure-libraries-for-netMonorepo"},{"location":"presets-group/#groupazure-azure-sdk-for-netmonorepo","text":"Group packages from azure azure-sdk-for-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-sdk-for-net\", \"groupName\": \"azure azure-sdk-for-net monorepo\" } ] }","title":"group:azure azure-sdk-for-netMonorepo"},{"location":"presets-group/#groupazure-azure-storage-netmonorepo","text":"Group packages from azure azure-storage-net monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:azure azure-storage-net\", \"groupName\": \"azure azure-storage-net monorepo\" } ] }","title":"group:azure azure-storage-netMonorepo"},{"location":"presets-group/#groupbugsnag-jsmonorepo","text":"Group packages from bugsnag-js monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:bugsnag-js\", \"groupName\": \"bugsnag-js monorepo\" } ] }","title":"group:bugsnag-jsMonorepo"},{"location":"presets-group/#groupdate-iomonorepo","text":"Group packages from date-io monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:date-io\", \"groupName\": \"date-io monorepo\" } ] }","title":"group:date-ioMonorepo"},{"location":"presets-group/#groupdevextreme-reactivemonorepo","text":"Group packages from devextreme-reactive monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:devextreme-reactive\", \"groupName\": \"devextreme-reactive monorepo\" } ] }","title":"group:devextreme-reactiveMonorepo"},{"location":"presets-group/#groupelectron-forgemonorepo","text":"Group packages from electron-forge monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:electron-forge\", \"groupName\": \"electron-forge monorepo\" } ] }","title":"group:electron-forgeMonorepo"},{"location":"presets-group/#groupfeathers-databasesmonorepo","text":"Group packages from feathers-databases monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:feathers-databases\", \"groupName\": \"feathers-databases monorepo\" } ] }","title":"group:feathers-databasesMonorepo"},{"location":"presets-group/#groupember-decoratorsmonorepo","text":"Group packages from ember-decorators monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ember-decorators\", \"groupName\": \"ember-decorators monorepo\" } ] }","title":"group:ember-decoratorsMonorepo"},{"location":"presets-group/#groupgraphql-modulesmonorepo","text":"Group packages from graphql-modules monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-modules\", \"groupName\": \"graphql-modules monorepo\" } ] }","title":"group:graphql-modulesMonorepo"},{"location":"presets-group/#groupionic-nativemonorepo","text":"Group packages from ionic-native monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ionic-native\", \"groupName\": \"ionic-native monorepo\" } ] }","title":"group:ionic-nativeMonorepo"},{"location":"presets-group/#groupmdc-reactmonorepo","text":"Group packages from mdc-react monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mdc-react\", \"groupName\": \"mdc-react monorepo\" } ] }","title":"group:mdc-reactMonorepo"},{"location":"presets-group/#groupngx-formlymonorepo","text":"Group packages from ngx-formly monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngx-formly\", \"groupName\": \"ngx-formly monorepo\" } ] }","title":"group:ngx-formlyMonorepo"},{"location":"presets-group/#groupngxs-storemonorepo","text":"Group packages from ngxs-store monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngxs-store\", \"groupName\": \"ngxs-store monorepo\" } ] }","title":"group:ngxs-storeMonorepo"},{"location":"presets-group/#groupreach-uimonorepo","text":"Group packages from reach-ui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reach-ui\", \"groupName\": \"reach-ui monorepo\" } ] }","title":"group:reach-uiMonorepo"},{"location":"presets-group/#groupreact-apollomonorepo","text":"Group packages from react-apollo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-apollo\", \"groupName\": \"react-apollo monorepo\" } ] }","title":"group:react-apolloMonorepo"},{"location":"presets-group/#groupreact-dndmonorepo","text":"Group packages from react-dnd monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-dnd\", \"groupName\": \"react-dnd monorepo\" } ] }","title":"group:react-dndMonorepo"},{"location":"presets-group/#groupreact-navigationmonorepo","text":"Group packages from react-navigation monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react-navigation\", \"groupName\": \"react-navigation monorepo\" } ] }","title":"group:react-navigationMonorepo"},{"location":"presets-group/#groupreactivestack-cookiesmonorepo","text":"Group packages from reactivestack-cookies monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reactivestack-cookies\", \"groupName\": \"reactivestack-cookies monorepo\" } ] }","title":"group:reactivestack-cookiesMonorepo"},{"location":"presets-group/#groupreg-suitmonorepo","text":"Group packages from reg-suit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reg-suit\", \"groupName\": \"reg-suit monorepo\" } ] }","title":"group:reg-suitMonorepo"},{"location":"presets-group/#groupsemantic-releasemonorepo","text":"Group packages from semantic-release monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:semantic-release\", \"groupName\": \"semantic-release monorepo\" } ] }","title":"group:semantic-releaseMonorepo"},{"location":"presets-group/#grouptelus-tdsmonorepo","text":"Group packages from telus-tds monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:telus-tds\", \"groupName\": \"telus-tds monorepo\" } ] }","title":"group:telus-tdsMonorepo"},{"location":"presets-group/#grouptypescript-eslintmonorepo","text":"Group packages from typescript-eslint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typescript-eslint\", \"groupName\": \"typescript-eslint monorepo\" } ] }","title":"group:typescript-eslintMonorepo"},{"location":"presets-group/#grouptypography-jsmonorepo","text":"Group packages from typography-js monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typography-js\", \"groupName\": \"typography-js monorepo\" } ] }","title":"group:typography-jsMonorepo"},{"location":"presets-group/#groupvue-climonorepo","text":"Group packages from vue-cli monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vue-cli\", \"groupName\": \"vue-cli monorepo\" } ] }","title":"group:vue-cliMonorepo"},{"location":"presets-group/#groupaccountsmonorepo","text":"Group packages from accounts monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:accounts\", \"groupName\": \"accounts monorepo\" } ] }","title":"group:accountsMonorepo"},{"location":"presets-group/#groupangular1monorepo","text":"Group packages from angular1 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular1\", \"groupName\": \"angular1 monorepo\" } ] }","title":"group:angular1Monorepo"},{"location":"presets-group/#groupangularmonorepo","text":"Group packages from angular monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angular\", \"groupName\": \"angular monorepo\" } ] }","title":"group:angularMonorepo"},{"location":"presets-group/#groupangularclimonorepo","text":"Group packages from angularcli monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularcli\", \"groupName\": \"angularcli monorepo\" } ] }","title":"group:angularcliMonorepo"},{"location":"presets-group/#groupangularfiremonorepo","text":"Group packages from angularfire monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularfire\", \"groupName\": \"angularfire monorepo\" } ] }","title":"group:angularfireMonorepo"},{"location":"presets-group/#groupapolloclientmonorepo","text":"Group packages from apolloclient monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apolloclient\", \"groupName\": \"apolloclient monorepo\" } ] }","title":"group:apolloclientMonorepo"},{"location":"presets-group/#groupapollolinkmonorepo","text":"Group packages from apollolink monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:apollolink\", \"groupName\": \"apollolink monorepo\" } ] }","title":"group:apollolinkMonorepo"},{"location":"presets-group/#groupawsappsyncmonorepo","text":"Group packages from awsappsync monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:awsappsync\", \"groupName\": \"awsappsync monorepo\" } ] }","title":"group:awsappsyncMonorepo"},{"location":"presets-group/#groupbabelmonorepo","text":"Group packages from babel monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:babel\", \"groupName\": \"babel monorepo\" } ] }","title":"group:babelMonorepo"},{"location":"presets-group/#groupbasetmonorepo","text":"Group packages from baset monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:baset\", \"groupName\": \"baset monorepo\" } ] }","title":"group:basetMonorepo"},{"location":"presets-group/#groupbravemonorepo","text":"Group packages from brave monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:brave\", \"groupName\": \"brave monorepo\" } ] }","title":"group:braveMonorepo"},{"location":"presets-group/#groupcapacitormonorepo","text":"Group packages from capacitor monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:capacitor\", \"groupName\": \"capacitor monorepo\" } ] }","title":"group:capacitorMonorepo"},{"location":"presets-group/#groupchromelymonorepo","text":"Group packages from chromely monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:chromely\", \"groupName\": \"chromely monorepo\" } ] }","title":"group:chromelyMonorepo"},{"location":"presets-group/#groupclaritymonorepo","text":"Group packages from clarity monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:clarity\", \"groupName\": \"clarity monorepo\" } ] }","title":"group:clarityMonorepo"},{"location":"presets-group/#groupcommitlintmonorepo","text":"Group packages from commitlint monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:commitlint\", \"groupName\": \"commitlint monorepo\" } ] }","title":"group:commitlintMonorepo"},{"location":"presets-group/#groupdocusaurusmonorepo","text":"Group packages from docusaurus monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:docusaurus\", \"groupName\": \"docusaurus monorepo\" } ] }","title":"group:docusaurusMonorepo"},{"location":"presets-group/#groupdotnetmonorepo","text":"Group packages from dotnet monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:dotnet\", \"groupName\": \"dotnet monorepo\" } ] }","title":"group:dotnetMonorepo"},{"location":"presets-group/#groupdropwizardmonorepo","text":"Group packages from dropwizard monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:dropwizard\", \"groupName\": \"dropwizard monorepo\" } ] }","title":"group:dropwizardMonorepo"},{"location":"presets-group/#groupemotionmonorepo","text":"Group packages from emotion monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:emotion\", \"groupName\": \"emotion monorepo\" } ] }","title":"group:emotionMonorepo"},{"location":"presets-group/#groupexpomonorepo","text":"Group packages from expo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:expo\", \"groupName\": \"expo monorepo\" } ] }","title":"group:expoMonorepo"},{"location":"presets-group/#groupfeathersmonorepo","text":"Group packages from feathers monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:feathers\", \"groupName\": \"feathers monorepo\" } ] }","title":"group:feathersMonorepo"},{"location":"presets-group/#groupfimbullintermonorepo","text":"Group packages from fimbullinter monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:fimbullinter\", \"groupName\": \"fimbullinter monorepo\" } ] }","title":"group:fimbullinterMonorepo"},{"location":"presets-group/#groupflopflipmonorepo","text":"Group packages from flopflip monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:flopflip\", \"groupName\": \"flopflip monorepo\" } ] }","title":"group:flopflipMonorepo"},{"location":"presets-group/#groupformatjsmonorepo","text":"Group packages from formatjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:formatjs\", \"groupName\": \"formatjs monorepo\" } ] }","title":"group:formatjsMonorepo"},{"location":"presets-group/#groupframework7monorepo","text":"Group packages from framework7 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:framework7\", \"groupName\": \"framework7 monorepo\" } ] }","title":"group:framework7Monorepo"},{"location":"presets-group/#groupgatsbymonorepo","text":"Group packages from gatsby monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:gatsby\", \"groupName\": \"gatsby monorepo\" } ] }","title":"group:gatsbyMonorepo"},{"location":"presets-group/#groupgraphqlcodegeneratormonorepo","text":"Group packages from graphqlcodegenerator monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphqlcodegenerator\", \"groupName\": \"graphqlcodegenerator monorepo\" } ] }","title":"group:graphqlcodegeneratorMonorepo"},{"location":"presets-group/#groupgraphql-meshmonorepo","text":"Group packages from graphql-mesh monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-mesh\", \"groupName\": \"graphql-mesh monorepo\" } ] }","title":"group:graphql-meshMonorepo"},{"location":"presets-group/#groupgraphql-toolkitmonorepo","text":"Group packages from graphql-toolkit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-toolkit\", \"groupName\": \"graphql-toolkit monorepo\" } ] }","title":"group:graphql-toolkitMonorepo"},{"location":"presets-group/#groupgraphql-toolsmonorepo","text":"Group packages from graphql-tools monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:graphql-tools\", \"groupName\": \"graphql-tools monorepo\" } ] }","title":"group:graphql-toolsMonorepo"},{"location":"presets-group/#grouphamcrestmonorepo","text":"Group packages from hamcrest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:hamcrest\", \"groupName\": \"hamcrest monorepo\" } ] }","title":"group:hamcrestMonorepo"},{"location":"presets-group/#grouphangfiremonorepo","text":"Group packages from Hangfire monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Hangfire\", \"groupName\": \"Hangfire monorepo\" } ] }","title":"group:HangfireMonorepo"},{"location":"presets-group/#grouphapijsmonorepo","text":"Group packages from hapijs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:hapijs\", \"groupName\": \"hapijs monorepo\" } ] }","title":"group:hapijsMonorepo"},{"location":"presets-group/#groupinfrastructuremonorepo","text":"Group packages from infrastructure monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:infrastructure\", \"groupName\": \"infrastructure monorepo\" } ] }","title":"group:infrastructureMonorepo"},{"location":"presets-group/#groupistanbuljsmonorepo","text":"Group packages from istanbuljs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:istanbuljs\", \"groupName\": \"istanbuljs monorepo\" } ] }","title":"group:istanbuljsMonorepo"},{"location":"presets-group/#groupjasminemonorepo","text":"Group packages from jasmine monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jasmine\", \"groupName\": \"jasmine monorepo\" } ] }","title":"group:jasmineMonorepo"},{"location":"presets-group/#groupjerseymonorepo","text":"Group packages from jersey monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jersey\", \"groupName\": \"jersey monorepo\" } ] }","title":"group:jerseyMonorepo"},{"location":"presets-group/#groupjestmonorepo","text":"Group packages from jest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:jest\", \"groupName\": \"jest monorepo\" } ] }","title":"group:jestMonorepo"},{"location":"presets-group/#groupjunit5monorepo","text":"Group packages from junit5 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:junit5\", \"groupName\": \"junit5 monorepo\" } ] }","title":"group:junit5Monorepo"},{"location":"presets-group/#grouplernamonorepo","text":"Group packages from lerna monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lerna\", \"groupName\": \"lerna monorepo\" } ] }","title":"group:lernaMonorepo"},{"location":"presets-group/#grouplinguimonorepo","text":"Group packages from lingui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lingui\", \"groupName\": \"lingui monorepo\" } ] }","title":"group:linguiMonorepo"},{"location":"presets-group/#grouplodashmonorepo","text":"Group packages from lodash monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lodash\", \"groupName\": \"lodash monorepo\" } ] }","title":"group:lodashMonorepo"},{"location":"presets-group/#grouploopbackmonorepo","text":"Group packages from loopback monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:loopback\", \"groupName\": \"loopback monorepo\" } ] }","title":"group:loopbackMonorepo"},{"location":"presets-group/#grouplrnwebcomponentsmonorepo","text":"Group packages from lrnwebcomponents monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:lrnwebcomponents\", \"groupName\": \"lrnwebcomponents monorepo\" } ] }","title":"group:lrnwebcomponentsMonorepo"},{"location":"presets-group/#groupmasstransitmonorepo","text":"Group packages from MassTransit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:MassTransit\", \"groupName\": \"MassTransit monorepo\" } ] }","title":"group:MassTransitMonorepo"},{"location":"presets-group/#groupmaterialmonorepo","text":"Group packages from material monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:material\", \"groupName\": \"material monorepo\" } ] }","title":"group:materialMonorepo"},{"location":"presets-group/#groupmdxmonorepo","text":"Group packages from mdx monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mdx\", \"groupName\": \"mdx monorepo\" } ] }","title":"group:mdxMonorepo"},{"location":"presets-group/#groupmuimonorepo","text":"Group packages from mui monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:mui\", \"groupName\": \"mui monorepo\" } ] }","title":"group:muiMonorepo"},{"location":"presets-group/#groupnestmonorepo","text":"Group packages from nest monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nest\", \"groupName\": \"nest monorepo\" } ] }","title":"group:nestMonorepo"},{"location":"presets-group/#groupneutrinomonorepo","text":"Group packages from neutrino monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:neutrino\", \"groupName\": \"neutrino monorepo\" } ] }","title":"group:neutrinoMonorepo"},{"location":"presets-group/#groupnextjsmonorepo","text":"Group packages from nextjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nextjs\", \"groupName\": \"nextjs monorepo\" } ] }","title":"group:nextjsMonorepo"},{"location":"presets-group/#groupnivomonorepo","text":"Group packages from nivo monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nivo\", \"groupName\": \"nivo monorepo\" } ] }","title":"group:nivoMonorepo"},{"location":"presets-group/#groupngrxmonorepo","text":"Group packages from ngrx monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:ngrx\", \"groupName\": \"ngrx monorepo\" } ] }","title":"group:ngrxMonorepo"},{"location":"presets-group/#groupnrwlmonorepo","text":"Group packages from nrwl monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nrwl\", \"groupName\": \"nrwl monorepo\" } ] }","title":"group:nrwlMonorepo"},{"location":"presets-group/#groupnuxtjsmonorepo","text":"Group packages from nuxtjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:nuxtjs\", \"groupName\": \"nuxtjs monorepo\" } ] }","title":"group:nuxtjsMonorepo"},{"location":"presets-group/#groupopenfeignmonorepo","text":"Group packages from openfeign monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:openfeign\", \"groupName\": \"openfeign monorepo\" } ] }","title":"group:openfeignMonorepo"},{"location":"presets-group/#groupopentelemetrymonorepo","text":"Group packages from opentelemetry monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:opentelemetry\", \"groupName\": \"opentelemetry monorepo\" } ] }","title":"group:opentelemetryMonorepo"},{"location":"presets-group/#grouppicassomonorepo","text":"Group packages from picasso monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:picasso\", \"groupName\": \"picasso monorepo\" } ] }","title":"group:picassoMonorepo"},{"location":"presets-group/#grouppnpjsmonorepo","text":"Group packages from pnpjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pnpjs\", \"groupName\": \"pnpjs monorepo\" } ] }","title":"group:pnpjsMonorepo"},{"location":"presets-group/#groupplaywrightmonorepo","text":"Group packages from playwright monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:playwright\", \"groupName\": \"playwright monorepo\" } ] }","title":"group:playwrightMonorepo"},{"location":"presets-group/#grouppollyjsmonorepo","text":"Group packages from pollyjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pollyjs\", \"groupName\": \"pollyjs monorepo\" } ] }","title":"group:pollyjsMonorepo"},{"location":"presets-group/#grouppouchdbmonorepo","text":"Group packages from pouchdb monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:pouchdb\", \"groupName\": \"pouchdb monorepo\" } ] }","title":"group:pouchdbMonorepo"},{"location":"presets-group/#groupprismamonorepo","text":"Group packages from prisma monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:prisma\", \"groupName\": \"prisma monorepo\" } ] }","title":"group:prismaMonorepo"},{"location":"presets-group/#groupreactmonorepo","text":"Group packages from react monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:react\", \"groupName\": \"react monorepo\" } ] }","title":"group:reactMonorepo"},{"location":"presets-group/#groupreactroutermonorepo","text":"Group packages from reactrouter monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reactrouter\", \"groupName\": \"reactrouter monorepo\" } ] }","title":"group:reactrouterMonorepo"},{"location":"presets-group/#groupreakitmonorepo","text":"Group packages from reakit monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:reakit\", \"groupName\": \"reakit monorepo\" } ] }","title":"group:reakitMonorepo"},{"location":"presets-group/#groupredwoodmonorepo","text":"Group packages from redwood monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:redwood\", \"groupName\": \"redwood monorepo\" } ] }","title":"group:redwoodMonorepo"},{"location":"presets-group/#groupremarkmonorepo","text":"Group packages from remark monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:remark\", \"groupName\": \"remark monorepo\" } ] }","title":"group:remarkMonorepo"},{"location":"presets-group/#grouprouter5monorepo","text":"Group packages from router5 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:router5\", \"groupName\": \"router5 monorepo\" } ] }","title":"group:router5Monorepo"},{"location":"presets-group/#groupsentrymonorepo","text":"Group packages from sentry monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:sentry\", \"groupName\": \"sentry monorepo\" } ] }","title":"group:sentryMonorepo"},{"location":"presets-group/#groupspringfoxmonorepo","text":"Group packages from springfox monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:springfox\", \"groupName\": \"springfox monorepo\" } ] }","title":"group:springfoxMonorepo"},{"location":"presets-group/#groupsanitymonorepo","text":"Group packages from sanity monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:sanity\", \"groupName\": \"sanity monorepo\" } ] }","title":"group:sanityMonorepo"},{"location":"presets-group/#groupsteeltoemonorepo","text":"Group packages from Steeltoe monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Steeltoe\", \"groupName\": \"Steeltoe monorepo\" } ] }","title":"group:SteeltoeMonorepo"},{"location":"presets-group/#groupstorybookmonorepo","text":"Group packages from storybook monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:storybook\", \"groupName\": \"storybook monorepo\" } ] }","title":"group:storybookMonorepo"},{"location":"presets-group/#groupstrapimonorepo","text":"Group packages from strapi monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:strapi\", \"groupName\": \"strapi monorepo\" } ] }","title":"group:strapiMonorepo"},{"location":"presets-group/#groupstrykermonorepo","text":"Group packages from stryker monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:stryker\", \"groupName\": \"stryker monorepo\" } ] }","title":"group:strykerMonorepo"},{"location":"presets-group/#groupsurveyjsmonorepo","text":"Group packages from surveyjs monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:surveyjs\", \"groupName\": \"surveyjs monorepo\" } ] }","title":"group:surveyjsMonorepo"},{"location":"presets-group/#groupswashbucklemonorepo","text":"Group packages from Swashbuckle monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:Swashbuckle\", \"groupName\": \"Swashbuckle monorepo\" } ] }","title":"group:SwashbuckleMonorepo"},{"location":"presets-group/#grouptreatmonorepo","text":"Group packages from treat monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:treat\", \"groupName\": \"treat monorepo\" } ] }","title":"group:treatMonorepo"},{"location":"presets-group/#grouptypefacesmonorepo","text":"Group packages from typefaces monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:typefaces\", \"groupName\": \"typefaces monorepo\" } ] }","title":"group:typefacesMonorepo"},{"location":"presets-group/#groupuppymonorepo","text":"Group packages from uppy monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:uppy\", \"groupName\": \"uppy monorepo\" } ] }","title":"group:uppyMonorepo"},{"location":"presets-group/#groupvuemonorepo","text":"Group packages from vue monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vue\", \"groupName\": \"vue monorepo\" } ] }","title":"group:vueMonorepo"},{"location":"presets-group/#groupvuepressmonorepo","text":"Group packages from vuepress monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:vuepress\", \"groupName\": \"vuepress monorepo\" } ] }","title":"group:vuepressMonorepo"},{"location":"presets-group/#groupwebdriveriomonorepo","text":"Group packages from webdriverio monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:webdriverio\", \"groupName\": \"webdriverio monorepo\" } ] }","title":"group:webdriverioMonorepo"},{"location":"presets-group/#groupworkboxmonorepo","text":"Group packages from workbox monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:workbox\", \"groupName\": \"workbox monorepo\" } ] }","title":"group:workboxMonorepo"},{"location":"presets-group/#groupbabel6monorepo","text":"Group packages from babel6 monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:babel6\", \"groupName\": \"babel6 monorepo\" } ] }","title":"group:babel6Monorepo"},{"location":"presets-group/#groupwordpressmonorepo","text":"Group packages from wordpress monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:wordpress\", \"groupName\": \"wordpress monorepo\" } ] }","title":"group:wordpressMonorepo"},{"location":"presets-group/#groupangularmaterialmonorepo","text":"Group packages from angularmaterial monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:angularmaterial\", \"groupName\": \"angularmaterial monorepo\" } ] }","title":"group:angularmaterialMonorepo"},{"location":"presets-group/#groupaws-java-sdkmonorepo","text":"Group packages from aws-java-sdk monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:aws-java-sdk\", \"groupName\": \"aws-java-sdk monorepo\" } ] }","title":"group:aws-java-sdkMonorepo"},{"location":"presets-group/#groupembroidermonorepo","text":"Group packages from embroider monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:embroider\", \"groupName\": \"embroider monorepo\" } ] }","title":"group:embroiderMonorepo"},{"location":"presets-group/#groupfullcalendarmonorepo","text":"Group packages from fullcalendar monorepo together { \"packageRules\": [ { \"extends\": \"monorepo:fullcalendar\", \"groupName\": \"fullcalendar monorepo\" } ] }","title":"group:fullcalendarMonorepo"},{"location":"presets-group/#groupmonorepos","text":"Group known monorepo packages together { \"ignoreDeps\": [], \"extends\": [ \"group:ag-gridMonorepo\", \"group:arcus event-gridMonorepo\", \"group:arcus securityMonorepo\", \"group:arcus messagingMonorepo\", \"group:arcus observabilityMonorepo\", \"group:arcus webapiMonorepo\", \"group:arcus background-jobsMonorepo\", \"group:algolia-react-instantsearchMonorepo\", \"group:angular-eslintMonorepo\", \"group:apollo-serverMonorepo\", \"group:aspnet-api-versioningMonorepo\", \"group:aspnet AspNetWebStackMonorepo\", \"group:aspnet ExtensionsMonorepo\", \"group:aws-cdkMonorepo\", \"group:aws-sdk-js-v3Monorepo\", \"group:azure azure-libraries-for-netMonorepo\", \"group:azure azure-sdk-for-netMonorepo\", \"group:azure azure-storage-netMonorepo\", \"group:bugsnag-jsMonorepo\", \"group:date-ioMonorepo\", \"group:devextreme-reactiveMonorepo\", \"group:electron-forgeMonorepo\", \"group:feathers-databasesMonorepo\", \"group:ember-decoratorsMonorepo\", \"group:graphql-modulesMonorepo\", \"group:ionic-nativeMonorepo\", \"group:mdc-reactMonorepo\", \"group:ngx-formlyMonorepo\", \"group:ngxs-storeMonorepo\", \"group:reach-uiMonorepo\", \"group:react-apolloMonorepo\", \"group:react-dndMonorepo\", \"group:react-navigationMonorepo\", \"group:reactivestack-cookiesMonorepo\", \"group:reg-suitMonorepo\", \"group:semantic-releaseMonorepo\", \"group:telus-tdsMonorepo\", \"group:typescript-eslintMonorepo\", \"group:typography-jsMonorepo\", \"group:vue-cliMonorepo\", \"group:accountsMonorepo\", \"group:angular1Monorepo\", \"group:angularMonorepo\", \"group:angularcliMonorepo\", \"group:angularfireMonorepo\", \"group:apolloclientMonorepo\", \"group:apollolinkMonorepo\", \"group:awsappsyncMonorepo\", \"group:babelMonorepo\", \"group:basetMonorepo\", \"group:braveMonorepo\", \"group:capacitorMonorepo\", \"group:chromelyMonorepo\", \"group:clarityMonorepo\", \"group:commitlintMonorepo\", \"group:docusaurusMonorepo\", \"group:dotnetMonorepo\", \"group:dropwizardMonorepo\", \"group:emotionMonorepo\", \"group:expoMonorepo\", \"group:feathersMonorepo\", \"group:fimbullinterMonorepo\", \"group:flopflipMonorepo\", \"group:formatjsMonorepo\", \"group:framework7Monorepo\", \"group:gatsbyMonorepo\", \"group:graphqlcodegeneratorMonorepo\", \"group:graphql-meshMonorepo\", \"group:graphql-toolkitMonorepo\", \"group:graphql-toolsMonorepo\", \"group:hamcrestMonorepo\", \"group:HangfireMonorepo\", \"group:hapijsMonorepo\", \"group:infrastructureMonorepo\", \"group:istanbuljsMonorepo\", \"group:jasmineMonorepo\", \"group:jerseyMonorepo\", \"group:jestMonorepo\", \"group:junit5Monorepo\", \"group:lernaMonorepo\", \"group:linguiMonorepo\", \"group:lodashMonorepo\", \"group:loopbackMonorepo\", \"group:lrnwebcomponentsMonorepo\", \"group:MassTransitMonorepo\", \"group:materialMonorepo\", \"group:mdxMonorepo\", \"group:muiMonorepo\", \"group:nestMonorepo\", \"group:neutrinoMonorepo\", \"group:nextjsMonorepo\", \"group:nivoMonorepo\", \"group:ngrxMonorepo\", \"group:nrwlMonorepo\", \"group:nuxtjsMonorepo\", \"group:openfeignMonorepo\", \"group:opentelemetryMonorepo\", \"group:picassoMonorepo\", \"group:pnpjsMonorepo\", \"group:playwrightMonorepo\", \"group:pollyjsMonorepo\", \"group:pouchdbMonorepo\", \"group:prismaMonorepo\", \"group:reactMonorepo\", \"group:reactrouterMonorepo\", \"group:reakitMonorepo\", \"group:redwoodMonorepo\", \"group:remarkMonorepo\", \"group:router5Monorepo\", \"group:sentryMonorepo\", \"group:springfoxMonorepo\", \"group:sanityMonorepo\", \"group:SteeltoeMonorepo\", \"group:storybookMonorepo\", \"group:strapiMonorepo\", \"group:strykerMonorepo\", \"group:surveyjsMonorepo\", \"group:SwashbuckleMonorepo\", \"group:treatMonorepo\", \"group:typefacesMonorepo\", \"group:uppyMonorepo\", \"group:vueMonorepo\", \"group:vuepressMonorepo\", \"group:webdriverioMonorepo\", \"group:workboxMonorepo\", \"group:babel6Monorepo\", \"group:wordpressMonorepo\", \"group:angularmaterialMonorepo\", \"group:aws-java-sdkMonorepo\", \"group:embroiderMonorepo\", \"group:fullcalendarMonorepo\" ] }","title":"group:monorepos"},{"location":"presets-helpers/","text":"helpers:disableTypesNodeMajor { \"packageRules\": [ { \"matchPackageNames\": [ \"@types/node\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": false } ] } helpers:oddIsUnstable DEPRECATED: Odd version numbers are classified as unstable {} helpers:oddIsUnstablePackages DEPRECATED: Preconfigure dependencies where an odd major version indicates unstable (Docker-only) {} helpers:followTypescriptNext Keep version in sync with the next tag { \"extends\": [ \":followTag(typescript, next)\" ] } helpers:followTypescriptRc Keep version in sync with the rc tag { \"extends\": [ \":followTag(typescript, rc)\" ] }","title":"Helper Presets"},{"location":"presets-helpers/#helpersdisabletypesnodemajor","text":"{ \"packageRules\": [ { \"matchPackageNames\": [ \"@types/node\" ], \"matchUpdateTypes\": [ \"major\" ], \"enabled\": false } ] }","title":"helpers:disableTypesNodeMajor"},{"location":"presets-helpers/#helpersoddisunstable","text":"DEPRECATED: Odd version numbers are classified as unstable {}","title":"helpers:oddIsUnstable"},{"location":"presets-helpers/#helpersoddisunstablepackages","text":"DEPRECATED: Preconfigure dependencies where an odd major version indicates unstable (Docker-only) {}","title":"helpers:oddIsUnstablePackages"},{"location":"presets-helpers/#helpersfollowtypescriptnext","text":"Keep version in sync with the next tag { \"extends\": [ \":followTag(typescript, next)\" ] }","title":"helpers:followTypescriptNext"},{"location":"presets-helpers/#helpersfollowtypescriptrc","text":"Keep version in sync with the rc tag { \"extends\": [ \":followTag(typescript, rc)\" ] }","title":"helpers:followTypescriptRc"},{"location":"presets-monorepo/","text":"monorepo:ag-grid ag-grid monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ag-grid/ag-grid\" ] } monorepo:arcus event-grid arcus event-grid monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.eventgrid\" ] } monorepo:arcus security arcus security monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.security\" ] } monorepo:arcus messaging arcus messaging monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.messaging\" ] } monorepo:arcus observability arcus observability monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.observability\" ] } monorepo:arcus webapi arcus webapi monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.webapi\" ] } monorepo:arcus background-jobs arcus background-jobs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.backgroundjobs\" ] } monorepo:algolia-react-instantsearch algolia-react-instantsearch monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/algolia/react-instantsearch\" ] } monorepo:angular-eslint angular-eslint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular-eslint/angular-eslint\" ] } monorepo:apollo-server apollo-server monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-server\" ] } monorepo:aspnet-api-versioning aspnet-api-versioning monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Microsoft/aspnet-api-versioning\" ] } monorepo:aspnet AspNetWebStack aspnet AspNetWebStack monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aspnet/AspNetWebStack\" ] } monorepo:aspnet Extensions aspnet Extensions monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aspnet/Extensions\" ] } monorepo:aws-cdk aws-cdk monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aws/aws-cdk\" ] } monorepo:aws-sdk-js-v3 aws-sdk-js-v3 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aws/aws-sdk-js-v3\" ] } monorepo:azure azure-libraries-for-net azure azure-libraries-for-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-libraries-for-net\" ] } monorepo:azure azure-sdk-for-net azure azure-sdk-for-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-sdk-for-net\" ] } monorepo:azure azure-storage-net azure azure-storage-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-storage-net\" ] } monorepo:bugsnag-js bugsnag-js monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/bugsnag/bugsnag-js\" ] } monorepo:date-io date-io monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dmtrKovalenko/date-io\" ] } monorepo:devextreme-reactive devextreme-reactive monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/DevExpress/devextreme-reactive\" ] } monorepo:electron-forge electron-forge monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/electron-userland/electron-forge\" ] } monorepo:feathers-databases feathers-databases monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/feathersjs/databases\" ] } monorepo:ember-decorators ember-decorators monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ember-decorators/ember-decorators\" ] } monorepo:graphql-modules graphql-modules monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Urigo/graphql-modules\" ] } monorepo:ionic-native ionic-native monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ionic-team/ionic-native\" ] } monorepo:mdc-react mdc-react monorepo { \"matchSourceUrlPrefixes\": [ \"material-components/material-components-web-react\" ] } monorepo:ngx-formly ngx-formly monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngx-formly/ngx-formly\" ] } monorepo:ngxs-store ngxs-store monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngxs/store\" ] } monorepo:reach-ui reach-ui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reach/reach-ui\" ] } monorepo:react-apollo react-apollo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/react-apollo\" ] } monorepo:react-dnd react-dnd monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/react-dnd/react-dnd\" ] } monorepo:react-navigation react-navigation monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/react-navigation/react-navigation\" ] } monorepo:reactivestack-cookies reactivestack-cookies monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reactivestack/cookies\" ] } monorepo:reg-suit reg-suit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reg-viz/reg-suit\" ] } monorepo:semantic-release semantic-release monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/semantic-release/\" ] } monorepo:telus-tds telus-tds monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/telusdigital/tds\" ] } monorepo:typescript-eslint typescript-eslint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/typescript-eslint/typescript-eslint\" ] } monorepo:typography-js typography-js monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/KyleAMathews/typography.js\" ] } monorepo:vue-cli vue-cli monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vue-cli\" ] } monorepo:accounts accounts monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/accounts-js/accounts\" ] } monorepo:angular1 angular1 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular.js\" ] } monorepo:angular angular monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular\" ] } monorepo:angularcli angularcli monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular-cli\" ] } monorepo:angularfire angularfire monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angularfire\" ] } monorepo:apolloclient apolloclient monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-client\" ] } monorepo:apollolink apollolink monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-link\" ] } monorepo:awsappsync awsappsync monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/awslabs/aws-mobile-appsync-sdk-js\" ] } monorepo:babel babel monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/babel/babel\" ] } monorepo:baset baset monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/igmat/baset\" ] } monorepo:brave brave monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/openzipkin/brave\" ] } monorepo:capacitor capacitor monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ionic-team/capacitor\" ] } monorepo:chromely chromely monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/chromelyapps/Chromely\" ] } monorepo:clarity clarity monorepo { \"matchPackagePatterns\": [ \"^@cds/\", \"^@clr/\" ] } monorepo:commitlint commitlint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/conventional-changelog/commitlint\" ] } monorepo:docusaurus docusaurus monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/docusaurus\" ] } monorepo:dotnet dotnet monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dotnet/aspnetcore\", \"https://github.com/dotnet/efcore\", \"https://github.com/dotnet/extensions\", \"https://github.com/dotnet/runtime\" ] } monorepo:dropwizard dropwizard monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dropwizard/dropwizard\" ] } monorepo:emotion emotion monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/emotion-js/emotion\" ] } monorepo:expo expo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/expo/expo\" ] } monorepo:feathers feathers monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/feathersjs/feathers\" ] } monorepo:fimbullinter fimbullinter monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/fimbullinter/wotan\" ] } monorepo:flopflip flopflip monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/tdeekens/flopflip\" ] } monorepo:formatjs formatjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/formatjs/formatjs\" ] } monorepo:framework7 framework7 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/framework7io/framework7\" ] } monorepo:gatsby gatsby monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/gatsbyjs/gatsby\" ] } monorepo:graphqlcodegenerator graphqlcodegenerator monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dotansimha/graphql-code-generator\", \"https://github.com/dotansimha/graphql-codegen\" ] } monorepo:graphql-mesh graphql-mesh monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Urigo/graphql-mesh\" ] } monorepo:graphql-toolkit graphql-toolkit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ardatan/graphql-toolkit\" ] } monorepo:graphql-tools graphql-tools monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ardatan/graphql-tools\" ] } monorepo:hamcrest hamcrest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/hamcrest/JavaHamcrest\" ] } monorepo:Hangfire Hangfire monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/HangfireIO/Hangfire\" ] } monorepo:hapijs hapijs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/hapijs\" ] } monorepo:infrastructure infrastructure monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/instructure/instructure-ui\" ] } monorepo:istanbuljs istanbuljs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/istanbuljs/istanbuljs\" ] } monorepo:jasmine jasmine monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/jasmine/jasmine\" ] } monorepo:jersey jersey monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/eclipse-ee4j/jersey\" ] } monorepo:jest jest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/jest\" ] } monorepo:junit5 junit5 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/junit-team/junit5\" ] } monorepo:lerna lerna monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lerna/lerna\" ] } monorepo:lingui lingui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lingui/js-lingui\" ] } monorepo:lodash lodash monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lodash/\" ] } monorepo:loopback loopback monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/strongloop/loopback-next\" ] } monorepo:lrnwebcomponents lrnwebcomponents monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/elmsln/lrnwebcomponents\" ] } monorepo:MassTransit MassTransit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/MassTransit/MassTransit\" ] } monorepo:material material monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/material-components/material-components-web\" ] } monorepo:mdx mdx monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/mdx-js/mdx\" ] } monorepo:mui mui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/mui-org/material-ui\" ] } monorepo:nest nest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nestjs/nest\" ] } monorepo:neutrino neutrino monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/neutrinojs/neutrino\", \"https://github.com/mozilla-neutrino/neutrino-dev\" ] } monorepo:nextjs nextjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/zeit/next.js\", \"https://github.com/vercel/next.js\" ] } monorepo:nivo nivo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/plouc/nivo\" ] } monorepo:ngrx ngrx monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngrx/\" ] } monorepo:nrwl nrwl monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nrwl/\" ] } monorepo:nuxtjs nuxtjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nuxt/nuxt.js\" ] } monorepo:openfeign openfeign monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/OpenFeign/feign\" ] } monorepo:opentelemetry opentelemetry monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/open-telemetry/opentelemetry-js\" ] } monorepo:picasso picasso monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/qlik-oss/picasso.js\" ] } monorepo:pnpjs pnpjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/pnp/pnpjs\" ] } monorepo:playwright playwright monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Microsoft/playwright\" ] } monorepo:pollyjs pollyjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Netflix/pollyjs\" ] } monorepo:pouchdb pouchdb monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/pouchdb/pouchdb\" ] } monorepo:prisma prisma monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/prisma/prisma\" ] } monorepo:react react monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/react\" ] } monorepo:reactrouter reactrouter monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ReactTraining/react-router\" ] } monorepo:reakit reakit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reakit/reakit\" ] } monorepo:redwood redwood monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/redwoodjs/redwood\" ] } monorepo:remark remark monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/remarkjs/remark\" ] } monorepo:router5 router5 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/router5/router5\" ] } monorepo:sentry sentry monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/getsentry/sentry-javascript\" ] } monorepo:springfox springfox monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/springfox/springfox\" ] } monorepo:sanity sanity monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/sanity-io/sanity\" ] } monorepo:Steeltoe Steeltoe monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/SteeltoeOSS/steeltoe\" ] } monorepo:storybook storybook monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/storybookjs/storybook\" ] } monorepo:strapi strapi monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/strapi/strapi\" ] } monorepo:stryker stryker monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/stryker-mutator/stryker\" ] } monorepo:surveyjs surveyjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/surveyjs/surveyjs\" ] } monorepo:Swashbuckle Swashbuckle monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/domaindrivendev/Swashbuckle.AspNetCore\" ] } monorepo:treat treat monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/seek-oss/treat\" ] } monorepo:typefaces typefaces monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/KyleAMathews/typefaces\" ] } monorepo:uppy uppy monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/transloadit/uppy\" ] } monorepo:vue vue monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vue\" ] } monorepo:vuepress vuepress monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vuepress\" ] } monorepo:webdriverio webdriverio monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/webdriverio/webdriverio\" ] } monorepo:workbox workbox monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/googlechrome/workbox\" ] } monorepo:babel6 babel6 monorepo { \"matchPackagePatterns\": [ \"^babel6$\" ] } monorepo:wordpress wordpress monorepo { \"matchPackagePatterns\": [ \"^@wordpress/\" ] } monorepo:angularmaterial angularmaterial monorepo { \"matchPackagePatterns\": [ \"^@angular/material\", \"^@angular/cdk\" ] } monorepo:aws-java-sdk aws-java-sdk monorepo { \"matchPackagePatterns\": [ \"^com.amazonaws:aws-java-sdk-\" ] } monorepo:embroider embroider monorepo { \"matchPackagePatterns\": [ \"^@embroider/\" ] } monorepo:fullcalendar fullcalendar monorepo { \"matchPackagePatterns\": [ \"^@fullcalendar/\" ] }","title":"Monorepo Presets"},{"location":"presets-monorepo/#monorepoag-grid","text":"ag-grid monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ag-grid/ag-grid\" ] }","title":"monorepo:ag-grid"},{"location":"presets-monorepo/#monorepoarcus-event-grid","text":"arcus event-grid monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.eventgrid\" ] }","title":"monorepo:arcus event-grid"},{"location":"presets-monorepo/#monorepoarcus-security","text":"arcus security monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.security\" ] }","title":"monorepo:arcus security"},{"location":"presets-monorepo/#monorepoarcus-messaging","text":"arcus messaging monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.messaging\" ] }","title":"monorepo:arcus messaging"},{"location":"presets-monorepo/#monorepoarcus-observability","text":"arcus observability monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.observability\" ] }","title":"monorepo:arcus observability"},{"location":"presets-monorepo/#monorepoarcus-webapi","text":"arcus webapi monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.webapi\" ] }","title":"monorepo:arcus webapi"},{"location":"presets-monorepo/#monorepoarcus-background-jobs","text":"arcus background-jobs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/arcus-azure/arcus.backgroundjobs\" ] }","title":"monorepo:arcus background-jobs"},{"location":"presets-monorepo/#monorepoalgolia-react-instantsearch","text":"algolia-react-instantsearch monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/algolia/react-instantsearch\" ] }","title":"monorepo:algolia-react-instantsearch"},{"location":"presets-monorepo/#monorepoangular-eslint","text":"angular-eslint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular-eslint/angular-eslint\" ] }","title":"monorepo:angular-eslint"},{"location":"presets-monorepo/#monorepoapollo-server","text":"apollo-server monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-server\" ] }","title":"monorepo:apollo-server"},{"location":"presets-monorepo/#monorepoaspnet-api-versioning","text":"aspnet-api-versioning monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Microsoft/aspnet-api-versioning\" ] }","title":"monorepo:aspnet-api-versioning"},{"location":"presets-monorepo/#monorepoaspnet-aspnetwebstack","text":"aspnet AspNetWebStack monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aspnet/AspNetWebStack\" ] }","title":"monorepo:aspnet AspNetWebStack"},{"location":"presets-monorepo/#monorepoaspnet-extensions","text":"aspnet Extensions monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aspnet/Extensions\" ] }","title":"monorepo:aspnet Extensions"},{"location":"presets-monorepo/#monorepoaws-cdk","text":"aws-cdk monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aws/aws-cdk\" ] }","title":"monorepo:aws-cdk"},{"location":"presets-monorepo/#monorepoaws-sdk-js-v3","text":"aws-sdk-js-v3 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/aws/aws-sdk-js-v3\" ] }","title":"monorepo:aws-sdk-js-v3"},{"location":"presets-monorepo/#monorepoazure-azure-libraries-for-net","text":"azure azure-libraries-for-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-libraries-for-net\" ] }","title":"monorepo:azure azure-libraries-for-net"},{"location":"presets-monorepo/#monorepoazure-azure-sdk-for-net","text":"azure azure-sdk-for-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-sdk-for-net\" ] }","title":"monorepo:azure azure-sdk-for-net"},{"location":"presets-monorepo/#monorepoazure-azure-storage-net","text":"azure azure-storage-net monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Azure/azure-storage-net\" ] }","title":"monorepo:azure azure-storage-net"},{"location":"presets-monorepo/#monorepobugsnag-js","text":"bugsnag-js monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/bugsnag/bugsnag-js\" ] }","title":"monorepo:bugsnag-js"},{"location":"presets-monorepo/#monorepodate-io","text":"date-io monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dmtrKovalenko/date-io\" ] }","title":"monorepo:date-io"},{"location":"presets-monorepo/#monorepodevextreme-reactive","text":"devextreme-reactive monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/DevExpress/devextreme-reactive\" ] }","title":"monorepo:devextreme-reactive"},{"location":"presets-monorepo/#monorepoelectron-forge","text":"electron-forge monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/electron-userland/electron-forge\" ] }","title":"monorepo:electron-forge"},{"location":"presets-monorepo/#monorepofeathers-databases","text":"feathers-databases monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/feathersjs/databases\" ] }","title":"monorepo:feathers-databases"},{"location":"presets-monorepo/#monorepoember-decorators","text":"ember-decorators monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ember-decorators/ember-decorators\" ] }","title":"monorepo:ember-decorators"},{"location":"presets-monorepo/#monorepographql-modules","text":"graphql-modules monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Urigo/graphql-modules\" ] }","title":"monorepo:graphql-modules"},{"location":"presets-monorepo/#monorepoionic-native","text":"ionic-native monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ionic-team/ionic-native\" ] }","title":"monorepo:ionic-native"},{"location":"presets-monorepo/#monorepomdc-react","text":"mdc-react monorepo { \"matchSourceUrlPrefixes\": [ \"material-components/material-components-web-react\" ] }","title":"monorepo:mdc-react"},{"location":"presets-monorepo/#monorepongx-formly","text":"ngx-formly monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngx-formly/ngx-formly\" ] }","title":"monorepo:ngx-formly"},{"location":"presets-monorepo/#monorepongxs-store","text":"ngxs-store monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngxs/store\" ] }","title":"monorepo:ngxs-store"},{"location":"presets-monorepo/#monoreporeach-ui","text":"reach-ui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reach/reach-ui\" ] }","title":"monorepo:reach-ui"},{"location":"presets-monorepo/#monoreporeact-apollo","text":"react-apollo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/react-apollo\" ] }","title":"monorepo:react-apollo"},{"location":"presets-monorepo/#monoreporeact-dnd","text":"react-dnd monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/react-dnd/react-dnd\" ] }","title":"monorepo:react-dnd"},{"location":"presets-monorepo/#monoreporeact-navigation","text":"react-navigation monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/react-navigation/react-navigation\" ] }","title":"monorepo:react-navigation"},{"location":"presets-monorepo/#monoreporeactivestack-cookies","text":"reactivestack-cookies monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reactivestack/cookies\" ] }","title":"monorepo:reactivestack-cookies"},{"location":"presets-monorepo/#monoreporeg-suit","text":"reg-suit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reg-viz/reg-suit\" ] }","title":"monorepo:reg-suit"},{"location":"presets-monorepo/#monoreposemantic-release","text":"semantic-release monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/semantic-release/\" ] }","title":"monorepo:semantic-release"},{"location":"presets-monorepo/#monorepotelus-tds","text":"telus-tds monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/telusdigital/tds\" ] }","title":"monorepo:telus-tds"},{"location":"presets-monorepo/#monorepotypescript-eslint","text":"typescript-eslint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/typescript-eslint/typescript-eslint\" ] }","title":"monorepo:typescript-eslint"},{"location":"presets-monorepo/#monorepotypography-js","text":"typography-js monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/KyleAMathews/typography.js\" ] }","title":"monorepo:typography-js"},{"location":"presets-monorepo/#monorepovue-cli","text":"vue-cli monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vue-cli\" ] }","title":"monorepo:vue-cli"},{"location":"presets-monorepo/#monorepoaccounts","text":"accounts monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/accounts-js/accounts\" ] }","title":"monorepo:accounts"},{"location":"presets-monorepo/#monorepoangular1","text":"angular1 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular.js\" ] }","title":"monorepo:angular1"},{"location":"presets-monorepo/#monorepoangular","text":"angular monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular\" ] }","title":"monorepo:angular"},{"location":"presets-monorepo/#monorepoangularcli","text":"angularcli monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angular-cli\" ] }","title":"monorepo:angularcli"},{"location":"presets-monorepo/#monorepoangularfire","text":"angularfire monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/angular/angularfire\" ] }","title":"monorepo:angularfire"},{"location":"presets-monorepo/#monorepoapolloclient","text":"apolloclient monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-client\" ] }","title":"monorepo:apolloclient"},{"location":"presets-monorepo/#monorepoapollolink","text":"apollolink monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/apollo-link\" ] }","title":"monorepo:apollolink"},{"location":"presets-monorepo/#monorepoawsappsync","text":"awsappsync monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/awslabs/aws-mobile-appsync-sdk-js\" ] }","title":"monorepo:awsappsync"},{"location":"presets-monorepo/#monorepobabel","text":"babel monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/babel/babel\" ] }","title":"monorepo:babel"},{"location":"presets-monorepo/#monorepobaset","text":"baset monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/igmat/baset\" ] }","title":"monorepo:baset"},{"location":"presets-monorepo/#monorepobrave","text":"brave monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/openzipkin/brave\" ] }","title":"monorepo:brave"},{"location":"presets-monorepo/#monorepocapacitor","text":"capacitor monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ionic-team/capacitor\" ] }","title":"monorepo:capacitor"},{"location":"presets-monorepo/#monorepochromely","text":"chromely monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/chromelyapps/Chromely\" ] }","title":"monorepo:chromely"},{"location":"presets-monorepo/#monorepoclarity","text":"clarity monorepo { \"matchPackagePatterns\": [ \"^@cds/\", \"^@clr/\" ] }","title":"monorepo:clarity"},{"location":"presets-monorepo/#monorepocommitlint","text":"commitlint monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/conventional-changelog/commitlint\" ] }","title":"monorepo:commitlint"},{"location":"presets-monorepo/#monorepodocusaurus","text":"docusaurus monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/docusaurus\" ] }","title":"monorepo:docusaurus"},{"location":"presets-monorepo/#monorepodotnet","text":"dotnet monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dotnet/aspnetcore\", \"https://github.com/dotnet/efcore\", \"https://github.com/dotnet/extensions\", \"https://github.com/dotnet/runtime\" ] }","title":"monorepo:dotnet"},{"location":"presets-monorepo/#monorepodropwizard","text":"dropwizard monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dropwizard/dropwizard\" ] }","title":"monorepo:dropwizard"},{"location":"presets-monorepo/#monorepoemotion","text":"emotion monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/emotion-js/emotion\" ] }","title":"monorepo:emotion"},{"location":"presets-monorepo/#monorepoexpo","text":"expo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/expo/expo\" ] }","title":"monorepo:expo"},{"location":"presets-monorepo/#monorepofeathers","text":"feathers monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/feathersjs/feathers\" ] }","title":"monorepo:feathers"},{"location":"presets-monorepo/#monorepofimbullinter","text":"fimbullinter monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/fimbullinter/wotan\" ] }","title":"monorepo:fimbullinter"},{"location":"presets-monorepo/#monorepoflopflip","text":"flopflip monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/tdeekens/flopflip\" ] }","title":"monorepo:flopflip"},{"location":"presets-monorepo/#monorepoformatjs","text":"formatjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/formatjs/formatjs\" ] }","title":"monorepo:formatjs"},{"location":"presets-monorepo/#monorepoframework7","text":"framework7 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/framework7io/framework7\" ] }","title":"monorepo:framework7"},{"location":"presets-monorepo/#monorepogatsby","text":"gatsby monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/gatsbyjs/gatsby\" ] }","title":"monorepo:gatsby"},{"location":"presets-monorepo/#monorepographqlcodegenerator","text":"graphqlcodegenerator monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/dotansimha/graphql-code-generator\", \"https://github.com/dotansimha/graphql-codegen\" ] }","title":"monorepo:graphqlcodegenerator"},{"location":"presets-monorepo/#monorepographql-mesh","text":"graphql-mesh monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Urigo/graphql-mesh\" ] }","title":"monorepo:graphql-mesh"},{"location":"presets-monorepo/#monorepographql-toolkit","text":"graphql-toolkit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ardatan/graphql-toolkit\" ] }","title":"monorepo:graphql-toolkit"},{"location":"presets-monorepo/#monorepographql-tools","text":"graphql-tools monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ardatan/graphql-tools\" ] }","title":"monorepo:graphql-tools"},{"location":"presets-monorepo/#monorepohamcrest","text":"hamcrest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/hamcrest/JavaHamcrest\" ] }","title":"monorepo:hamcrest"},{"location":"presets-monorepo/#monorepohangfire","text":"Hangfire monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/HangfireIO/Hangfire\" ] }","title":"monorepo:Hangfire"},{"location":"presets-monorepo/#monorepohapijs","text":"hapijs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/hapijs\" ] }","title":"monorepo:hapijs"},{"location":"presets-monorepo/#monorepoinfrastructure","text":"infrastructure monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/instructure/instructure-ui\" ] }","title":"monorepo:infrastructure"},{"location":"presets-monorepo/#monorepoistanbuljs","text":"istanbuljs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/istanbuljs/istanbuljs\" ] }","title":"monorepo:istanbuljs"},{"location":"presets-monorepo/#monorepojasmine","text":"jasmine monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/jasmine/jasmine\" ] }","title":"monorepo:jasmine"},{"location":"presets-monorepo/#monorepojersey","text":"jersey monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/eclipse-ee4j/jersey\" ] }","title":"monorepo:jersey"},{"location":"presets-monorepo/#monorepojest","text":"jest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/jest\" ] }","title":"monorepo:jest"},{"location":"presets-monorepo/#monorepojunit5","text":"junit5 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/junit-team/junit5\" ] }","title":"monorepo:junit5"},{"location":"presets-monorepo/#monorepolerna","text":"lerna monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lerna/lerna\" ] }","title":"monorepo:lerna"},{"location":"presets-monorepo/#monorepolingui","text":"lingui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lingui/js-lingui\" ] }","title":"monorepo:lingui"},{"location":"presets-monorepo/#monorepolodash","text":"lodash monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/lodash/\" ] }","title":"monorepo:lodash"},{"location":"presets-monorepo/#monorepoloopback","text":"loopback monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/strongloop/loopback-next\" ] }","title":"monorepo:loopback"},{"location":"presets-monorepo/#monorepolrnwebcomponents","text":"lrnwebcomponents monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/elmsln/lrnwebcomponents\" ] }","title":"monorepo:lrnwebcomponents"},{"location":"presets-monorepo/#monorepomasstransit","text":"MassTransit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/MassTransit/MassTransit\" ] }","title":"monorepo:MassTransit"},{"location":"presets-monorepo/#monorepomaterial","text":"material monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/material-components/material-components-web\" ] }","title":"monorepo:material"},{"location":"presets-monorepo/#monorepomdx","text":"mdx monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/mdx-js/mdx\" ] }","title":"monorepo:mdx"},{"location":"presets-monorepo/#monorepomui","text":"mui monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/mui-org/material-ui\" ] }","title":"monorepo:mui"},{"location":"presets-monorepo/#monoreponest","text":"nest monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nestjs/nest\" ] }","title":"monorepo:nest"},{"location":"presets-monorepo/#monoreponeutrino","text":"neutrino monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/neutrinojs/neutrino\", \"https://github.com/mozilla-neutrino/neutrino-dev\" ] }","title":"monorepo:neutrino"},{"location":"presets-monorepo/#monoreponextjs","text":"nextjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/zeit/next.js\", \"https://github.com/vercel/next.js\" ] }","title":"monorepo:nextjs"},{"location":"presets-monorepo/#monoreponivo","text":"nivo monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/plouc/nivo\" ] }","title":"monorepo:nivo"},{"location":"presets-monorepo/#monorepongrx","text":"ngrx monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ngrx/\" ] }","title":"monorepo:ngrx"},{"location":"presets-monorepo/#monoreponrwl","text":"nrwl monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nrwl/\" ] }","title":"monorepo:nrwl"},{"location":"presets-monorepo/#monoreponuxtjs","text":"nuxtjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/nuxt/nuxt.js\" ] }","title":"monorepo:nuxtjs"},{"location":"presets-monorepo/#monorepoopenfeign","text":"openfeign monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/OpenFeign/feign\" ] }","title":"monorepo:openfeign"},{"location":"presets-monorepo/#monorepoopentelemetry","text":"opentelemetry monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/open-telemetry/opentelemetry-js\" ] }","title":"monorepo:opentelemetry"},{"location":"presets-monorepo/#monorepopicasso","text":"picasso monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/qlik-oss/picasso.js\" ] }","title":"monorepo:picasso"},{"location":"presets-monorepo/#monorepopnpjs","text":"pnpjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/pnp/pnpjs\" ] }","title":"monorepo:pnpjs"},{"location":"presets-monorepo/#monorepoplaywright","text":"playwright monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Microsoft/playwright\" ] }","title":"monorepo:playwright"},{"location":"presets-monorepo/#monorepopollyjs","text":"pollyjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/Netflix/pollyjs\" ] }","title":"monorepo:pollyjs"},{"location":"presets-monorepo/#monorepopouchdb","text":"pouchdb monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/pouchdb/pouchdb\" ] }","title":"monorepo:pouchdb"},{"location":"presets-monorepo/#monorepoprisma","text":"prisma monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/prisma/prisma\" ] }","title":"monorepo:prisma"},{"location":"presets-monorepo/#monoreporeact","text":"react monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/facebook/react\" ] }","title":"monorepo:react"},{"location":"presets-monorepo/#monoreporeactrouter","text":"reactrouter monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/ReactTraining/react-router\" ] }","title":"monorepo:reactrouter"},{"location":"presets-monorepo/#monoreporeakit","text":"reakit monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/reakit/reakit\" ] }","title":"monorepo:reakit"},{"location":"presets-monorepo/#monoreporedwood","text":"redwood monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/redwoodjs/redwood\" ] }","title":"monorepo:redwood"},{"location":"presets-monorepo/#monoreporemark","text":"remark monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/remarkjs/remark\" ] }","title":"monorepo:remark"},{"location":"presets-monorepo/#monoreporouter5","text":"router5 monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/router5/router5\" ] }","title":"monorepo:router5"},{"location":"presets-monorepo/#monoreposentry","text":"sentry monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/getsentry/sentry-javascript\" ] }","title":"monorepo:sentry"},{"location":"presets-monorepo/#monorepospringfox","text":"springfox monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/springfox/springfox\" ] }","title":"monorepo:springfox"},{"location":"presets-monorepo/#monoreposanity","text":"sanity monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/sanity-io/sanity\" ] }","title":"monorepo:sanity"},{"location":"presets-monorepo/#monoreposteeltoe","text":"Steeltoe monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/SteeltoeOSS/steeltoe\" ] }","title":"monorepo:Steeltoe"},{"location":"presets-monorepo/#monorepostorybook","text":"storybook monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/storybookjs/storybook\" ] }","title":"monorepo:storybook"},{"location":"presets-monorepo/#monorepostrapi","text":"strapi monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/strapi/strapi\" ] }","title":"monorepo:strapi"},{"location":"presets-monorepo/#monorepostryker","text":"stryker monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/stryker-mutator/stryker\" ] }","title":"monorepo:stryker"},{"location":"presets-monorepo/#monoreposurveyjs","text":"surveyjs monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/surveyjs/surveyjs\" ] }","title":"monorepo:surveyjs"},{"location":"presets-monorepo/#monoreposwashbuckle","text":"Swashbuckle monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/domaindrivendev/Swashbuckle.AspNetCore\" ] }","title":"monorepo:Swashbuckle"},{"location":"presets-monorepo/#monorepotreat","text":"treat monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/seek-oss/treat\" ] }","title":"monorepo:treat"},{"location":"presets-monorepo/#monorepotypefaces","text":"typefaces monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/KyleAMathews/typefaces\" ] }","title":"monorepo:typefaces"},{"location":"presets-monorepo/#monorepouppy","text":"uppy monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/transloadit/uppy\" ] }","title":"monorepo:uppy"},{"location":"presets-monorepo/#monorepovue","text":"vue monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vue\" ] }","title":"monorepo:vue"},{"location":"presets-monorepo/#monorepovuepress","text":"vuepress monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/vuejs/vuepress\" ] }","title":"monorepo:vuepress"},{"location":"presets-monorepo/#monorepowebdriverio","text":"webdriverio monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/webdriverio/webdriverio\" ] }","title":"monorepo:webdriverio"},{"location":"presets-monorepo/#monorepoworkbox","text":"workbox monorepo { \"matchSourceUrlPrefixes\": [ \"https://github.com/googlechrome/workbox\" ] }","title":"monorepo:workbox"},{"location":"presets-monorepo/#monorepobabel6","text":"babel6 monorepo { \"matchPackagePatterns\": [ \"^babel6$\" ] }","title":"monorepo:babel6"},{"location":"presets-monorepo/#monorepowordpress","text":"wordpress monorepo { \"matchPackagePatterns\": [ \"^@wordpress/\" ] }","title":"monorepo:wordpress"},{"location":"presets-monorepo/#monorepoangularmaterial","text":"angularmaterial monorepo { \"matchPackagePatterns\": [ \"^@angular/material\", \"^@angular/cdk\" ] }","title":"monorepo:angularmaterial"},{"location":"presets-monorepo/#monorepoaws-java-sdk","text":"aws-java-sdk monorepo { \"matchPackagePatterns\": [ \"^com.amazonaws:aws-java-sdk-\" ] }","title":"monorepo:aws-java-sdk"},{"location":"presets-monorepo/#monorepoembroider","text":"embroider monorepo { \"matchPackagePatterns\": [ \"^@embroider/\" ] }","title":"monorepo:embroider"},{"location":"presets-monorepo/#monorepofullcalendar","text":"fullcalendar monorepo { \"matchPackagePatterns\": [ \"^@fullcalendar/\" ] }","title":"monorepo:fullcalendar"},{"location":"presets-npm/","text":"npm:unpublishSafe Set a status check pending for 3 days from release timestamp to guard against npm unpublishing { \"npm\": { \"stabilityDays\": 3 } }","title":"Npm Presets"},{"location":"presets-npm/#npmunpublishsafe","text":"Set a status check pending for 3 days from release timestamp to guard against npm unpublishing { \"npm\": { \"stabilityDays\": 3 } }","title":"npm:unpublishSafe"},{"location":"presets-packages/","text":"packages:angularJs All angular.js packages { \"matchPackageNames\": [ \"angular\", \"angular-animate\", \"angular-scroll\", \"angular-sanitize\" ] } packages:apollographql All packages published by Apollo GraphQL { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/\" ] } packages:mapbox All mapbox-related packages { \"matchPackagePatterns\": [ \"^(leaflet|mapbox)\" ] } packages:emberTemplateLint All ember-template-lint packages { \"matchPackagePatterns\": [ \"^ember-template-lint\" ] } packages:eslint All eslint packages { \"matchPackageNames\": [ \"babel-eslint\" ], \"matchPackagePatterns\": [ \"^@typescript-eslint/\", \"^eslint\" ] } packages:stylelint All stylelint packages { \"matchPackagePatterns\": [ \"^stylelint\" ] } packages:tslint All tslint packages { \"matchPackageNames\": [ \"codelyzer\" ], \"matchPackagePatterns\": [ \"\\\\btslint\\\\b\" ] } packages:linters All lint-related packages { \"extends\": [ \"packages:emberTemplateLint\", \"packages:eslint\", \"packages:stylelint\", \"packages:tslint\" ], \"matchPackageNames\": [ \"remark-lint\" ] } packages:postcss All postcss packages { \"matchPackageNames\": [ \"postcss\" ], \"matchPackagePatterns\": [ \"^postcss-\" ] } packages:jsUnitTest Unit test packages for javascript { \"matchPackageNames\": [ \"coveralls\", \"ember-exam\", \"ember-mocha\", \"ember-qunit\", \"istanbul\", \"mock-fs\", \"nock\", \"nyc\", \"proxyquire\", \"supertest\" ], \"matchPackagePatterns\": [ \"^chai\", \"^jest\", \"^mocha\", \"^qunit\", \"^sinon\", \"^should\" ] } packages:unitTest All unit test packages { \"extends\": [ \"packages:jsUnitTest\" ] } packages:jsTest JavaScript test packages { \"extends\": [ \"packages:jsUnitTest\" ] } packages:test Test packages { \"extends\": [ \"packages:unitTest\" ] } packages:gatsby All packages published by Gatsby { \"extends\": [ \"monorepo:gatsby\" ] } packages:googleapis All googleapis packages { \"matchDatasources\": [ \"npm\" ], \"matchPackagePatterns\": [ \"^@google-cloud/\" ] }","title":"Package Presets"},{"location":"presets-packages/#packagesangularjs","text":"All angular.js packages { \"matchPackageNames\": [ \"angular\", \"angular-animate\", \"angular-scroll\", \"angular-sanitize\" ] }","title":"packages:angularJs"},{"location":"presets-packages/#packagesapollographql","text":"All packages published by Apollo GraphQL { \"matchSourceUrlPrefixes\": [ \"https://github.com/apollographql/\" ] }","title":"packages:apollographql"},{"location":"presets-packages/#packagesmapbox","text":"All mapbox-related packages { \"matchPackagePatterns\": [ \"^(leaflet|mapbox)\" ] }","title":"packages:mapbox"},{"location":"presets-packages/#packagesembertemplatelint","text":"All ember-template-lint packages { \"matchPackagePatterns\": [ \"^ember-template-lint\" ] }","title":"packages:emberTemplateLint"},{"location":"presets-packages/#packageseslint","text":"All eslint packages { \"matchPackageNames\": [ \"babel-eslint\" ], \"matchPackagePatterns\": [ \"^@typescript-eslint/\", \"^eslint\" ] }","title":"packages:eslint"},{"location":"presets-packages/#packagesstylelint","text":"All stylelint packages { \"matchPackagePatterns\": [ \"^stylelint\" ] }","title":"packages:stylelint"},{"location":"presets-packages/#packagestslint","text":"All tslint packages { \"matchPackageNames\": [ \"codelyzer\" ], \"matchPackagePatterns\": [ \"\\\\btslint\\\\b\" ] }","title":"packages:tslint"},{"location":"presets-packages/#packageslinters","text":"All lint-related packages { \"extends\": [ \"packages:emberTemplateLint\", \"packages:eslint\", \"packages:stylelint\", \"packages:tslint\" ], \"matchPackageNames\": [ \"remark-lint\" ] }","title":"packages:linters"},{"location":"presets-packages/#packagespostcss","text":"All postcss packages { \"matchPackageNames\": [ \"postcss\" ], \"matchPackagePatterns\": [ \"^postcss-\" ] }","title":"packages:postcss"},{"location":"presets-packages/#packagesjsunittest","text":"Unit test packages for javascript { \"matchPackageNames\": [ \"coveralls\", \"ember-exam\", \"ember-mocha\", \"ember-qunit\", \"istanbul\", \"mock-fs\", \"nock\", \"nyc\", \"proxyquire\", \"supertest\" ], \"matchPackagePatterns\": [ \"^chai\", \"^jest\", \"^mocha\", \"^qunit\", \"^sinon\", \"^should\" ] }","title":"packages:jsUnitTest"},{"location":"presets-packages/#packagesunittest","text":"All unit test packages { \"extends\": [ \"packages:jsUnitTest\" ] }","title":"packages:unitTest"},{"location":"presets-packages/#packagesjstest","text":"JavaScript test packages { \"extends\": [ \"packages:jsUnitTest\" ] }","title":"packages:jsTest"},{"location":"presets-packages/#packagestest","text":"Test packages { \"extends\": [ \"packages:unitTest\" ] }","title":"packages:test"},{"location":"presets-packages/#packagesgatsby","text":"All packages published by Gatsby { \"extends\": [ \"monorepo:gatsby\" ] }","title":"packages:gatsby"},{"location":"presets-packages/#packagesgoogleapis","text":"All googleapis packages { \"matchDatasources\": [ \"npm\" ], \"matchPackagePatterns\": [ \"^@google-cloud/\" ] }","title":"packages:googleapis"},{"location":"presets-preview/","text":"preview:dockerCompose Enable docker compose image updating { \"docker-compose\": { \"enabled\": true } } preview:dockerVersions Upgrade docker tags to newer versions { \"docker\": { \"major\": { \"enabled\": true }, \"minor\": { \"enabled\": true } } } preview:buildkite Enable buildkite functionality { \"buildkite\": { \"enabled\": true } }","title":"Preview Presets"},{"location":"presets-preview/#previewdockercompose","text":"Enable docker compose image updating { \"docker-compose\": { \"enabled\": true } }","title":"preview:dockerCompose"},{"location":"presets-preview/#previewdockerversions","text":"Upgrade docker tags to newer versions { \"docker\": { \"major\": { \"enabled\": true }, \"minor\": { \"enabled\": true } } }","title":"preview:dockerVersions"},{"location":"presets-preview/#previewbuildkite","text":"Enable buildkite functionality { \"buildkite\": { \"enabled\": true } }","title":"preview:buildkite"},{"location":"presets-regexManagers/","text":"regexManagers:dockerfileVersions Update _VERSION variables in Dockerfiles { \"regexManagers\": [ { \"fileMatch\": [ \"(^|/|\\\\.)Dockerfile$\", \"(^|/)Dockerfile\\\\.[^/]*$\" ], \"matchStrings\": [ \"# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>[^\\\\s]+?)(?: lookupName=(?<lookupName>[^\\\\s]+?))?(?: versioning=(?<versioning>[a-z-]+?))?\\\\s(?:ENV|ARG) .+?_VERSION=(?<currentValue>.+?)\\\\s\" ] } ] }","title":"RegexManager Presets"},{"location":"presets-regexManagers/#regexmanagersdockerfileversions","text":"Update _VERSION variables in Dockerfiles { \"regexManagers\": [ { \"fileMatch\": [ \"(^|/|\\\\.)Dockerfile$\", \"(^|/)Dockerfile\\\\.[^/]*$\" ], \"matchStrings\": [ \"# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>[^\\\\s]+?)(?: lookupName=(?<lookupName>[^\\\\s]+?))?(?: versioning=(?<versioning>[a-z-]+?))?\\\\s(?:ENV|ARG) .+?_VERSION=(?<currentValue>.+?)\\\\s\" ] } ] }","title":"regexManagers:dockerfileVersions"},{"location":"presets-schedule/","text":"schedule:earlyMondays Weekly schedule on early monday mornings { \"schedule\": [ \"before 3am on Monday\" ] } schedule:daily Schedule daily { \"schedule\": [ \"before 2am\" ] } schedule:weekly Schedule weekly { \"extends\": [ \"schedule:earlyMondays\" ] } schedule:monthly Schedule monthly { \"schedule\": [ \"before 3am on the first day of the month\" ] } schedule:quarterly Schedule quarterly { \"schedule\": [ \"every 3 months on the first day of the month\" ] } schedule:yearly Schedule once a year (not recommended) { \"schedule\": [ \"every 12 months on the first day of the month\" ] } schedule:weekends Schedule for weekends { \"schedule\": [ \"every weekend\" ] } schedule:weekdays Schedule for weekdays { \"schedule\": [ \"every weekday\" ] } schedule:nonOfficeHours Schedule for typical non-office hours (night time and weekends) { \"schedule\": [ \"after 10pm every weekday\", \"before 5am every weekday\", \"every weekend\" ] }","title":"Schedule Presets"},{"location":"presets-schedule/#scheduleearlymondays","text":"Weekly schedule on early monday mornings { \"schedule\": [ \"before 3am on Monday\" ] }","title":"schedule:earlyMondays"},{"location":"presets-schedule/#scheduledaily","text":"Schedule daily { \"schedule\": [ \"before 2am\" ] }","title":"schedule:daily"},{"location":"presets-schedule/#scheduleweekly","text":"Schedule weekly { \"extends\": [ \"schedule:earlyMondays\" ] }","title":"schedule:weekly"},{"location":"presets-schedule/#schedulemonthly","text":"Schedule monthly { \"schedule\": [ \"before 3am on the first day of the month\" ] }","title":"schedule:monthly"},{"location":"presets-schedule/#schedulequarterly","text":"Schedule quarterly { \"schedule\": [ \"every 3 months on the first day of the month\" ] }","title":"schedule:quarterly"},{"location":"presets-schedule/#scheduleyearly","text":"Schedule once a year (not recommended) { \"schedule\": [ \"every 12 months on the first day of the month\" ] }","title":"schedule:yearly"},{"location":"presets-schedule/#scheduleweekends","text":"Schedule for weekends { \"schedule\": [ \"every weekend\" ] }","title":"schedule:weekends"},{"location":"presets-schedule/#scheduleweekdays","text":"Schedule for weekdays { \"schedule\": [ \"every weekday\" ] }","title":"schedule:weekdays"},{"location":"presets-schedule/#schedulenonofficehours","text":"Schedule for typical non-office hours (night time and weekends) { \"schedule\": [ \"after 10pm every weekday\", \"before 5am every weekday\", \"every weekend\" ] }","title":"schedule:nonOfficeHours"},{"location":"presets-workarounds/","text":"workarounds:all A collection of workarounds for known problems with packages { \"extends\": [ \"workarounds:mavenCommonsAncientVersion\", \"workarounds:ignoreSpringCloudNumeric\", \"workarounds:ignoreHttp4sDigestMilestones\" ] } workarounds:mavenCommonsAncientVersion { \"packageRules\": [ { \"matchDatasources\": [ \"maven\", \"sbt-package\" ], \"matchPackagePatterns\": [ \"^commons-\" ], \"allowedVersions\": \"!/^200\\\\d{5}(\\\\.\\\\d+)?/\" } ] } workarounds:ignoreSpringCloudNumeric Ignore spring cloud 1.x releases { \"packageRules\": [ { \"matchDatasources\": [ \"maven\" ], \"matchPackageNames\": [ \"org.springframework.cloud:spring-cloud-starter-parent\" ], \"allowedVersions\": \"/^[A-Z]/\" } ] } workarounds:ignoreHttp4sDigestMilestones Ignore http4s digest-based 1.x milestones { \"packageRules\": [ { \"matchManagers\": [ \"sbt\" ], \"matchPackagePatterns\": [ \"^org\\\\.http4s:\" ], \"allowedVersions\": \"!/^1\\\\.0-\\\\d+-[a-fA-F0-9]{7}$/\" } ] }","title":"Workaround Presets"},{"location":"presets-workarounds/#workaroundsall","text":"A collection of workarounds for known problems with packages { \"extends\": [ \"workarounds:mavenCommonsAncientVersion\", \"workarounds:ignoreSpringCloudNumeric\", \"workarounds:ignoreHttp4sDigestMilestones\" ] }","title":"workarounds:all"},{"location":"presets-workarounds/#workaroundsmavencommonsancientversion","text":"{ \"packageRules\": [ { \"matchDatasources\": [ \"maven\", \"sbt-package\" ], \"matchPackagePatterns\": [ \"^commons-\" ], \"allowedVersions\": \"!/^200\\\\d{5}(\\\\.\\\\d+)?/\" } ] }","title":"workarounds:mavenCommonsAncientVersion"},{"location":"presets-workarounds/#workaroundsignorespringcloudnumeric","text":"Ignore spring cloud 1.x releases { \"packageRules\": [ { \"matchDatasources\": [ \"maven\" ], \"matchPackageNames\": [ \"org.springframework.cloud:spring-cloud-starter-parent\" ], \"allowedVersions\": \"/^[A-Z]/\" } ] }","title":"workarounds:ignoreSpringCloudNumeric"},{"location":"presets-workarounds/#workaroundsignorehttp4sdigestmilestones","text":"Ignore http4s digest-based 1.x milestones { \"packageRules\": [ { \"matchManagers\": [ \"sbt\" ], \"matchPackagePatterns\": [ \"^org\\\\.http4s:\" ], \"allowedVersions\": \"!/^1\\\\.0-\\\\d+-[a-fA-F0-9]{7}$/\" } ] }","title":"workarounds:ignoreHttp4sDigestMilestones"},{"location":"private-modules/","text":"Private npm module support When are npm private modules used? Private npm modules are used at two times during Renovate's process. 1. Module lookup If a private npm module is listed as a dependency in a package.json , then Renovate will attempt to keep it up-to-date by querying the npm registry like it would for any other package. Hence, by default with no configuration a private package lookup will fail, because of lack of credentials. This means it won't be \"renovated\" and its version will remain unchanged in the package file unless you update it manually. These failures don't affect Renovate's ability to look up other modules in the same package file. Assuming the private module lookup succeeds (solutions for that are described later in this document) then private package versions will be kept up-to-date like public package versions are. 2. Lock file generation If you are using a lock file (e.g. Yarn's yarn.lock or npm's package-lock.json ) then Renovate needs to update that lock file whenever any package listed in your package file is updated to a new version. To do this, Renovate will run npm install or equivalent and save the resulting lock file. If a private module hasn't been updated, it usually won't matter to npm/Yarn because they won't attempt to update its lock file entry anyway. However it's possible that the install will fail if it attempts to look up that private module for some reason, even when that private module is not the main one being updated. It's therefore better to provide Renovate with all the credentials it needs to look up private packages. Supported npm authentication approaches The recommended approaches in order of preference are: Self-hosted hostRules : Configure a hostRules entry in the bot's config.js with the hostType , hostName and token specified Self-hosted .npmrc : copy an .npmrc file to the home dir of the bot. Renovate App with private modules from npmjs.org : Add an encrypted npmToken to your Renovate config Renovate App with a private registry : Add an unencrypted npmrc plus an encrypted npmToken in config All the various approaches are described below: Add hostRule to bots config Define hostRules like this: module.exports = { hostRules: [ { hostType: 'npm', hostName: 'registry.npmjs.org', token: process.env.NPMJS_TOKEN, }, { hostType: 'npm', baseUrl: 'https://pkgs.dev.azure.com/{organization}/_packaging/{feed}/npm/registry/', username: 'VssSessionToken', password: process.env.AZURE_NPM_TOKEN, }, ], }; NOTE: Do not use NPM_TOKEN as an environment variable, it's incompatible with hostRules and will be deprecated soon. Commit .npmrc file into repository One approach that many projects use for private repositories is to simply check in an authenticated .npmrc into the repository that is then shared between all developers. Therefore anyone running npm install or yarn install from the project root will be automatically authenticated with npm without having to distribute npm logins to every developer and make sure they've run npm login first before installing. The good news is that this works for Renovate too. If Renovate detects a .npmrc or .yarnrc file then it will use it for its install. Does not work if using binarySource=docker. This method will be deprecated soon Add npmrc string to Renovate config The above solution maybe have a downside that all users of the repository (e.g. developers) will also use any .npmrc that is checked into the repository, instead of their own one in ~/.npmrc . To avoid this, you can instead add your .npmrc authentication line to your Renovate config under the field npmrc . e.g. a renovate.json might look like this: { \"npmrc\": \"//some.registry.com/:_authToken=abcdefghi-1234-jklmno-aac6-12345567889\" } If configured like this, Renovate will use this to authenticate with npm and will ignore any .npmrc files(s) it finds checked into the repository. Add npmToken to Renovate config If you are using the main npmjs registry then you can configure just the npmToken instead: { \"npmToken\": \"abcdefghi-1234-jklmno-aac6-12345567889\" } Add an encrypted npm token to Renovate config If you don't wish for all users of the repository to be able to see the unencrypted token, you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://renovatebot.com/encrypt , paste in your npm token, click \"Encrypt\", then copy the encrypted result. Add the encrypted result inside an encrypted object like this: { \"encrypted\": { \"npmToken\": \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" } } If you have no .npmrc file then Renovate will create one for you, pointing to the default npmjs registry. If instead you use an alternative registry or need an .npmrc file for some other reason, you should configure it too and substitute the npm token with ${NPM_TOKEN} for it to be replaced. e.g. { \"encrypted\": { \"npmToken\": \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" }, \"npmrc\": \"registry=https://my.custom.registry/npm\\n//my.custom.registry/npm:_authToken=${NPM_TOKEN}\" } Renovate will then use the following logic: If no npmrc string is present in config then one will be created with the _authToken pointing to the default npmjs registry If an npmrc string is present and contains ${NPM_TOKEN} then that placeholder will be replaced with the decrypted token If an npmrc string is present but doesn't contain ${NPM_TOKEN} then the file will have _authToken=<token> appended to it Encrypted entire .npmrc file into config Copy the entire .npmrc, replace newlines with \\n chars, and then try encrypting it at https://renovatebot.com/encrypt You will then get an encrypted string that you can substitute into your renovate.json instead. The result will now look something like this: { \"encrypted\": { \"npmrc\": \"WOTWu+jliBtXYz3CU2eI7dDyMIvSJKS2N5PEHZmLB3XKT3vLaaYTGCU6m92Q9FgdaM/q2wLYun2JrTP4GPaW8eGZ3iiG1cm7lgOR5xPnkCzz0DUmSf6Cc/6geeVeSFdJ0zqlEAhdNMyJ4pUW6iQxC3WJKgM/ADvFtme077Acvc0fhCXv0XvbNSbtUwHF/gD6OJ0r2qlIzUMGJk/eI254xo5SwWVctc1iZS9LW+L0/CKjqhWh4SbyglP3lKE5shg3q7mzWDZepa/nJmAnNmXdoVO2aPPeQCG3BKqCtCfvLUUU/0LvnJ2SbQ1obyzL7vhh2OF/VsATS5cxbHvoX/hxWQ==\" } } However be aware that if your .npmrc is too long to encrypt then the above command will fail.","title":"Private npm module support"},{"location":"private-modules/#private-npm-module-support","text":"","title":"Private npm module support"},{"location":"private-modules/#when-are-npm-private-modules-used","text":"Private npm modules are used at two times during Renovate's process.","title":"When are npm private modules used?"},{"location":"private-modules/#1-module-lookup","text":"If a private npm module is listed as a dependency in a package.json , then Renovate will attempt to keep it up-to-date by querying the npm registry like it would for any other package. Hence, by default with no configuration a private package lookup will fail, because of lack of credentials. This means it won't be \"renovated\" and its version will remain unchanged in the package file unless you update it manually. These failures don't affect Renovate's ability to look up other modules in the same package file. Assuming the private module lookup succeeds (solutions for that are described later in this document) then private package versions will be kept up-to-date like public package versions are.","title":"1. Module lookup"},{"location":"private-modules/#2-lock-file-generation","text":"If you are using a lock file (e.g. Yarn's yarn.lock or npm's package-lock.json ) then Renovate needs to update that lock file whenever any package listed in your package file is updated to a new version. To do this, Renovate will run npm install or equivalent and save the resulting lock file. If a private module hasn't been updated, it usually won't matter to npm/Yarn because they won't attempt to update its lock file entry anyway. However it's possible that the install will fail if it attempts to look up that private module for some reason, even when that private module is not the main one being updated. It's therefore better to provide Renovate with all the credentials it needs to look up private packages.","title":"2. Lock file generation"},{"location":"private-modules/#supported-npm-authentication-approaches","text":"The recommended approaches in order of preference are: Self-hosted hostRules : Configure a hostRules entry in the bot's config.js with the hostType , hostName and token specified Self-hosted .npmrc : copy an .npmrc file to the home dir of the bot. Renovate App with private modules from npmjs.org : Add an encrypted npmToken to your Renovate config Renovate App with a private registry : Add an unencrypted npmrc plus an encrypted npmToken in config All the various approaches are described below:","title":"Supported npm authentication approaches"},{"location":"private-modules/#add-hostrule-to-bots-config","text":"Define hostRules like this: module.exports = { hostRules: [ { hostType: 'npm', hostName: 'registry.npmjs.org', token: process.env.NPMJS_TOKEN, }, { hostType: 'npm', baseUrl: 'https://pkgs.dev.azure.com/{organization}/_packaging/{feed}/npm/registry/', username: 'VssSessionToken', password: process.env.AZURE_NPM_TOKEN, }, ], }; NOTE: Do not use NPM_TOKEN as an environment variable, it's incompatible with hostRules and will be deprecated soon.","title":"Add hostRule to bots config"},{"location":"private-modules/#commit-npmrc-file-into-repository","text":"One approach that many projects use for private repositories is to simply check in an authenticated .npmrc into the repository that is then shared between all developers. Therefore anyone running npm install or yarn install from the project root will be automatically authenticated with npm without having to distribute npm logins to every developer and make sure they've run npm login first before installing. The good news is that this works for Renovate too. If Renovate detects a .npmrc or .yarnrc file then it will use it for its install. Does not work if using binarySource=docker. This method will be deprecated soon","title":"Commit .npmrc file into repository"},{"location":"private-modules/#add-npmrc-string-to-renovate-config","text":"The above solution maybe have a downside that all users of the repository (e.g. developers) will also use any .npmrc that is checked into the repository, instead of their own one in ~/.npmrc . To avoid this, you can instead add your .npmrc authentication line to your Renovate config under the field npmrc . e.g. a renovate.json might look like this: { \"npmrc\": \"//some.registry.com/:_authToken=abcdefghi-1234-jklmno-aac6-12345567889\" } If configured like this, Renovate will use this to authenticate with npm and will ignore any .npmrc files(s) it finds checked into the repository.","title":"Add npmrc string to Renovate config"},{"location":"private-modules/#add-npmtoken-to-renovate-config","text":"If you are using the main npmjs registry then you can configure just the npmToken instead: { \"npmToken\": \"abcdefghi-1234-jklmno-aac6-12345567889\" }","title":"Add npmToken to Renovate config"},{"location":"private-modules/#add-an-encrypted-npm-token-to-renovate-config","text":"If you don't wish for all users of the repository to be able to see the unencrypted token, you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://renovatebot.com/encrypt , paste in your npm token, click \"Encrypt\", then copy the encrypted result. Add the encrypted result inside an encrypted object like this: { \"encrypted\": { \"npmToken\": \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" } } If you have no .npmrc file then Renovate will create one for you, pointing to the default npmjs registry. If instead you use an alternative registry or need an .npmrc file for some other reason, you should configure it too and substitute the npm token with ${NPM_TOKEN} for it to be replaced. e.g. { \"encrypted\": { \"npmToken\": \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" }, \"npmrc\": \"registry=https://my.custom.registry/npm\\n//my.custom.registry/npm:_authToken=${NPM_TOKEN}\" } Renovate will then use the following logic: If no npmrc string is present in config then one will be created with the _authToken pointing to the default npmjs registry If an npmrc string is present and contains ${NPM_TOKEN} then that placeholder will be replaced with the decrypted token If an npmrc string is present but doesn't contain ${NPM_TOKEN} then the file will have _authToken=<token> appended to it","title":"Add an encrypted npm token to Renovate config"},{"location":"private-modules/#encrypted-entire-npmrc-file-into-config","text":"Copy the entire .npmrc, replace newlines with \\n chars, and then try encrypting it at https://renovatebot.com/encrypt You will then get an encrypted string that you can substitute into your renovate.json instead. The result will now look something like this: { \"encrypted\": { \"npmrc\": \"WOTWu+jliBtXYz3CU2eI7dDyMIvSJKS2N5PEHZmLB3XKT3vLaaYTGCU6m92Q9FgdaM/q2wLYun2JrTP4GPaW8eGZ3iiG1cm7lgOR5xPnkCzz0DUmSf6Cc/6geeVeSFdJ0zqlEAhdNMyJ4pUW6iQxC3WJKgM/ADvFtme077Acvc0fhCXv0XvbNSbtUwHF/gD6OJ0r2qlIzUMGJk/eI254xo5SwWVctc1iZS9LW+L0/CKjqhWh4SbyglP3lKE5shg3q7mzWDZepa/nJmAnNmXdoVO2aPPeQCG3BKqCtCfvLUUU/0LvnJ2SbQ1obyzL7vhh2OF/VsATS5cxbHvoX/hxWQ==\" } } However be aware that if your .npmrc is too long to encrypt then the above command will fail.","title":"Encrypted entire .npmrc file into config"},{"location":"python/","text":"Python package manager support Renovate supports the following Python package managers: pip (e.g. requirements.txt , requirements.pip ) files pipenv (e.g. Pipfile ) setup.py Versioning support The PEP440 versioning scheme has been rewritten for JavaScript for the purposes of use in this project is published as @renovatebot/pep440 . It supports both pinned versions as well as ranges. Legacy versions ( === prefix) are ignored. How it works Renovate searches through each repository for package files Existing dependencies are extracted from the package files Renovate looks up the latest version on PyPI to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has a \"changelog\" file or uses GitHub releases, a Release Note will be embedded in the generated PR Alternative file names The default file matching regex for requirements.txt aims to pick up the most popular conventions for file naming, but it's possible that some get missed. If you have a specific file or file pattern you want the Renovate bot to find, use the fileMatch field in the pip_requirements object. e.g.: \"pip_requirements\": { \"fileMatch\": [\"my/specifically-named.file\", \"\\.requirements$\"] } Alternate registries By default Renovate performs all lookups on pypi.org, but you can configure alternative index URLs. There are two ways to do this: index-url in requirements.txt The index URL can be specified in the first line of the file. For example: --index-url http://example.com/private-pypi/ some-package==0.3.1 some-other-package==1.0.0 Sources in Pipfile Renovate detects any custom-configured sources in Pipfile and uses them. Specify URL in configuration You can use the registryUrls array to configure alternate index URL(s). e.g.: \"python\": { \"registryUrls\": [\"http://example.com/private-pypi/\"] } Note: the index-url found in the requirements.txt file takes precedence over a registryUrl configured like the above. To override the URL found in requirements.txt , you need to configure it in packageRules , as they are applied after package file extraction. Disabling Python support The most direct way to disable all Python support in Renovate is like this: \"python\": { \"enabled\": false } Alternatively, maybe you only want one package manager, such as npm . In that case this would enable only npm : \"enabledManagers\": [\"npm\"]","title":"Python"},{"location":"python/#python-package-manager-support","text":"Renovate supports the following Python package managers: pip (e.g. requirements.txt , requirements.pip ) files pipenv (e.g. Pipfile ) setup.py","title":"Python package manager support"},{"location":"python/#versioning-support","text":"The PEP440 versioning scheme has been rewritten for JavaScript for the purposes of use in this project is published as @renovatebot/pep440 . It supports both pinned versions as well as ranges. Legacy versions ( === prefix) are ignored.","title":"Versioning support"},{"location":"python/#how-it-works","text":"Renovate searches through each repository for package files Existing dependencies are extracted from the package files Renovate looks up the latest version on PyPI to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has a \"changelog\" file or uses GitHub releases, a Release Note will be embedded in the generated PR","title":"How it works"},{"location":"python/#alternative-file-names","text":"The default file matching regex for requirements.txt aims to pick up the most popular conventions for file naming, but it's possible that some get missed. If you have a specific file or file pattern you want the Renovate bot to find, use the fileMatch field in the pip_requirements object. e.g.: \"pip_requirements\": { \"fileMatch\": [\"my/specifically-named.file\", \"\\.requirements$\"] }","title":"Alternative file names"},{"location":"python/#alternate-registries","text":"By default Renovate performs all lookups on pypi.org, but you can configure alternative index URLs. There are two ways to do this:","title":"Alternate registries"},{"location":"python/#index-url-in-requirementstxt","text":"The index URL can be specified in the first line of the file. For example: --index-url http://example.com/private-pypi/ some-package==0.3.1 some-other-package==1.0.0","title":"index-url in requirements.txt"},{"location":"python/#sources-in-pipfile","text":"Renovate detects any custom-configured sources in Pipfile and uses them.","title":"Sources in Pipfile"},{"location":"python/#specify-url-in-configuration","text":"You can use the registryUrls array to configure alternate index URL(s). e.g.: \"python\": { \"registryUrls\": [\"http://example.com/private-pypi/\"] } Note: the index-url found in the requirements.txt file takes precedence over a registryUrl configured like the above. To override the URL found in requirements.txt , you need to configure it in packageRules , as they are applied after package file extraction.","title":"Specify URL in configuration"},{"location":"python/#disabling-python-support","text":"The most direct way to disable all Python support in Renovate is like this: \"python\": { \"enabled\": false } Alternatively, maybe you only want one package manager, such as npm . In that case this would enable only npm : \"enabledManagers\": [\"npm\"]","title":"Disabling Python support"},{"location":"reconfigure-renovate/","text":"Reconfiguring Renovate There will be times when you need to change your Renovate config. There are two recommended approaches: Reconfigure via PR Nuke the config and re-onboard Reconfigure via PR If you want to make config edits directly, follow these steps: Create a new Git branch to work on Install the renovate package globally ( npm i -g renovate or yarn global add renovate ) to get the renovate-config-validator program Edit your Renovate configuration file Validate your config by running renovate-config-validator If the improved config passes the validation, merge the branch into your mainline branch Nuke config and re-onboard Perhaps you really liked the interactive onboarding PR and want to use it again. You can follow the steps below to nuke the config and get a new PR. Any existing Renovate PRs will be closed after you've completed these steps. Find your original Configure Renovate PR Rename the original PR to something else, e.g. Configure Renovate - old Remove the current Renovate configuration file (e.g. renovate.json ) from your mainline branch Following these steps will trick Renovate into thinking that your repository was never onboarded, and will trigger a new \"Configure Renovate\" PR. Renovate config file validation when using CircleCI If you use CircleCI, you can use the third-party daniel-shuy/renovate orb to validate your config as part of your workflow, e.g. version: '2.1' orbs: renovate: daniel-shuy/renovate@2.1 workflows: lint: jobs: - renovate/validate-config","title":"Reconfiguring Renovate"},{"location":"reconfigure-renovate/#reconfiguring-renovate","text":"There will be times when you need to change your Renovate config. There are two recommended approaches: Reconfigure via PR Nuke the config and re-onboard","title":"Reconfiguring Renovate"},{"location":"reconfigure-renovate/#reconfigure-via-pr","text":"If you want to make config edits directly, follow these steps: Create a new Git branch to work on Install the renovate package globally ( npm i -g renovate or yarn global add renovate ) to get the renovate-config-validator program Edit your Renovate configuration file Validate your config by running renovate-config-validator If the improved config passes the validation, merge the branch into your mainline branch","title":"Reconfigure via PR"},{"location":"reconfigure-renovate/#nuke-config-and-re-onboard","text":"Perhaps you really liked the interactive onboarding PR and want to use it again. You can follow the steps below to nuke the config and get a new PR. Any existing Renovate PRs will be closed after you've completed these steps. Find your original Configure Renovate PR Rename the original PR to something else, e.g. Configure Renovate - old Remove the current Renovate configuration file (e.g. renovate.json ) from your mainline branch Following these steps will trick Renovate into thinking that your repository was never onboarded, and will trigger a new \"Configure Renovate\" PR.","title":"Nuke config and re-onboard"},{"location":"reconfigure-renovate/#renovate-config-file-validation-when-using-circleci","text":"If you use CircleCI, you can use the third-party daniel-shuy/renovate orb to validate your config as part of your workflow, e.g. version: '2.1' orbs: renovate: daniel-shuy/renovate@2.1 workflows: lint: jobs: - renovate/validate-config","title":"Renovate config file validation when using CircleCI"},{"location":"ruby/","text":"Automated dependency updates for Ruby Bundler dependencies Renovate supports upgrading dependencies in Bundler's Gemfiles and their accompanying Gemfile.lock files. How it works Renovate searches in each repository for any Gemfiles Existing dependencies are extracted from the Gemfiles Renovate resolves the dependency on Rubygems.org (or elsewhere if configured), and checks for newer versions A PR is created which updates the Gemfile and Gemfile.lock in a single commit If the source repository has a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR Enabling You can install the Renovate App on GitHub. Or you can check out Renovate OSS to self-host Renovate.","title":"Ruby"},{"location":"ruby/#automated-dependency-updates-for-ruby-bundler-dependencies","text":"Renovate supports upgrading dependencies in Bundler's Gemfiles and their accompanying Gemfile.lock files.","title":"Automated dependency updates for Ruby Bundler dependencies"},{"location":"ruby/#how-it-works","text":"Renovate searches in each repository for any Gemfiles Existing dependencies are extracted from the Gemfiles Renovate resolves the dependency on Rubygems.org (or elsewhere if configured), and checks for newer versions A PR is created which updates the Gemfile and Gemfile.lock in a single commit If the source repository has a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR","title":"How it works"},{"location":"ruby/#enabling","text":"You can install the Renovate App on GitHub. Or you can check out Renovate OSS to self-host Renovate.","title":"Enabling"},{"location":"rust/","text":"Automated Dependency Updates for Rust crates Renovate supports upgrading dependencies in Cargo.toml files and their accompanying Cargo.lock checksums. How it works Renovate searches in each repository for any Cargo.toml files Renovate extracts existing dependencies from [dependencies] , [dev-dependencies] and [build-dependencies] Renovate attempts to find and parse a .cargo/config.toml file to discover index URLs for private registries Renovate resolves the dependency's version using the crates.io API or by cloning the index URL If Renovate finds an update, Renovate will use cargo update to update both Cargo.toml and Cargo.lock Enabling Rust Modules Updating Renovate updates Rust crates by default. Private crate registries and private git dependencies If any dependencies are hosted in private git repositories, Git Authentication for cargo must be set up. If any dependencies are hosted on private crate registries (ie., not on crates.io ), then credentials should be set up in such a way that the Git command-line is able to clone the registry index. Third-party crate registries usually provide instructions to achieve this. Both of these are currently only possible when running Renovate self-hosted.","title":"Rust crates"},{"location":"rust/#automated-dependency-updates-for-rust-crates","text":"Renovate supports upgrading dependencies in Cargo.toml files and their accompanying Cargo.lock checksums.","title":"Automated Dependency Updates for Rust crates"},{"location":"rust/#how-it-works","text":"Renovate searches in each repository for any Cargo.toml files Renovate extracts existing dependencies from [dependencies] , [dev-dependencies] and [build-dependencies] Renovate attempts to find and parse a .cargo/config.toml file to discover index URLs for private registries Renovate resolves the dependency's version using the crates.io API or by cloning the index URL If Renovate finds an update, Renovate will use cargo update to update both Cargo.toml and Cargo.lock","title":"How it works"},{"location":"rust/#enabling-rust-modules-updating","text":"Renovate updates Rust crates by default.","title":"Enabling Rust Modules Updating"},{"location":"rust/#private-crate-registries-and-private-git-dependencies","text":"If any dependencies are hosted in private git repositories, Git Authentication for cargo must be set up. If any dependencies are hosted on private crate registries (ie., not on crates.io ), then credentials should be set up in such a way that the Git command-line is able to clone the registry index. Third-party crate registries usually provide instructions to achieve this. Both of these are currently only possible when running Renovate self-hosted.","title":"Private crate registries and private git dependencies"},{"location":"self-hosted-configuration/","text":"Self-Hosted Configuration Options The below configuration options are applicable only if you are running your own instance (\"bot\") of Renovate. allowPostUpgradeCommandTemplating If true allow templating for post-upgrade commands. Name Value type boolean default false If true allow templating for post-upgrade commands. Let's look at an example of configuring packages with existing Angular migrations. Add two properties to config.js : allowPostUpgradeCommandTemplating and allowedPostUpgradeCommands module.exports = { allowPostUpgradeCommandTemplating: true, allowedPostUpgradeCommands: ['^npm ci --ignore-scripts$', '^npx ng update'], }; In the renovate.json file, define the commands and files to be included in the final commit. The command to install dependencies is necessary because, by default, the installation of dependencies is skipped (see the skipInstalls admin option) { \"packageRules\": [ { \"matchPackageNames\": [\"@angular/core\"], \"postUpgradeTasks\": { \"commands\": [ \"npm ci --ignore-scripts\", \"npx ng update {{{depName}}} --from={{{currentVersion}}} --to={{{newVersion}}} --migrateOnly --allowDirty --force\" ], \"fileFilters\": [\"**/**\"] } } ] } With this configuration, the executable command for @angular/core will look like this npm ci --ignore-scripts npx ng update @angular/core --from=9.0.0 --to=10.0.0 --migrateOnly --allowDirty --force allowedPostUpgradeCommands A list of regular expressions that determine which post-upgrade tasks are allowed. Name Value type array subType string A list of regular expressions that determine which commands in postUpgradeTasks are allowed to be executed. If this list is empty then no tasks will be executed. Also you need to have \"trustLevel\": \"high\" , otherwise these tasks will be ignored. e.g. { \"allowedPostUpgradeCommands\": [\"^tslint --fix$\", \"^tslint --[a-z]+$\"], \"trustLevel\": \"high\" } autodiscover Autodiscover all repositories. Name Value type boolean default false Be cautious when using this option - it will run Renovate over every repository that the bot account has access to. To filter this list, use autodiscoverFilter . autodiscoverFilter Filter the list of autodiscovered repositories. Name Value type string A minimatch glob-style pattern for filtering autodiscover ed repositories. Ex: project/* baseDir The base directory for Renovate to store local files, including repository files and cache. If left empty, Renovate will create its own temporary directory to use. Name Value type string default null Configure this directory if you want to change which directory Renovate uses for storing data. If left unconfigured, it will typically be a temporary directory like /tmp/renovate/ . binarySource Controls whether third party tools like npm or Gradle are called directly, or via Docker sidecar containers. Name Value type string allowedValues global,docker default \"global\" Set this to global if you wish Renovate to use globally-installed binaries ( npm , yarn , etc) instead of using its bundled versions. Set this to docker instead to use Docker-based binaries. cacheDir The directory for Renovate for storing caches. If left empty, Renovate will create a subdirectory within baseDir to use. Name Value type string default null Configure this directory if you want to change which directory Renovate uses for storing cache data. If left unconfigured, it will typically be a temporary directory like /tmp/renovate/cache/ . If you configure this to be different to the baseDir , it means you can have one location for repo data and another for cache data. composerIgnorePlatformReqs Enable / disable use of --ignore-platform-reqs in the Composer package manager. Name Value type boolean default true Set to false to prevent usage of --ignore-platform-reqs in the Composer package manager. customEnvVariables Custom environment variables for child processes and sidecar Docker containers. Name Value type object default false This configuration will be applied after all other environment variables so that it can be used to override defaults. dockerImagePrefix Change this value in order to override the default Renovate Docker sidecar image name prefix. Name Value type string default \"docker.io/renovate\" Override the default renovate sidecar Docker containers image prefix from docker.io/renovate to a custom value, so renovate will pull images from a custom Docker registry. If this is set to ghcr.io/renovatebot the final image for node would become ghcr.io/renovatebot/node instead of currently used docker.io/renovate/node . dockerMapDotfiles Map relevant home directory dotfiles into containers when binarySource=docker. Name Value type boolean default false This is used if you want to map \"dotfiles\" from your host computer home directory to containers that Renovate creates, e.g. for updating lock files. Currently applicable to .npmrc only. dockerUser Specify UID and GID for Docker-based binaries when binarySource=docker is used. Name Value type string default null Override default user and group used by Docker-based binaries. UID and GID should match the user that executes renovate. See Docker run reference for more information on user and group syntax. Set this to 1001:1002 to use UID 1001 and GID 1002. dryRun If enabled, perform a dry run by logging messages instead of creating/updating/deleting branches and PRs. Name Value type boolean default false endpoint Custom endpoint to use. Name Value type string force Any configuration defined within this object will force override existing settings. Name Value type object This object is used as a \"force override\" when you need to make sure certain configuration overrides whatever is configured in the repository. For example, forcing a null (no) schedule to make sure Renovate raises PRs on a run even if the repository itself or its preset defines a schedule that's currently in active. In practice, it is implemented by converting the force configuration into a packageRule that matches all packages. forceCli Whether CLI configuration options should be moved to the force config section. Name Value type boolean default true This is set to true by default, meaning that any settings (such as schedule ) take maximum priority even against custom settings existing inside individual repositories. It will also override any settings in packageRules . forkMode Set to true to fork the source repository and create branches there instead. Name Value type boolean default false You probably have no need for this option - it is an experimental setting for the Renovate hosted GitHub App. gitAuthor Author to use for Git commits. Must conform to RFC5322. Name Value type string default null RFC5322-compliant string if you wish to customise the Git author for commits. If you need to transition from one Git author to another, put the old gitAuthor into RENOVATE_LEGACY_GIT_AUTHOR_EMAIL in environment. Renovate will then check against it as well as the current Git author value before deciding if a branch has been modified. Note It is strongly recommended that the Git author email you provide should be unique to Renovate. Otherwise, if another bot or human shares the same email and pushes to one of Renovate's branches then Renovate will mistake the branch as unmodified and potentially force push over the changes. gitPrivateKey PGP key to use for signing Git commits. Name Value type string default null This should be an armored private key, e.g. the type you get from running gpg --export-secret-keys --armor 92066A17F0D1707B4E96863955FEF5171C45FAE5 > private.key . Replace the newlines with \\n before adding the resulting single-line value to your bot's config. It will be loaded lazily . Before the first commit in a repository, Renovate will: First, run gpg import if it hasn't been run before Then, run git config user.signingkey and git config commit.gpgsign true The git commands are run locally in the cloned repo instead of globally to reduce the chance of causing unintended consequences with global Git configs on shared systems. logContext Add a global or per-repo log context to each log entry. Name Value type string logContext is included with each log entry only if logFormat=\"json\" - it is not included in the pretty log output. If left as default (null), a random short ID will be selected. logFile Log file path. Name Value type string default null logFileLevel Log file log level. Name Value type string default \"debug\" logLevel Logging level. Deprecated, use LOG_LEVEL environment. Name Value type string allowedValues fatal,error,warn,info,debug,trace default null It's recommended to run at debug level if you can, and configure it using the environment variable LOG_LEVEL=debug . By configuring using the environment it means that debug logging starts from the beginning of the app, while if you configure it using file config then the debug logging can only start after the file config is parsed. Additionally, if you configure LOG_FORMAT=json in env then logging will be done in JSON format instead of \"pretty\" format, which is usually better if you're doing any ingestion or parsing of the logs. Warning: Configuring logLevel config option or --log-level cli option is deprecated and will be removed in a major version. onboarding Require a Configuration PR first. Name Value type boolean default true Set this to false if (a) you configure Renovate entirely on the bot side (i.e. empty renovate.json in repositories) and (b) you wish to run Renovate on every repository the bot has access to, and (c) you wish to skip the onboarding PRs. onboardingBranch Change this value in order to override the default onboarding branch name. Name Value type string default \"renovate/configure\" Note that this setting is independent of branchPrefix . For example, if you configure branchPrefix to be renovate- then you'd still have the onboarding PR created with branch renovate/configure until you configure onboardingBranch=renovate-configure or similar. If you have an existing Renovate installation and you change onboardingBranch then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged. onboardingCommitMessage Change this value in order to override the default onboarding commit message. Name Value type string Note that if commitMessagePrefix or semanticCommits values are defined then they will be prepended to the commit message using the same logic that is used for adding them to non-onboarding commit messages. onboardingConfig Configuration to use in onboarding PRs. Name Value type object mergeable true onboardingConfigFileName Change this value in order to override the default onboarding config file name. Name Value type string default \"renovate.json\" If set to one of the valid config file names , the onboarding PR will create a configuration file with the provided name instead of renovate.json . Falls back to renovate.json if the name provided is not valid. onboardingPrTitle Change this value in order to override the default onboarding PR title. Name Value type string default \"Configure Renovate\" Similarly to onboardingBranch , if you have an existing Renovate installation and you change onboardingPrTitle then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged. optimizeForDisabled Set to true to first check for disabling in config before cloning. Name Value type boolean default false password Password for authentication. Currently Bitbucket only (AppPassword). Name Value type string default null persistRepoData If set to true, repository data will preserved between runs instead of deleted. Name Value type boolean default false Set this to true if you wish for Renovate to persist repo data between runs. The intention is that this allows Renovate to do a faster git fetch between runs rather than git clone . It also may mean that ignored directories like node_modules can be preserved and save time on operations like npm install . platform Platform type of repository. Name Value type string allowedValues azure,bitbucket,bitbucket-server,gitea,github,gitlab default \"github\" prCommitsPerRunLimit Set a maximum number of commits per Renovate run. Default is no limit. Name Value type integer default 0 Parameter to reduce CI load. CI jobs are usually triggered by these events: pull-request creation, pull-request update, automerge events. Set as an integer. Default is no limit. printConfig If enabled, log the full resolved config for each repo, including resolved presets. Name Value type boolean default false This option is useful for troubleshooting, particularly if using presets. e.g. run renovate foo/bar --print-config > config.log and the fully-resolved config will be included in the log file. privateKey Server-side private key. Name Value type string replaceLineReturns true default null This private key is used to decrypt config files. The corresponding public key can be used to create encrypted values for config files. If you want a simple UI to encrypt values you can put the public key in a HTML page similar to https://renovatebot.com/encrypt . To create the key pair with openssl use the following commands: openssl genrsa -out rsa_priv.pem 4096 for generating the private key openssl rsa -pubout -in rsa_priv.pem -out rsa_pub.pem for extracting the public key privateKeyPath Path to the Server-side private key. Name Value type string default null Used as an alternative to privateKey , if you wish for the key to be read from disk instead. productLinks Links which are embedded within PRs, issues, etc. Name Value type object mergeable true additionalProperties [object Object] Override this object if you wish to change the URLs that Renovate links to, e.g. if you have an internal forum for asking for help. redisUrl If defined, this Redis URL will be used for caching instead of the file system. Name Value type string default null If this value is set then Renovate will use Redis for its global cache instead of the local file system. The global cache is used to store lookup results (e.g. dependency versions and release notes) between repositories and runs. Example url: redis://localhost . repositories List of Repositories. Name Value type array repositoryCache Option to do repository extract caching. Name Value type string allowedValues disabled,enabled,reset default \"disabled\" Set this to \"enabled\" to have Renovate maintain a JSON file cache per-repository to speed up extractions. Set to \"reset\" if you ever need to bypass the cache and have it overwritten. JSON files will be stored inside the cacheDir beside the existing file-based package cache. Warning: this is an experimental feature and may be modified or removed in a future non-major release. requireConfig Set to true if repositories must have a config to activate. Name Value type boolean default true skipInstalls Skip installing modules/dependencies if lock file updating is possible alone. Name Value type boolean default null By default, Renovate will use the most efficient approach to updating package files and lock files, which in most cases skips the need to perform a full module install by the bot. If this is set to false, then a full install of modules will be done. This is currently applicable to npm and lerna / npm only, and only used in cases where bugs in npm result in incorrect lock files being updated. token Repository Auth Token. Name Value type string default null trustLevel Set this to \"high\" if the bot should trust the repository owners/contents. Name Value type string default \"low\" Setting trustLevel to \"high\" can make sense in many self-hosted cases where the bot operator trusts the content in each repository. Setting trustLevel=high means: Child processes are run with full access to env .npmrc files can have environment variable substitution performed username Username for authentication. Currently Bitbucket only. Name Value type string default null","title":"Self Hosted Configuration"},{"location":"self-hosted-configuration/#self-hosted-configuration-options","text":"The below configuration options are applicable only if you are running your own instance (\"bot\") of Renovate.","title":"Self-Hosted Configuration Options"},{"location":"self-hosted-configuration/#allowpostupgradecommandtemplating","text":"If true allow templating for post-upgrade commands. Name Value type boolean default false If true allow templating for post-upgrade commands. Let's look at an example of configuring packages with existing Angular migrations. Add two properties to config.js : allowPostUpgradeCommandTemplating and allowedPostUpgradeCommands module.exports = { allowPostUpgradeCommandTemplating: true, allowedPostUpgradeCommands: ['^npm ci --ignore-scripts$', '^npx ng update'], }; In the renovate.json file, define the commands and files to be included in the final commit. The command to install dependencies is necessary because, by default, the installation of dependencies is skipped (see the skipInstalls admin option) { \"packageRules\": [ { \"matchPackageNames\": [\"@angular/core\"], \"postUpgradeTasks\": { \"commands\": [ \"npm ci --ignore-scripts\", \"npx ng update {{{depName}}} --from={{{currentVersion}}} --to={{{newVersion}}} --migrateOnly --allowDirty --force\" ], \"fileFilters\": [\"**/**\"] } } ] } With this configuration, the executable command for @angular/core will look like this npm ci --ignore-scripts npx ng update @angular/core --from=9.0.0 --to=10.0.0 --migrateOnly --allowDirty --force","title":"allowPostUpgradeCommandTemplating"},{"location":"self-hosted-configuration/#allowedpostupgradecommands","text":"A list of regular expressions that determine which post-upgrade tasks are allowed. Name Value type array subType string A list of regular expressions that determine which commands in postUpgradeTasks are allowed to be executed. If this list is empty then no tasks will be executed. Also you need to have \"trustLevel\": \"high\" , otherwise these tasks will be ignored. e.g. { \"allowedPostUpgradeCommands\": [\"^tslint --fix$\", \"^tslint --[a-z]+$\"], \"trustLevel\": \"high\" }","title":"allowedPostUpgradeCommands"},{"location":"self-hosted-configuration/#autodiscover","text":"Autodiscover all repositories. Name Value type boolean default false Be cautious when using this option - it will run Renovate over every repository that the bot account has access to. To filter this list, use autodiscoverFilter .","title":"autodiscover"},{"location":"self-hosted-configuration/#autodiscoverfilter","text":"Filter the list of autodiscovered repositories. Name Value type string A minimatch glob-style pattern for filtering autodiscover ed repositories. Ex: project/*","title":"autodiscoverFilter"},{"location":"self-hosted-configuration/#basedir","text":"The base directory for Renovate to store local files, including repository files and cache. If left empty, Renovate will create its own temporary directory to use. Name Value type string default null Configure this directory if you want to change which directory Renovate uses for storing data. If left unconfigured, it will typically be a temporary directory like /tmp/renovate/ .","title":"baseDir"},{"location":"self-hosted-configuration/#binarysource","text":"Controls whether third party tools like npm or Gradle are called directly, or via Docker sidecar containers. Name Value type string allowedValues global,docker default \"global\" Set this to global if you wish Renovate to use globally-installed binaries ( npm , yarn , etc) instead of using its bundled versions. Set this to docker instead to use Docker-based binaries.","title":"binarySource"},{"location":"self-hosted-configuration/#cachedir","text":"The directory for Renovate for storing caches. If left empty, Renovate will create a subdirectory within baseDir to use. Name Value type string default null Configure this directory if you want to change which directory Renovate uses for storing cache data. If left unconfigured, it will typically be a temporary directory like /tmp/renovate/cache/ . If you configure this to be different to the baseDir , it means you can have one location for repo data and another for cache data.","title":"cacheDir"},{"location":"self-hosted-configuration/#composerignoreplatformreqs","text":"Enable / disable use of --ignore-platform-reqs in the Composer package manager. Name Value type boolean default true Set to false to prevent usage of --ignore-platform-reqs in the Composer package manager.","title":"composerIgnorePlatformReqs"},{"location":"self-hosted-configuration/#customenvvariables","text":"Custom environment variables for child processes and sidecar Docker containers. Name Value type object default false This configuration will be applied after all other environment variables so that it can be used to override defaults.","title":"customEnvVariables"},{"location":"self-hosted-configuration/#dockerimageprefix","text":"Change this value in order to override the default Renovate Docker sidecar image name prefix. Name Value type string default \"docker.io/renovate\" Override the default renovate sidecar Docker containers image prefix from docker.io/renovate to a custom value, so renovate will pull images from a custom Docker registry. If this is set to ghcr.io/renovatebot the final image for node would become ghcr.io/renovatebot/node instead of currently used docker.io/renovate/node .","title":"dockerImagePrefix"},{"location":"self-hosted-configuration/#dockermapdotfiles","text":"Map relevant home directory dotfiles into containers when binarySource=docker. Name Value type boolean default false This is used if you want to map \"dotfiles\" from your host computer home directory to containers that Renovate creates, e.g. for updating lock files. Currently applicable to .npmrc only.","title":"dockerMapDotfiles"},{"location":"self-hosted-configuration/#dockeruser","text":"Specify UID and GID for Docker-based binaries when binarySource=docker is used. Name Value type string default null Override default user and group used by Docker-based binaries. UID and GID should match the user that executes renovate. See Docker run reference for more information on user and group syntax. Set this to 1001:1002 to use UID 1001 and GID 1002.","title":"dockerUser"},{"location":"self-hosted-configuration/#dryrun","text":"If enabled, perform a dry run by logging messages instead of creating/updating/deleting branches and PRs. Name Value type boolean default false","title":"dryRun"},{"location":"self-hosted-configuration/#endpoint","text":"Custom endpoint to use. Name Value type string","title":"endpoint"},{"location":"self-hosted-configuration/#force","text":"Any configuration defined within this object will force override existing settings. Name Value type object This object is used as a \"force override\" when you need to make sure certain configuration overrides whatever is configured in the repository. For example, forcing a null (no) schedule to make sure Renovate raises PRs on a run even if the repository itself or its preset defines a schedule that's currently in active. In practice, it is implemented by converting the force configuration into a packageRule that matches all packages.","title":"force"},{"location":"self-hosted-configuration/#forcecli","text":"Whether CLI configuration options should be moved to the force config section. Name Value type boolean default true This is set to true by default, meaning that any settings (such as schedule ) take maximum priority even against custom settings existing inside individual repositories. It will also override any settings in packageRules .","title":"forceCli"},{"location":"self-hosted-configuration/#forkmode","text":"Set to true to fork the source repository and create branches there instead. Name Value type boolean default false You probably have no need for this option - it is an experimental setting for the Renovate hosted GitHub App.","title":"forkMode"},{"location":"self-hosted-configuration/#gitauthor","text":"Author to use for Git commits. Must conform to RFC5322. Name Value type string default null RFC5322-compliant string if you wish to customise the Git author for commits. If you need to transition from one Git author to another, put the old gitAuthor into RENOVATE_LEGACY_GIT_AUTHOR_EMAIL in environment. Renovate will then check against it as well as the current Git author value before deciding if a branch has been modified. Note It is strongly recommended that the Git author email you provide should be unique to Renovate. Otherwise, if another bot or human shares the same email and pushes to one of Renovate's branches then Renovate will mistake the branch as unmodified and potentially force push over the changes.","title":"gitAuthor"},{"location":"self-hosted-configuration/#gitprivatekey","text":"PGP key to use for signing Git commits. Name Value type string default null This should be an armored private key, e.g. the type you get from running gpg --export-secret-keys --armor 92066A17F0D1707B4E96863955FEF5171C45FAE5 > private.key . Replace the newlines with \\n before adding the resulting single-line value to your bot's config. It will be loaded lazily . Before the first commit in a repository, Renovate will: First, run gpg import if it hasn't been run before Then, run git config user.signingkey and git config commit.gpgsign true The git commands are run locally in the cloned repo instead of globally to reduce the chance of causing unintended consequences with global Git configs on shared systems.","title":"gitPrivateKey"},{"location":"self-hosted-configuration/#logcontext","text":"Add a global or per-repo log context to each log entry. Name Value type string logContext is included with each log entry only if logFormat=\"json\" - it is not included in the pretty log output. If left as default (null), a random short ID will be selected.","title":"logContext"},{"location":"self-hosted-configuration/#logfile","text":"Log file path. Name Value type string default null","title":"logFile"},{"location":"self-hosted-configuration/#logfilelevel","text":"Log file log level. Name Value type string default \"debug\"","title":"logFileLevel"},{"location":"self-hosted-configuration/#loglevel","text":"Logging level. Deprecated, use LOG_LEVEL environment. Name Value type string allowedValues fatal,error,warn,info,debug,trace default null It's recommended to run at debug level if you can, and configure it using the environment variable LOG_LEVEL=debug . By configuring using the environment it means that debug logging starts from the beginning of the app, while if you configure it using file config then the debug logging can only start after the file config is parsed. Additionally, if you configure LOG_FORMAT=json in env then logging will be done in JSON format instead of \"pretty\" format, which is usually better if you're doing any ingestion or parsing of the logs. Warning: Configuring logLevel config option or --log-level cli option is deprecated and will be removed in a major version.","title":"logLevel"},{"location":"self-hosted-configuration/#onboarding","text":"Require a Configuration PR first. Name Value type boolean default true Set this to false if (a) you configure Renovate entirely on the bot side (i.e. empty renovate.json in repositories) and (b) you wish to run Renovate on every repository the bot has access to, and (c) you wish to skip the onboarding PRs.","title":"onboarding"},{"location":"self-hosted-configuration/#onboardingbranch","text":"Change this value in order to override the default onboarding branch name. Name Value type string default \"renovate/configure\" Note that this setting is independent of branchPrefix . For example, if you configure branchPrefix to be renovate- then you'd still have the onboarding PR created with branch renovate/configure until you configure onboardingBranch=renovate-configure or similar. If you have an existing Renovate installation and you change onboardingBranch then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged.","title":"onboardingBranch"},{"location":"self-hosted-configuration/#onboardingcommitmessage","text":"Change this value in order to override the default onboarding commit message. Name Value type string Note that if commitMessagePrefix or semanticCommits values are defined then they will be prepended to the commit message using the same logic that is used for adding them to non-onboarding commit messages.","title":"onboardingCommitMessage"},{"location":"self-hosted-configuration/#onboardingconfig","text":"Configuration to use in onboarding PRs. Name Value type object mergeable true","title":"onboardingConfig"},{"location":"self-hosted-configuration/#onboardingconfigfilename","text":"Change this value in order to override the default onboarding config file name. Name Value type string default \"renovate.json\" If set to one of the valid config file names , the onboarding PR will create a configuration file with the provided name instead of renovate.json . Falls back to renovate.json if the name provided is not valid.","title":"onboardingConfigFileName"},{"location":"self-hosted-configuration/#onboardingprtitle","text":"Change this value in order to override the default onboarding PR title. Name Value type string default \"Configure Renovate\" Similarly to onboardingBranch , if you have an existing Renovate installation and you change onboardingPrTitle then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged.","title":"onboardingPrTitle"},{"location":"self-hosted-configuration/#optimizefordisabled","text":"Set to true to first check for disabling in config before cloning. Name Value type boolean default false","title":"optimizeForDisabled"},{"location":"self-hosted-configuration/#password","text":"Password for authentication. Currently Bitbucket only (AppPassword). Name Value type string default null","title":"password"},{"location":"self-hosted-configuration/#persistrepodata","text":"If set to true, repository data will preserved between runs instead of deleted. Name Value type boolean default false Set this to true if you wish for Renovate to persist repo data between runs. The intention is that this allows Renovate to do a faster git fetch between runs rather than git clone . It also may mean that ignored directories like node_modules can be preserved and save time on operations like npm install .","title":"persistRepoData"},{"location":"self-hosted-configuration/#platform","text":"Platform type of repository. Name Value type string allowedValues azure,bitbucket,bitbucket-server,gitea,github,gitlab default \"github\"","title":"platform"},{"location":"self-hosted-configuration/#prcommitsperrunlimit","text":"Set a maximum number of commits per Renovate run. Default is no limit. Name Value type integer default 0 Parameter to reduce CI load. CI jobs are usually triggered by these events: pull-request creation, pull-request update, automerge events. Set as an integer. Default is no limit.","title":"prCommitsPerRunLimit"},{"location":"self-hosted-configuration/#printconfig","text":"If enabled, log the full resolved config for each repo, including resolved presets. Name Value type boolean default false This option is useful for troubleshooting, particularly if using presets. e.g. run renovate foo/bar --print-config > config.log and the fully-resolved config will be included in the log file.","title":"printConfig"},{"location":"self-hosted-configuration/#privatekey","text":"Server-side private key. Name Value type string replaceLineReturns true default null This private key is used to decrypt config files. The corresponding public key can be used to create encrypted values for config files. If you want a simple UI to encrypt values you can put the public key in a HTML page similar to https://renovatebot.com/encrypt . To create the key pair with openssl use the following commands: openssl genrsa -out rsa_priv.pem 4096 for generating the private key openssl rsa -pubout -in rsa_priv.pem -out rsa_pub.pem for extracting the public key","title":"privateKey"},{"location":"self-hosted-configuration/#privatekeypath","text":"Path to the Server-side private key. Name Value type string default null Used as an alternative to privateKey , if you wish for the key to be read from disk instead.","title":"privateKeyPath"},{"location":"self-hosted-configuration/#productlinks","text":"Links which are embedded within PRs, issues, etc. Name Value type object mergeable true additionalProperties [object Object] Override this object if you wish to change the URLs that Renovate links to, e.g. if you have an internal forum for asking for help.","title":"productLinks"},{"location":"self-hosted-configuration/#redisurl","text":"If defined, this Redis URL will be used for caching instead of the file system. Name Value type string default null If this value is set then Renovate will use Redis for its global cache instead of the local file system. The global cache is used to store lookup results (e.g. dependency versions and release notes) between repositories and runs. Example url: redis://localhost .","title":"redisUrl"},{"location":"self-hosted-configuration/#repositories","text":"List of Repositories. Name Value type array","title":"repositories"},{"location":"self-hosted-configuration/#repositorycache","text":"Option to do repository extract caching. Name Value type string allowedValues disabled,enabled,reset default \"disabled\" Set this to \"enabled\" to have Renovate maintain a JSON file cache per-repository to speed up extractions. Set to \"reset\" if you ever need to bypass the cache and have it overwritten. JSON files will be stored inside the cacheDir beside the existing file-based package cache. Warning: this is an experimental feature and may be modified or removed in a future non-major release.","title":"repositoryCache"},{"location":"self-hosted-configuration/#requireconfig","text":"Set to true if repositories must have a config to activate. Name Value type boolean default true","title":"requireConfig"},{"location":"self-hosted-configuration/#skipinstalls","text":"Skip installing modules/dependencies if lock file updating is possible alone. Name Value type boolean default null By default, Renovate will use the most efficient approach to updating package files and lock files, which in most cases skips the need to perform a full module install by the bot. If this is set to false, then a full install of modules will be done. This is currently applicable to npm and lerna / npm only, and only used in cases where bugs in npm result in incorrect lock files being updated.","title":"skipInstalls"},{"location":"self-hosted-configuration/#token","text":"Repository Auth Token. Name Value type string default null","title":"token"},{"location":"self-hosted-configuration/#trustlevel","text":"Set this to \"high\" if the bot should trust the repository owners/contents. Name Value type string default \"low\" Setting trustLevel to \"high\" can make sense in many self-hosted cases where the bot operator trusts the content in each repository. Setting trustLevel=high means: Child processes are run with full access to env .npmrc files can have environment variable substitution performed","title":"trustLevel"},{"location":"self-hosted-configuration/#username","text":"Username for authentication. Currently Bitbucket only. Name Value type string default null","title":"username"},{"location":"self-hosting/","text":"Self-Hosting Renovate Installing Renovate OSS CLI npmjs npm install -g renovate Renovate does not embed npm , pnpm and yarn as its own dependencies. If you want to use these package managers to update your lockfiles, you must ensure that the correct versions are already installed globally. npm install -g yarn pnpm The same goes for any other third party binary tool like gradle or poetry - you need to make sure they are installed and the appropriate version before running Renovate. Docker Renovate is available for Docker via an automated build renovate/renovate . It builds latest based on the master branch and all semver tags are published too. For example, all the following are valid tags: docker run --rm renovate/renovate docker run --rm renovate/renovate:24.53.0 docker run --rm renovate/renovate:24.53 docker run --rm renovate/renovate:24 Do not use the example tags listed above, as they will be out-of-date. Go to renovate/renovate tags to grab the latest tagged release from Renovate. If you want to configure Renovate using a config.js file then map it to /usr/src/app/config.js using Docker volumes. For example: docker run --rm -v \"/path/to/your/config.js:/usr/src/app/config.js\" renovate/renovate Kubernetes Renovate's official Docker image is compatible with Kubernetes. The following is an example manifest of running Renovate against a GitHub Enterprise server. First the Kubernetes manifest: apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: containers: - name: renovate # Update this to the latest available and then enable Renovate on # the manifest image: renovate/renovate:24.53.0 args: - user/repo # Environment Variables env: - name: LOG_LEVEL value: debug envFrom: - secretRef: name: renovate-env restartPolicy: Never And also this accompanying secret.yaml : apiVersion: v1 kind: Secret metadata: name: renovate-env type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' # You can set RENOVATE_AUTODISCOVER to true to run Renovate on all repos you have push access to RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' A config.js file can be added to the manifest using a ConfigMap as shown in the following example (using a \"dry run\" in github.com): --- apiVersion: v1 kind: ConfigMap metadata: name: renovate-config data: config.json: |- { \"repositories\": [\"orgname/repo\",\"username/repo\"], \"dryRun\" : \"true\" } --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate-bot spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: containers: - image: renovate/renovate:24.53.0 name: renovate-bot env: # For illustration purposes, please use secrets. - name: RENOVATE_PLATFORM value: 'github' - name: RENOVATE_TOKEN value: 'some-token' - name: RENOVATE_AUTODISCOVER value: 'false' - name: RENOVATE_BASE_DIR value: '/tmp/renovate/' - name: RENOVATE_CONFIG_FILE value: '/opt/renovate/config.json' - name: LOG_LEVEL value: debug volumeMounts: - name: config-volume mountPath: /opt/renovate/ - name: work-volume mountPath: /tmp/renovate/ restartPolicy: Never volumes: - name: config-volume configMap: name: renovate-config - name: work-volume emptyDir: {} CircleCI If you are using CircleCI, you can use the third-party daniel-shuy/renovate orb to run a self-hosted instance of Renovate on CircleCI. By default, the orb looks for the self-hosted configuration file in the project root, but you can specify another path to the configuration file with the config_file_path parameter. Secrets should be configured using environment variables (eg. RENOVATE_TOKEN , GITHUB_COM_TOKEN ). Configure environment variables in CircleCI Project Settings . To share environment variables across projects, use CircleCI Contexts . The following example runs Renovate hourly, and looks for the self-hosted configuration file at renovate-config.js : version: '2.1' orbs: renovate: daniel-shuy/renovate@2.1.1 workflows: renovate: jobs: - renovate/self-hosted: config_file_path: renovate-config.js nightly: triggers: - schedule: cron: 0 * * * * filters: branches: only: - master GitLab CI/CD pipeline For GitLab pipelines we recommend you use the renovate-runner project on GitLab . We've prepared some pipeline templates to run Renovate on pipeline schedules in an easy way. You can also find the configuration steps there. For self-hosted GitLab clone/import the renovate-runner project to your instance. Configuration Self-hosted Renovate can be configured using any of the following (or a combination): A config.js file (can also be named config.json , but you can't have both at the same time) CLI parameters Environment parameters Note that some Renovate configuration options are only available for self-hosting, and so can only be configured using one of the above methods. These are described in the Self-hosted Configuration doc. Authentication Regardless of platform, you need to select a user account for renovate to assume the identity of, and generate a Personal Access Token. It is recommended to be @renovate-bot if you are using a self-hosted server with free choice of usernames. It is also recommended that you configure config.gitAuthor with the same identity as your Renovate user, e.g. like \"gitAuthor\": \"Renovate Bot <renovate@whitesourcesoftware.com>\" . GitHub Enterprise First, create a personal access token for the bot account (select \"repo\" permissions). Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . GitLab CE/EE First, create a personal access token for the bot account (select read_user , api and write_repository scopes). Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=gitlab somewhere in config. Bitbucket Cloud First, create an AppPassword for the bot account. Configure it as password in your config.js file, or in environment variable RENOVATE_PASSWORD , or via CLI --password= . Also be sure to configure the username for your bot account too. Don't forget to configure platform=bitbucket somewhere in config. Bitbucket Server Create a Personal Access Token for your bot account. Configure it as password in your config.js file, or in environment variable RENOVATE_PASSWORD , or via CLI --password= . Also configure the username for your bot account too, if you decided not to name it @renovate-bot . Don't forget to configure platform=bitbucket-server somewhere in config. Azure DevOps First, create a personal access token for the bot account. Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=azure somewhere in config. Gitea First, create a access token for your bot account. Configure it as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=gitea somewhere in config. GitHub.com token for release notes If you are running on any platform except github.com, it's important to also configure the environment variable GITHUB_COM_TOKEN containing a personal access token for github.com. This account can actually be any account on GitHub, and needs only read-only access. It's used when fetching release notes for repositories in order to increase the hourly API limit. It's also OK to configure the same as a host rule instead, if you prefer that. Note: If you're using Renovate in a project where dependencies are loaded from github.com (such as Go modules hosted on GitHub) it is highly recommended to add a token as you will run in the rate limit from the github.com API, which will lead to Renovate closing and reopening PRs because it could not get reliable info on updated dependencies. File/directory usage By default, Renovate stores all files in the renovate/ subdirectory of the operating system's temporary directory, e.g. /tmp/renovate/ . Repository data is copied or cloned into unique subdirectories under repos/ , e.g. /tmp/renovate/repos/github/owner1/repo-a/ . Renovate's own cache, as well as the caches(s) for npm, Yarn, Composer etc, is stored in /tmp/renovate/cache . To use another directory as the base directory, instead of tmp/renovate : Configure a value for baseDir in config.js Use an environment variable RENOVATE_BASE_DIR Use the CLI to pass a base directory: --base-dir= If you want to override the cache location then configure a value for cacheDir instead. Usage The following example uses the Renovate CLI tool, which can be installed by running npm i -g renovate . If running your own Renovate bot then you will need a user account that Renovate will run as. It's recommended to use a dedicated account for the bot, e.g. name it renovate-bot if on your own instance. Create and save a Personal Access Token for this account. Create a Renovate config file, e.g. here is an example: module.exports = { endpoint: 'https://self-hosted.gitlab/api/v4/', token: '**gitlab_token**', platform: 'gitlab', onboardingConfig: { extends: ['config:base'], }, repositories: ['username/repo', 'orgname/repo'], }; Here change the logFile and repositories to something appropriate. Also replace gitlab-token value with the one created during the previous step. If running against GitHub Enterprise, change the above gitlab values to the equivalent GitHub ones. You can save this file as anything you want and then use RENOVATE_CONFIG_FILE env variable to tell Renovate where to find it. Most people will run Renovate via cron, e.g. once per hour. Here is an example bash script that you can point cron to: #!/bin/bash export PATH=\"/home/user/.yarn/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH\" export RENOVATE_CONFIG_FILE=\"/home/user/renovate-config.js\" export RENOVATE_TOKEN=\"**some-token**\" # GitHub, GitLab, Azure DevOps export GITHUB_COM_TOKEN=\"**github-token**\" # Delete this if using github.com # Renovate renovate Note: the GitHub.com token in env is necessary in order to retrieve Release Notes that are usually hosted on github.com. You don't need to add it if you are already running the bot against github.com, but you do need to add it if you're using GitHub Enterprise, GitLab, Azure DevOps, or Bitbucket. You should save and test out this script manually first, and add it to cron once you've verified it. Kubernetes for GitLab, using Git over SSH This section describes how to use Git binary with SSH for Gitlab, to avoid API shortcomings. You need to first create a SSH key, then add the public part to Gitlab (see this guide ) Then, you need to create the secret to add the SSH key, and the following config to your container host gitlab.com HostName gitlab.com StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa User git To easily create the secret, you can do the following (see docs ) kubectl create secret generic ssh-key-secret --from-file=config=/path/to/config --from-file=id_rsa=/path/to/.ssh/id_rsa --from-file=id_rsa.pub=/path/to/.ssh/id_rsa.pub It creates something like this apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> Then you just need to add Git author, and mount volumes. The final configuration should look something like this: --- apiVersion: v1 kind: Namespace metadata: name: <namespace, for example renovate> --- apiVersion: v1 kind: Secret metadata: name: renovate-env namespace: <namespace> type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' --- apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate namespace: <namespace> spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: volumes: - name: ssh-key-volume secret: secretName: ssh-key-secret containers: - name: renovate # Update this to the latest available and then enable Renovate on the manifest image: renovate/renovate:24.53.0 volumeMounts: - name: ssh-key-volume readOnly: true mountPath: '/home/ubuntu/.ssh' args: - <repository> # Environment Variables envFrom: - secretRef: name: renovate-env restartPolicy: Never Logging It's recommended to configure LOG_LEVEL=debug and LOG_FORMAT=json in environment if you are ingesting/parsing logs into another system. Debug logging is usually necessary for any debugging, while JSON format will mean that the output is parseable. About the log level numbers When you use LOG_LEVEL=debug and LOG_FORMAT=json , Renovate uses numbers in the level field. The logging level output is controlled by the Bunyan logging library. Level Meaning 10 trace 20 debug 30 info 40 warn 50 error 60 fatal","title":"Self-hosting"},{"location":"self-hosting/#self-hosting-renovate","text":"","title":"Self-Hosting Renovate"},{"location":"self-hosting/#installing-renovate-oss-cli","text":"","title":"Installing Renovate OSS CLI"},{"location":"self-hosting/#npmjs","text":"npm install -g renovate Renovate does not embed npm , pnpm and yarn as its own dependencies. If you want to use these package managers to update your lockfiles, you must ensure that the correct versions are already installed globally. npm install -g yarn pnpm The same goes for any other third party binary tool like gradle or poetry - you need to make sure they are installed and the appropriate version before running Renovate.","title":"npmjs"},{"location":"self-hosting/#docker","text":"Renovate is available for Docker via an automated build renovate/renovate . It builds latest based on the master branch and all semver tags are published too. For example, all the following are valid tags: docker run --rm renovate/renovate docker run --rm renovate/renovate:24.53.0 docker run --rm renovate/renovate:24.53 docker run --rm renovate/renovate:24 Do not use the example tags listed above, as they will be out-of-date. Go to renovate/renovate tags to grab the latest tagged release from Renovate. If you want to configure Renovate using a config.js file then map it to /usr/src/app/config.js using Docker volumes. For example: docker run --rm -v \"/path/to/your/config.js:/usr/src/app/config.js\" renovate/renovate","title":"Docker"},{"location":"self-hosting/#kubernetes","text":"Renovate's official Docker image is compatible with Kubernetes. The following is an example manifest of running Renovate against a GitHub Enterprise server. First the Kubernetes manifest: apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: containers: - name: renovate # Update this to the latest available and then enable Renovate on # the manifest image: renovate/renovate:24.53.0 args: - user/repo # Environment Variables env: - name: LOG_LEVEL value: debug envFrom: - secretRef: name: renovate-env restartPolicy: Never And also this accompanying secret.yaml : apiVersion: v1 kind: Secret metadata: name: renovate-env type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' # You can set RENOVATE_AUTODISCOVER to true to run Renovate on all repos you have push access to RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' A config.js file can be added to the manifest using a ConfigMap as shown in the following example (using a \"dry run\" in github.com): --- apiVersion: v1 kind: ConfigMap metadata: name: renovate-config data: config.json: |- { \"repositories\": [\"orgname/repo\",\"username/repo\"], \"dryRun\" : \"true\" } --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate-bot spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: containers: - image: renovate/renovate:24.53.0 name: renovate-bot env: # For illustration purposes, please use secrets. - name: RENOVATE_PLATFORM value: 'github' - name: RENOVATE_TOKEN value: 'some-token' - name: RENOVATE_AUTODISCOVER value: 'false' - name: RENOVATE_BASE_DIR value: '/tmp/renovate/' - name: RENOVATE_CONFIG_FILE value: '/opt/renovate/config.json' - name: LOG_LEVEL value: debug volumeMounts: - name: config-volume mountPath: /opt/renovate/ - name: work-volume mountPath: /tmp/renovate/ restartPolicy: Never volumes: - name: config-volume configMap: name: renovate-config - name: work-volume emptyDir: {}","title":"Kubernetes"},{"location":"self-hosting/#circleci","text":"If you are using CircleCI, you can use the third-party daniel-shuy/renovate orb to run a self-hosted instance of Renovate on CircleCI. By default, the orb looks for the self-hosted configuration file in the project root, but you can specify another path to the configuration file with the config_file_path parameter. Secrets should be configured using environment variables (eg. RENOVATE_TOKEN , GITHUB_COM_TOKEN ). Configure environment variables in CircleCI Project Settings . To share environment variables across projects, use CircleCI Contexts . The following example runs Renovate hourly, and looks for the self-hosted configuration file at renovate-config.js : version: '2.1' orbs: renovate: daniel-shuy/renovate@2.1.1 workflows: renovate: jobs: - renovate/self-hosted: config_file_path: renovate-config.js nightly: triggers: - schedule: cron: 0 * * * * filters: branches: only: - master","title":"CircleCI"},{"location":"self-hosting/#gitlab-cicd-pipeline","text":"For GitLab pipelines we recommend you use the renovate-runner project on GitLab . We've prepared some pipeline templates to run Renovate on pipeline schedules in an easy way. You can also find the configuration steps there. For self-hosted GitLab clone/import the renovate-runner project to your instance.","title":"GitLab CI/CD pipeline"},{"location":"self-hosting/#configuration","text":"Self-hosted Renovate can be configured using any of the following (or a combination): A config.js file (can also be named config.json , but you can't have both at the same time) CLI parameters Environment parameters Note that some Renovate configuration options are only available for self-hosting, and so can only be configured using one of the above methods. These are described in the Self-hosted Configuration doc.","title":"Configuration"},{"location":"self-hosting/#authentication","text":"Regardless of platform, you need to select a user account for renovate to assume the identity of, and generate a Personal Access Token. It is recommended to be @renovate-bot if you are using a self-hosted server with free choice of usernames. It is also recommended that you configure config.gitAuthor with the same identity as your Renovate user, e.g. like \"gitAuthor\": \"Renovate Bot <renovate@whitesourcesoftware.com>\" .","title":"Authentication"},{"location":"self-hosting/#github-enterprise","text":"First, create a personal access token for the bot account (select \"repo\" permissions). Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= .","title":"GitHub Enterprise"},{"location":"self-hosting/#gitlab-ceee","text":"First, create a personal access token for the bot account (select read_user , api and write_repository scopes). Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=gitlab somewhere in config.","title":"GitLab CE/EE"},{"location":"self-hosting/#bitbucket-cloud","text":"First, create an AppPassword for the bot account. Configure it as password in your config.js file, or in environment variable RENOVATE_PASSWORD , or via CLI --password= . Also be sure to configure the username for your bot account too. Don't forget to configure platform=bitbucket somewhere in config.","title":"Bitbucket Cloud"},{"location":"self-hosting/#bitbucket-server","text":"Create a Personal Access Token for your bot account. Configure it as password in your config.js file, or in environment variable RENOVATE_PASSWORD , or via CLI --password= . Also configure the username for your bot account too, if you decided not to name it @renovate-bot . Don't forget to configure platform=bitbucket-server somewhere in config.","title":"Bitbucket Server"},{"location":"self-hosting/#azure-devops","text":"First, create a personal access token for the bot account. Configure it either as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=azure somewhere in config.","title":"Azure DevOps"},{"location":"self-hosting/#gitea","text":"First, create a access token for your bot account. Configure it as token in your config.js file, or in environment variable RENOVATE_TOKEN , or via CLI --token= . Don't forget to configure platform=gitea somewhere in config.","title":"Gitea"},{"location":"self-hosting/#githubcom-token-for-release-notes","text":"If you are running on any platform except github.com, it's important to also configure the environment variable GITHUB_COM_TOKEN containing a personal access token for github.com. This account can actually be any account on GitHub, and needs only read-only access. It's used when fetching release notes for repositories in order to increase the hourly API limit. It's also OK to configure the same as a host rule instead, if you prefer that. Note: If you're using Renovate in a project where dependencies are loaded from github.com (such as Go modules hosted on GitHub) it is highly recommended to add a token as you will run in the rate limit from the github.com API, which will lead to Renovate closing and reopening PRs because it could not get reliable info on updated dependencies.","title":"GitHub.com token for release notes"},{"location":"self-hosting/#filedirectory-usage","text":"By default, Renovate stores all files in the renovate/ subdirectory of the operating system's temporary directory, e.g. /tmp/renovate/ . Repository data is copied or cloned into unique subdirectories under repos/ , e.g. /tmp/renovate/repos/github/owner1/repo-a/ . Renovate's own cache, as well as the caches(s) for npm, Yarn, Composer etc, is stored in /tmp/renovate/cache . To use another directory as the base directory, instead of tmp/renovate : Configure a value for baseDir in config.js Use an environment variable RENOVATE_BASE_DIR Use the CLI to pass a base directory: --base-dir= If you want to override the cache location then configure a value for cacheDir instead.","title":"File/directory usage"},{"location":"self-hosting/#usage","text":"The following example uses the Renovate CLI tool, which can be installed by running npm i -g renovate . If running your own Renovate bot then you will need a user account that Renovate will run as. It's recommended to use a dedicated account for the bot, e.g. name it renovate-bot if on your own instance. Create and save a Personal Access Token for this account. Create a Renovate config file, e.g. here is an example: module.exports = { endpoint: 'https://self-hosted.gitlab/api/v4/', token: '**gitlab_token**', platform: 'gitlab', onboardingConfig: { extends: ['config:base'], }, repositories: ['username/repo', 'orgname/repo'], }; Here change the logFile and repositories to something appropriate. Also replace gitlab-token value with the one created during the previous step. If running against GitHub Enterprise, change the above gitlab values to the equivalent GitHub ones. You can save this file as anything you want and then use RENOVATE_CONFIG_FILE env variable to tell Renovate where to find it. Most people will run Renovate via cron, e.g. once per hour. Here is an example bash script that you can point cron to: #!/bin/bash export PATH=\"/home/user/.yarn/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH\" export RENOVATE_CONFIG_FILE=\"/home/user/renovate-config.js\" export RENOVATE_TOKEN=\"**some-token**\" # GitHub, GitLab, Azure DevOps export GITHUB_COM_TOKEN=\"**github-token**\" # Delete this if using github.com # Renovate renovate Note: the GitHub.com token in env is necessary in order to retrieve Release Notes that are usually hosted on github.com. You don't need to add it if you are already running the bot against github.com, but you do need to add it if you're using GitHub Enterprise, GitLab, Azure DevOps, or Bitbucket. You should save and test out this script manually first, and add it to cron once you've verified it.","title":"Usage"},{"location":"self-hosting/#kubernetes-for-gitlab-using-git-over-ssh","text":"This section describes how to use Git binary with SSH for Gitlab, to avoid API shortcomings. You need to first create a SSH key, then add the public part to Gitlab (see this guide ) Then, you need to create the secret to add the SSH key, and the following config to your container host gitlab.com HostName gitlab.com StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa User git To easily create the secret, you can do the following (see docs ) kubectl create secret generic ssh-key-secret --from-file=config=/path/to/config --from-file=id_rsa=/path/to/.ssh/id_rsa --from-file=id_rsa.pub=/path/to/.ssh/id_rsa.pub It creates something like this apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> Then you just need to add Git author, and mount volumes. The final configuration should look something like this: --- apiVersion: v1 kind: Namespace metadata: name: <namespace, for example renovate> --- apiVersion: v1 kind: Secret metadata: name: renovate-env namespace: <namespace> type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' --- apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate namespace: <namespace> spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: volumes: - name: ssh-key-volume secret: secretName: ssh-key-secret containers: - name: renovate # Update this to the latest available and then enable Renovate on the manifest image: renovate/renovate:24.53.0 volumeMounts: - name: ssh-key-volume readOnly: true mountPath: '/home/ubuntu/.ssh' args: - <repository> # Environment Variables envFrom: - secretRef: name: renovate-env restartPolicy: Never","title":"Kubernetes for GitLab, using Git over SSH"},{"location":"self-hosting/#logging","text":"It's recommended to configure LOG_LEVEL=debug and LOG_FORMAT=json in environment if you are ingesting/parsing logs into another system. Debug logging is usually necessary for any debugging, while JSON format will mean that the output is parseable.","title":"Logging"},{"location":"self-hosting/#about-the-log-level-numbers","text":"When you use LOG_LEVEL=debug and LOG_FORMAT=json , Renovate uses numbers in the level field. The logging level output is controlled by the Bunyan logging library. Level Meaning 10 trace 20 debug 30 info 40 warn 50 error 60 fatal","title":"About the log level numbers"},{"location":"semantic-commits/","text":"Semantic Commit messages To detect if your repository uses semantic commits, Renovate looks at the latest 10 commit messages in the base branch. It then uses conventional-commits-detector to determine what convention the commit messages follow. Renovate only detects Angular-style conventional commits, it ignores all other commit conventions. When Renovate finds Angular-style commits, Renovate will create commit messages and PR titles that look like this: chore(deps): update eslint to v4.2.0 fix(deps): update express to v4.16.2 Renovate uses chore by default, but uses fix for updates to your production dependencies in your package.json file. Manually enabling or disabling semantic commits You can override the default settings, and disable or enable semantic commits. If you want Renovate to use semantic commits: add \":semanticCommits\" to your extends array. If you want Renovate to stop using semantic commits, add \":semanticCommitsDisabled\" to your extends array. Changing the Semantic Commit type You can change the Semantic Commit type that Renovate uses. Say you want Renovate to use \"chore\" for every PR, you can add \":semanticCommitTypeAll(chore)\" to your extends array. PR titles and commit messages start with \"chore(deps):\" Or say you want to use \"ci\" for every PR, then you would add \":semanticCommitTypeAll(ci)\" to your extends array instead. PR titles and commit messages start with \"ci(deps):\" Changing the Semantic Commit scope If you don't like the default \"deps\" scope, you can use another word for the scope instead. For example, to set the scope to \"package\" instead, add the preset \":semanticCommitScope(package)\" to your extends array. If you want to remove the semantic commit scope (e.g. use prefix chore: instead of chore(deps): ), then add the preset \":semanticCommitScopeDisabled\" to your extends array.","title":"Semantic Commit Messages"},{"location":"semantic-commits/#semantic-commit-messages","text":"To detect if your repository uses semantic commits, Renovate looks at the latest 10 commit messages in the base branch. It then uses conventional-commits-detector to determine what convention the commit messages follow. Renovate only detects Angular-style conventional commits, it ignores all other commit conventions. When Renovate finds Angular-style commits, Renovate will create commit messages and PR titles that look like this: chore(deps): update eslint to v4.2.0 fix(deps): update express to v4.16.2 Renovate uses chore by default, but uses fix for updates to your production dependencies in your package.json file.","title":"Semantic Commit messages"},{"location":"semantic-commits/#manually-enabling-or-disabling-semantic-commits","text":"You can override the default settings, and disable or enable semantic commits. If you want Renovate to use semantic commits: add \":semanticCommits\" to your extends array. If you want Renovate to stop using semantic commits, add \":semanticCommitsDisabled\" to your extends array.","title":"Manually enabling or disabling semantic commits"},{"location":"semantic-commits/#changing-the-semantic-commit-type","text":"You can change the Semantic Commit type that Renovate uses. Say you want Renovate to use \"chore\" for every PR, you can add \":semanticCommitTypeAll(chore)\" to your extends array. PR titles and commit messages start with \"chore(deps):\" Or say you want to use \"ci\" for every PR, then you would add \":semanticCommitTypeAll(ci)\" to your extends array instead. PR titles and commit messages start with \"ci(deps):\"","title":"Changing the Semantic Commit type"},{"location":"semantic-commits/#changing-the-semantic-commit-scope","text":"If you don't like the default \"deps\" scope, you can use another word for the scope instead. For example, to set the scope to \"package\" instead, add the preset \":semanticCommitScope(package)\" to your extends array. If you want to remove the semantic commit scope (e.g. use prefix chore: instead of chore(deps): ), then add the preset \":semanticCommitScopeDisabled\" to your extends array.","title":"Changing the Semantic Commit scope"},{"location":"setup-azure-devops/","text":"Azure DevOps setup This document explains how to setup Renovate for use on Azure DevOps. Setting up a new pipeline Create a brand new pipeline within Azure DevOps, and select your source: Then select your repository. Within Configure your pipeline select: Starter pipeline Replace all content in the starter pipeline with: schedules: - cron: '0 3 * * *' displayName: 'Every day at 3am' branches: include: [master] trigger: none pool: vmImage: ubuntu-latest steps: - task: npmAuthenticate@0 inputs: workingFile: .npmrc - bash: | git config --global user.email 'bot@renovateapp.com' git config --global user.name 'Renovate Bot' npx --userconfig .npmrc renovate env: TOKEN: $(System.AccessToken) Create a .npmrc file Create a .npmrc file in your repository: registry=https://pkgs.dev.azure.com/YOUR-ORG/_packaging/YOUR-FEED/npm/registry/ always-auth=true For the registry key, replace YOUR-ORG with your Azure DevOps organization and YOUR-FEED with your Azure Artifacts feed. Create a config.js file Create a config.js file in your repository: module.exports = { platform: 'azure', endpoint: 'https://dev.azure.com/YOUR-ORG/', token: process.env.TOKEN, hostRules: [ { hostName: 'pkgs.dev.azure.com', username: 'apikey', password: process.env.TOKEN, }, ], repositories: ['YOUR-PROJECT/YOUR-REPO'], }; For the endpoint key, replace YOUR-ORG with your Azure DevOps organization. For the repositories key, replace YOUR-PROJECT/YOUR-REPO with your Azure DevOps project and repository. Add renovate.json file Additionally, you can create a renovate.json file which holds the Renovate configuration, in the root of the repo. Read more about the Renovate configuration options Using a single pipeline to update multiple repositories If you want to use a single Renovate pipeline to update multiple repositories you must take the following steps. Add the names of the repositories to config.js . Make sure that the \"Project Collection Build Service (YOUR-PROJECT)\" user has the following permissions on the repositories: Contribute Contribute to pull requests Create branch","title":"Azure DevOps setup"},{"location":"setup-azure-devops/#azure-devops-setup","text":"This document explains how to setup Renovate for use on Azure DevOps.","title":"Azure DevOps setup"},{"location":"setup-azure-devops/#setting-up-a-new-pipeline","text":"Create a brand new pipeline within Azure DevOps, and select your source: Then select your repository. Within Configure your pipeline select: Starter pipeline Replace all content in the starter pipeline with: schedules: - cron: '0 3 * * *' displayName: 'Every day at 3am' branches: include: [master] trigger: none pool: vmImage: ubuntu-latest steps: - task: npmAuthenticate@0 inputs: workingFile: .npmrc - bash: | git config --global user.email 'bot@renovateapp.com' git config --global user.name 'Renovate Bot' npx --userconfig .npmrc renovate env: TOKEN: $(System.AccessToken)","title":"Setting up a new pipeline"},{"location":"setup-azure-devops/#create-a-npmrc-file","text":"Create a .npmrc file in your repository: registry=https://pkgs.dev.azure.com/YOUR-ORG/_packaging/YOUR-FEED/npm/registry/ always-auth=true For the registry key, replace YOUR-ORG with your Azure DevOps organization and YOUR-FEED with your Azure Artifacts feed.","title":"Create a .npmrc file"},{"location":"setup-azure-devops/#create-a-configjs-file","text":"Create a config.js file in your repository: module.exports = { platform: 'azure', endpoint: 'https://dev.azure.com/YOUR-ORG/', token: process.env.TOKEN, hostRules: [ { hostName: 'pkgs.dev.azure.com', username: 'apikey', password: process.env.TOKEN, }, ], repositories: ['YOUR-PROJECT/YOUR-REPO'], }; For the endpoint key, replace YOUR-ORG with your Azure DevOps organization. For the repositories key, replace YOUR-PROJECT/YOUR-REPO with your Azure DevOps project and repository.","title":"Create a config.js file"},{"location":"setup-azure-devops/#add-renovatejson-file","text":"Additionally, you can create a renovate.json file which holds the Renovate configuration, in the root of the repo. Read more about the Renovate configuration options","title":"Add renovate.json file"},{"location":"setup-azure-devops/#using-a-single-pipeline-to-update-multiple-repositories","text":"If you want to use a single Renovate pipeline to update multiple repositories you must take the following steps. Add the names of the repositories to config.js . Make sure that the \"Project Collection Build Service (YOUR-PROJECT)\" user has the following permissions on the repositories: Contribute Contribute to pull requests Create branch","title":"Using a single pipeline to update multiple repositories"},{"location":"templates/","text":"Template fields In order to provide flexible configuration, Renovate supports using \"templates\" for certain fields like branchName . Renovate's templates use handlebars under the hood. You can recognize templates when you see strings like {{depName}} in configuration fields. Below you can find lists of fields/values that you can use in templates. Some are configuration options passed through, while others are generated as part of Renovate's run. Exposed config options The following configuration options are passed through for templating: additionalBranchPrefix , addLabels , branchName , branchPrefix , branchTopic , commitMessage , commitMessageAction , commitMessageExtra , commitMessagePrefix , commitMessageSuffix , commitMessageTopic , gitAuthor , group , groupName , groupSlug , labels , prBodyColumns , prBodyDefinitions , prBodyNotes , prTitle , semanticCommitScope , semanticCommitType . Other available fields The following runtime values are passed through for templating: baseBranch : The baseBranch for this branch/PR body : The body of the release notes currentValue : The extracted current value of the dependency being updated currentVersion : The version that would be currently installed. For example, if currentValue is ^3.0.0 then currentVersion might be 3.1.0. datasource : The datasource used to look up the upgrade depName : The name of the dependency being updated depNameLinked : The dependency name already linked to its home page using markdown depNameSanitized : The depName field sanitized for use in branches after removing spaces and special characters depType : The dependency type (if extracted - manager-dependent) displayFrom : The current value, formatted for display displayTo : The to value, formatted for display hasReleaseNotes : true if the upgrade has release notes isLockfileUpdate : true if the branch is a lock file update isMajor : true if the upgrade is major isPatch : true if the upgrade is a patch upgrade isPin : true if the upgrade is pinning dependencies isRollback : true if the upgrade is a rollback PR isRange : true if the new value is a range isSingleVersion : true if the upgrade is to a single version rather than a range logJSON : ChangeLogResult object for the upgrade lookupName : The full name that was used to look up the dependency. newDigest : The new digest value newDigestShort : A shorted version of newDigest, for use when the full digest is too long to be conveniently displayed newMajor : The major version of the new version. e.g. \"3\" if the new version if \"3.1.0\" newMinor : The minor version of the new version. e.g. \"1\" if the new version if \"3.1.0\" newValue : The new value in the upgrade. Can be a range or version e.g. \"^3.0.0\" or \"3.1.0\" newVersion : The new version in the upgrade, e.g. \"3.1.0\" packageFile : The filename that the dependency was found in packageFileDir : The directory with full path where the packageFile was found parentDir : The name of the directory that the dependency was found in, without full path platform : VCS platform in use, e.g. \"github\", \"gitlab\", etc. prettyDepType : Massaged depType project : ChangeLogProject object recreateClosed : If true, this PR will be recreated if closed references : A list of references for the upgrade releases : An array of releases for an upgrade releaseNotes : A ChangeLogNotes object for the release repository : The current repository semanticPrefix : The fully generated semantic prefix for commit messages sourceUrl : The source URL for the package updateType : One of digest, pin, rollback, patch, minor, major upgrades : An array of upgrade objects in the branch url : The url of the release notes version : The version number of the changelog versioning : The versioning scheme in use versions : An array of ChangeLogRelease objects in the upgrade","title":"Templates"},{"location":"templates/#template-fields","text":"In order to provide flexible configuration, Renovate supports using \"templates\" for certain fields like branchName . Renovate's templates use handlebars under the hood. You can recognize templates when you see strings like {{depName}} in configuration fields. Below you can find lists of fields/values that you can use in templates. Some are configuration options passed through, while others are generated as part of Renovate's run.","title":"Template fields"},{"location":"templates/#exposed-config-options","text":"The following configuration options are passed through for templating: additionalBranchPrefix , addLabels , branchName , branchPrefix , branchTopic , commitMessage , commitMessageAction , commitMessageExtra , commitMessagePrefix , commitMessageSuffix , commitMessageTopic , gitAuthor , group , groupName , groupSlug , labels , prBodyColumns , prBodyDefinitions , prBodyNotes , prTitle , semanticCommitScope , semanticCommitType .","title":"Exposed config options"},{"location":"templates/#other-available-fields","text":"The following runtime values are passed through for templating: baseBranch : The baseBranch for this branch/PR body : The body of the release notes currentValue : The extracted current value of the dependency being updated currentVersion : The version that would be currently installed. For example, if currentValue is ^3.0.0 then currentVersion might be 3.1.0. datasource : The datasource used to look up the upgrade depName : The name of the dependency being updated depNameLinked : The dependency name already linked to its home page using markdown depNameSanitized : The depName field sanitized for use in branches after removing spaces and special characters depType : The dependency type (if extracted - manager-dependent) displayFrom : The current value, formatted for display displayTo : The to value, formatted for display hasReleaseNotes : true if the upgrade has release notes isLockfileUpdate : true if the branch is a lock file update isMajor : true if the upgrade is major isPatch : true if the upgrade is a patch upgrade isPin : true if the upgrade is pinning dependencies isRollback : true if the upgrade is a rollback PR isRange : true if the new value is a range isSingleVersion : true if the upgrade is to a single version rather than a range logJSON : ChangeLogResult object for the upgrade lookupName : The full name that was used to look up the dependency. newDigest : The new digest value newDigestShort : A shorted version of newDigest, for use when the full digest is too long to be conveniently displayed newMajor : The major version of the new version. e.g. \"3\" if the new version if \"3.1.0\" newMinor : The minor version of the new version. e.g. \"1\" if the new version if \"3.1.0\" newValue : The new value in the upgrade. Can be a range or version e.g. \"^3.0.0\" or \"3.1.0\" newVersion : The new version in the upgrade, e.g. \"3.1.0\" packageFile : The filename that the dependency was found in packageFileDir : The directory with full path where the packageFile was found parentDir : The name of the directory that the dependency was found in, without full path platform : VCS platform in use, e.g. \"github\", \"gitlab\", etc. prettyDepType : Massaged depType project : ChangeLogProject object recreateClosed : If true, this PR will be recreated if closed references : A list of references for the upgrade releases : An array of releases for an upgrade releaseNotes : A ChangeLogNotes object for the release repository : The current repository semanticPrefix : The fully generated semantic prefix for commit messages sourceUrl : The source URL for the package updateType : One of digest, pin, rollback, patch, minor, major upgrades : An array of upgrade objects in the branch url : The url of the release notes version : The version number of the changelog versioning : The versioning scheme in use versions : An array of ChangeLogRelease objects in the upgrade","title":"Other available fields"},{"location":"updating-rebasing/","text":"Updating and Rebasing Branches There are many cases where Renovate will need to update a branch/PR after its initial creation, and this document will attempt to describe them. Note: Renovate doesn't technically do \"rebasing\" in the Git sense. Instead, it reapplies all updates into a new commit based off of the head of the base branch. No rebasing if you have made edits First of all, here is the one time when Renovate won't update branches. If you have edited a Renovate branch directly (e.g. to make a code fix to allow tests to pass again) then Renovate will stop all updates of that branch. It is up to you to either finish the job and merge the PR, or rename it and close it so that Renovate can take back over again. Rebasing Conflicted PRs If new commits to the base branch - such as merging another Renovate PR - result in an open Renovate PR having merge conflicts, then Renovate will recreate (\"rebase\") any conflicted PRs. This applies both to commits to dependency files such as package.json as well as lock files such as yarn.lock . You should not ever need to resolve such conflicts manually. You can disable this functionality by configuring \"rebaseWhen\": \"never\" (not recommended); Rebasing Out-of-date Branches There are two cases where Renovate will rebase its branches off the base branch every time they are out of date: If you configure \"rebaseWhen\": \"behind-base-branch\" If you use the default configuration \"rebaseWhen\": \"auto\" and the repository has a requirement that branches must be up-to-date before merging (e.g. \"Require branches to be up to date before merging\" on GitHub, or FF-only settings on Bitbucket Server or GitLab) In that case Renovate PRs will be rebased off the repository's base branch whenever they are behind the base branch, even if the PRs are not conflicted. Newer Dependency Versions If an existing PR is open to upgrade dependency \"foo\" to v1.1.0 and then v1.1.1 is released, then Renovate will regenerate the branch again. This way: Each Renovate branch will always have 1 and only 1 commit The newest version will be based off the latest base branch commit at the time Manual rebasing It is possible to manually request that Renovate rebase a PR by ticking a rebase/retry checkbox on GitHub or GitLab, or by adding the label \"rebase\" to a Renovate PR. This label name is also configurable via the rebaseLabel config option too. If you apply this label then Renovate will regenerate its commit for the branch, even if the branch has been modified. Therefore it is useful in situations such as: If a branch is stale but you don't have rebaseWhen=behind-base-branch enabled If a branch has been edited and you wish to discard the edits and have Renovate create it again If a branch was created with an error (e.g. lockfile generation) and you wish to have it retried","title":"Updating and Rebasing Branches"},{"location":"updating-rebasing/#updating-and-rebasing-branches","text":"There are many cases where Renovate will need to update a branch/PR after its initial creation, and this document will attempt to describe them. Note: Renovate doesn't technically do \"rebasing\" in the Git sense. Instead, it reapplies all updates into a new commit based off of the head of the base branch.","title":"Updating and Rebasing Branches"},{"location":"updating-rebasing/#no-rebasing-if-you-have-made-edits","text":"First of all, here is the one time when Renovate won't update branches. If you have edited a Renovate branch directly (e.g. to make a code fix to allow tests to pass again) then Renovate will stop all updates of that branch. It is up to you to either finish the job and merge the PR, or rename it and close it so that Renovate can take back over again.","title":"No rebasing if you have made edits"},{"location":"updating-rebasing/#rebasing-conflicted-prs","text":"If new commits to the base branch - such as merging another Renovate PR - result in an open Renovate PR having merge conflicts, then Renovate will recreate (\"rebase\") any conflicted PRs. This applies both to commits to dependency files such as package.json as well as lock files such as yarn.lock . You should not ever need to resolve such conflicts manually. You can disable this functionality by configuring \"rebaseWhen\": \"never\" (not recommended);","title":"Rebasing Conflicted PRs"},{"location":"updating-rebasing/#rebasing-out-of-date-branches","text":"There are two cases where Renovate will rebase its branches off the base branch every time they are out of date: If you configure \"rebaseWhen\": \"behind-base-branch\" If you use the default configuration \"rebaseWhen\": \"auto\" and the repository has a requirement that branches must be up-to-date before merging (e.g. \"Require branches to be up to date before merging\" on GitHub, or FF-only settings on Bitbucket Server or GitLab) In that case Renovate PRs will be rebased off the repository's base branch whenever they are behind the base branch, even if the PRs are not conflicted.","title":"Rebasing Out-of-date Branches"},{"location":"updating-rebasing/#newer-dependency-versions","text":"If an existing PR is open to upgrade dependency \"foo\" to v1.1.0 and then v1.1.1 is released, then Renovate will regenerate the branch again. This way: Each Renovate branch will always have 1 and only 1 commit The newest version will be based off the latest base branch commit at the time","title":"Newer Dependency Versions"},{"location":"updating-rebasing/#manual-rebasing","text":"It is possible to manually request that Renovate rebase a PR by ticking a rebase/retry checkbox on GitHub or GitLab, or by adding the label \"rebase\" to a Renovate PR. This label name is also configurable via the rebaseLabel config option too. If you apply this label then Renovate will regenerate its commit for the branch, even if the branch has been modified. Therefore it is useful in situations such as: If a branch is stale but you don't have rebaseWhen=behind-base-branch enabled If a branch has been edited and you wish to discard the edits and have Renovate create it again If a branch was created with an error (e.g. lockfile generation) and you wish to have it retried","title":"Manual rebasing"},{"location":"modules/datasource/","text":"Datasources Once Renovate's manager is done scanning files and extracting dependencies, it will assign a datasource to each extracted package file and/or dependency so that Renovate then knows how to search for new versions. You do not need to ever configure/override datasources directly, but you may use them in a packageRules array to configure other aspects of Renovate's behavior, e.g. { \"packageRules\": [ { \"matchDatasources\": [\"npm\"], \"matchPackageNames\": [\"lodash\"], \"automerge\": true } ] } Supported Datasources Supported values for datasource are: bitbucket-tags , cdnjs , clojure , crate , dart , docker , galaxy , git-refs , git-submodules , git-tags , github-releases , github-tags , gitlab-tags , go , gradle-version , helm , hex , jenkins-plugins , maven , npm , nuget , orb , packagist , pod , pypi , repology , ruby-version , rubygems , sbt-package , sbt-plugin , terraform-module , terraform-provider . Bitbucket Tags Datasource Identifier : bitbucket-tags Cdnjs Datasource Identifier : cdnjs Clojure Datasource Identifier : clojure Crate Datasource Identifier : crate Dart Datasource Identifier : dart Docker Datasource Identifier : docker Default configuration : { \"additionalBranchPrefix\": \"docker-\", \"commitMessageTopic\": \"{{{depName}}} Docker tag\", \"major\": { \"enabled\": false }, \"commitMessageExtra\": \"to v{{#if isMajor}}{{{newMajor}}}{{else}}{{{newVersion}}}{{/if}}\", \"digest\": { \"branchTopic\": \"{{{depNameSanitized}}}-{{{currentValue}}}\", \"commitMessageExtra\": \"to {{newDigestShort}}\", \"commitMessageTopic\": \"{{{depName}}}{{#if currentValue}}:{{{currentValue}}}{{/if}} Docker digest\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}}\", \"commitMessageExtra\": \"\" } }, \"pin\": { \"commitMessageExtra\": \"\", \"groupName\": \"Docker digests\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}}\", \"branchTopic\": \"digests-pin\" } }, \"group\": { \"commitMessageTopic\": \"{{{groupName}}} Docker tags\" } } Galaxy Datasource Identifier : galaxy Git Refs Datasource Identifier : git-refs Git Submodules Datasource Identifier : git-submodules Default configuration : { \"pinDigests\": false } Git Tags Datasource Identifier : git-tags Github Releases Datasource Identifier : github-releases Github Tags Datasource Identifier : github-tags Gitlab Tags Datasource Identifier : gitlab-tags Go Datasource Identifier : go Gradle Version Datasource Identifier : gradle-version Helm Datasource Identifier : helm Default configuration : { \"additionalBranchPrefix\": \"helm-\", \"commitMessageTopic\": \"Helm release {{depName}}\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}} Helm releases\" } } Hex Datasource Identifier : hex Jenkins Plugins Datasource Identifier : jenkins-plugins Maven Datasource Identifier : maven Npm Datasource Identifier : npm Nuget Datasource Identifier : nuget Orb Datasource Identifier : orb Packagist Datasource Identifier : packagist Pod Datasource Identifier : pod Pypi Datasource Identifier : pypi Repology Datasource Identifier : repology Description : Repology supports looking up package versions from a wide variety of package repositories and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the lookupName has to contain the repository identifier and the package name itself, separated by a slash. As an example, alpine_3_12/gcc would look for a binary or source package called gcc within the alpine_3_12 repository. A list of all supported repositories can be found on the Repology homepage. To determine the correct identifier, click on a repository of your choice and make note of the identifier in the URL: https://repology.org/repository/<identifier> As an example, the Alpine Linux 3.12 repository points to https://repology.org/repository/alpine_3_12 and therefor has the repository identifier alpine_3_12 . Usage Example A real world example for this specific datasource would be maintaining system packages within a Dockerfile, as this allows to specifically pin each dependency without having to manually keep the versions up-to-date. This can be achieved by configuring a generic regex manager in renovate.json for files named Dockerfile : { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"#\\\\s*renovate:\\\\s*datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\": \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use regular comments in your Dockerfile to automatically update dependencies, which could look like this: FROM alpine:3.12.0@sha256:a15790640a6690aa1730c38cf0a440e2aa44aaca9b0e8931a9f2b0d7cc90fd65 # renovate: datasource=repology depName=alpine_3_12/gcc versioning=loose ENV GCC_VERSION=\"9.3.0-r2\" # renovate: datasource=repology depName=alpine_3_12/musl-dev versioning=loose ENV MUSL_DEV_VERSION=\"1.1.24-r8\" RUN apk add --no-cache \\ gcc=\"${GCC_VERSION}\" \\ musl-dev=\"${MUSL_DEV_VERSION}\" It is often wise to use the loose versioning for distribution packages as the version number usually does not strictly match the semver specification which is used by default. Now whenever the OS package for gcc of Alpine Linux 3.12 is being updated, Renovate will automatically adjust the value of the environment variable to the newest version. Ruby Version Datasource Identifier : ruby-version Rubygems Datasource Identifier : rubygems Sbt Package Datasource Identifier : sbt-package Sbt Plugin Datasource Identifier : sbt-plugin Terraform Module Datasource Identifier : terraform-module Terraform Provider Datasource Identifier : terraform-provider","title":"Datasources"},{"location":"modules/datasource/#datasources","text":"Once Renovate's manager is done scanning files and extracting dependencies, it will assign a datasource to each extracted package file and/or dependency so that Renovate then knows how to search for new versions. You do not need to ever configure/override datasources directly, but you may use them in a packageRules array to configure other aspects of Renovate's behavior, e.g. { \"packageRules\": [ { \"matchDatasources\": [\"npm\"], \"matchPackageNames\": [\"lodash\"], \"automerge\": true } ] }","title":"Datasources"},{"location":"modules/datasource/#supported-datasources","text":"Supported values for datasource are: bitbucket-tags , cdnjs , clojure , crate , dart , docker , galaxy , git-refs , git-submodules , git-tags , github-releases , github-tags , gitlab-tags , go , gradle-version , helm , hex , jenkins-plugins , maven , npm , nuget , orb , packagist , pod , pypi , repology , ruby-version , rubygems , sbt-package , sbt-plugin , terraform-module , terraform-provider .","title":"Supported Datasources"},{"location":"modules/datasource/#bitbucket-tags-datasource","text":"Identifier : bitbucket-tags","title":"Bitbucket Tags Datasource"},{"location":"modules/datasource/#cdnjs-datasource","text":"Identifier : cdnjs","title":"Cdnjs Datasource"},{"location":"modules/datasource/#clojure-datasource","text":"Identifier : clojure","title":"Clojure Datasource"},{"location":"modules/datasource/#crate-datasource","text":"Identifier : crate","title":"Crate Datasource"},{"location":"modules/datasource/#dart-datasource","text":"Identifier : dart","title":"Dart Datasource"},{"location":"modules/datasource/#docker-datasource","text":"Identifier : docker Default configuration : { \"additionalBranchPrefix\": \"docker-\", \"commitMessageTopic\": \"{{{depName}}} Docker tag\", \"major\": { \"enabled\": false }, \"commitMessageExtra\": \"to v{{#if isMajor}}{{{newMajor}}}{{else}}{{{newVersion}}}{{/if}}\", \"digest\": { \"branchTopic\": \"{{{depNameSanitized}}}-{{{currentValue}}}\", \"commitMessageExtra\": \"to {{newDigestShort}}\", \"commitMessageTopic\": \"{{{depName}}}{{#if currentValue}}:{{{currentValue}}}{{/if}} Docker digest\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}}\", \"commitMessageExtra\": \"\" } }, \"pin\": { \"commitMessageExtra\": \"\", \"groupName\": \"Docker digests\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}}\", \"branchTopic\": \"digests-pin\" } }, \"group\": { \"commitMessageTopic\": \"{{{groupName}}} Docker tags\" } }","title":"Docker Datasource"},{"location":"modules/datasource/#galaxy-datasource","text":"Identifier : galaxy","title":"Galaxy Datasource"},{"location":"modules/datasource/#git-refs-datasource","text":"Identifier : git-refs","title":"Git Refs Datasource"},{"location":"modules/datasource/#git-submodules-datasource","text":"Identifier : git-submodules Default configuration : { \"pinDigests\": false }","title":"Git Submodules Datasource"},{"location":"modules/datasource/#git-tags-datasource","text":"Identifier : git-tags","title":"Git Tags Datasource"},{"location":"modules/datasource/#github-releases-datasource","text":"Identifier : github-releases","title":"Github Releases Datasource"},{"location":"modules/datasource/#github-tags-datasource","text":"Identifier : github-tags","title":"Github Tags Datasource"},{"location":"modules/datasource/#gitlab-tags-datasource","text":"Identifier : gitlab-tags","title":"Gitlab Tags Datasource"},{"location":"modules/datasource/#go-datasource","text":"Identifier : go","title":"Go Datasource"},{"location":"modules/datasource/#gradle-version-datasource","text":"Identifier : gradle-version","title":"Gradle Version Datasource"},{"location":"modules/datasource/#helm-datasource","text":"Identifier : helm Default configuration : { \"additionalBranchPrefix\": \"helm-\", \"commitMessageTopic\": \"Helm release {{depName}}\", \"group\": { \"commitMessageTopic\": \"{{{groupName}}} Helm releases\" } }","title":"Helm Datasource"},{"location":"modules/datasource/#hex-datasource","text":"Identifier : hex","title":"Hex Datasource"},{"location":"modules/datasource/#jenkins-plugins-datasource","text":"Identifier : jenkins-plugins","title":"Jenkins Plugins Datasource"},{"location":"modules/datasource/#maven-datasource","text":"Identifier : maven","title":"Maven Datasource"},{"location":"modules/datasource/#npm-datasource","text":"Identifier : npm","title":"Npm Datasource"},{"location":"modules/datasource/#nuget-datasource","text":"Identifier : nuget","title":"Nuget Datasource"},{"location":"modules/datasource/#orb-datasource","text":"Identifier : orb","title":"Orb Datasource"},{"location":"modules/datasource/#packagist-datasource","text":"Identifier : packagist","title":"Packagist Datasource"},{"location":"modules/datasource/#pod-datasource","text":"Identifier : pod","title":"Pod Datasource"},{"location":"modules/datasource/#pypi-datasource","text":"Identifier : pypi","title":"Pypi Datasource"},{"location":"modules/datasource/#repology-datasource","text":"Identifier : repology Description : Repology supports looking up package versions from a wide variety of package repositories and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the lookupName has to contain the repository identifier and the package name itself, separated by a slash. As an example, alpine_3_12/gcc would look for a binary or source package called gcc within the alpine_3_12 repository. A list of all supported repositories can be found on the Repology homepage. To determine the correct identifier, click on a repository of your choice and make note of the identifier in the URL: https://repology.org/repository/<identifier> As an example, the Alpine Linux 3.12 repository points to https://repology.org/repository/alpine_3_12 and therefor has the repository identifier alpine_3_12 . Usage Example A real world example for this specific datasource would be maintaining system packages within a Dockerfile, as this allows to specifically pin each dependency without having to manually keep the versions up-to-date. This can be achieved by configuring a generic regex manager in renovate.json for files named Dockerfile : { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"#\\\\s*renovate:\\\\s*datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\": \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use regular comments in your Dockerfile to automatically update dependencies, which could look like this: FROM alpine:3.12.0@sha256:a15790640a6690aa1730c38cf0a440e2aa44aaca9b0e8931a9f2b0d7cc90fd65 # renovate: datasource=repology depName=alpine_3_12/gcc versioning=loose ENV GCC_VERSION=\"9.3.0-r2\" # renovate: datasource=repology depName=alpine_3_12/musl-dev versioning=loose ENV MUSL_DEV_VERSION=\"1.1.24-r8\" RUN apk add --no-cache \\ gcc=\"${GCC_VERSION}\" \\ musl-dev=\"${MUSL_DEV_VERSION}\" It is often wise to use the loose versioning for distribution packages as the version number usually does not strictly match the semver specification which is used by default. Now whenever the OS package for gcc of Alpine Linux 3.12 is being updated, Renovate will automatically adjust the value of the environment variable to the newest version.","title":"Repology Datasource"},{"location":"modules/datasource/#ruby-version-datasource","text":"Identifier : ruby-version","title":"Ruby Version Datasource"},{"location":"modules/datasource/#rubygems-datasource","text":"Identifier : rubygems","title":"Rubygems Datasource"},{"location":"modules/datasource/#sbt-package-datasource","text":"Identifier : sbt-package","title":"Sbt Package Datasource"},{"location":"modules/datasource/#sbt-plugin-datasource","text":"Identifier : sbt-plugin","title":"Sbt Plugin Datasource"},{"location":"modules/datasource/#terraform-module-datasource","text":"Identifier : terraform-module","title":"Terraform Module Datasource"},{"location":"modules/datasource/#terraform-provider-datasource","text":"Identifier : terraform-provider","title":"Terraform Provider Datasource"},{"location":"modules/manager/","text":"Managers Renovate is based around the concept of \"package managers\", or \"managers\" for short. These range from traditional package managers like npm, Bundler and Composer through to less traditional concepts like CircleCI or Travis config files. The goal of Renovate is to detect and maintain all third party dependencies in your repositories, through the use of managers. Supported Managers docker : ansible , docker-compose , dockerfile , droneci , github-actions , gitlabci , kubernetes dotnet : nuget elixir : mix golang : gomod java : gradle , maven js : meteor , npm node : nodenv , nvm , travis php : composer python : pip_requirements , pip_setup , pipenv , poetry , setup-cfg ruby : bundler , ruby-version rust : cargo other : ansible-galaxy , azure-pipelines , batect , batect-wrapper , bazel , buildkite , cdnurl , circleci , cloudbuild , cocoapods , deps-edn , git-submodules , gitlabci-include , gradle-lite , gradle-wrapper , helm-requirements , helm-values , helmfile , helmv3 , homebrew , html , jenkins , kustomize , leiningen , pre-commit , pub , regex , sbt , swift , terraform , terraform-version , terragrunt , terragrunt-version Configuring Managers File Matching Most managers have a default fileMatch array. The fileMatch array contains regular expression strings that match against the repository file list. Managers with no default fileMatch Some managers have no default fileMatch regular expression, because they have no filename convention that would let Renovate intelligently filter them. In such a case, the manager will be disabled until you create a fileMatch regular expression, e.g. like the following: { \"kubernetes\": { \"fileMatch\": [\"^config/.*\\\\.yaml$\"] } } Extending a manager's default fileMatch If the default fileMatch regular expression for a manager does not match against one of your relevant files, you can extend the existing regular expression(s) by configuring a manager's fileMatch like in this example: { \"dockerfile\": { \"fileMatch\": [\"does-not-look-like-a-docker-file\"] } } Ignoring files that match the default fileMatch Renovate will extend the existing fileMatch , meaning you don't need to include the default regular expressions like Dockerfile in your own array. In other words, the regular expression are \"additive\". If a manager matches a file that you don't want it to, ignore it using the ignorePaths configuration option. Also, if you ever find that Renovate is not matching a file name that you're certain it should, check your preset config isn't the cause of it. The config:base preset ignores common test and example directory names, for example. Enabling and disabling managers Enabling experimental managers Most managers are enabled by default. For those that aren't, typically because they are considered experimental, you can opt-in manually. If there was a manager called some-new-manager you would enable it like this: { \"some-new-manager\": { \"enabled\": true } } Disabling managers To disable a specific manager like gradle , do this: { \"gradle\": { \"enabled\": false } } To disable all managers within a language like python , do this: { \"python\": { \"enabled\": false } } Only languages declared by a Renovate manager are supported. Please check the list of supported managers . Limiting enabled managers Say you only want to use Renovate for JavaScript packages, and to update your Dockerfile, and don't want any other updates. You can use the enabledManagers array, to list the managers you want to use ( npm , dockerfile ): { \"enabledManagers\": [\"npm\", \"dockerfile\"] } Using the enabledManager array disables all other managers, this includes Bundler, Composer, Docker Compose, etc.","title":"Managers"},{"location":"modules/manager/#managers","text":"Renovate is based around the concept of \"package managers\", or \"managers\" for short. These range from traditional package managers like npm, Bundler and Composer through to less traditional concepts like CircleCI or Travis config files. The goal of Renovate is to detect and maintain all third party dependencies in your repositories, through the use of managers.","title":"Managers"},{"location":"modules/manager/#supported-managers","text":"docker : ansible , docker-compose , dockerfile , droneci , github-actions , gitlabci , kubernetes dotnet : nuget elixir : mix golang : gomod java : gradle , maven js : meteor , npm node : nodenv , nvm , travis php : composer python : pip_requirements , pip_setup , pipenv , poetry , setup-cfg ruby : bundler , ruby-version rust : cargo other : ansible-galaxy , azure-pipelines , batect , batect-wrapper , bazel , buildkite , cdnurl , circleci , cloudbuild , cocoapods , deps-edn , git-submodules , gitlabci-include , gradle-lite , gradle-wrapper , helm-requirements , helm-values , helmfile , helmv3 , homebrew , html , jenkins , kustomize , leiningen , pre-commit , pub , regex , sbt , swift , terraform , terraform-version , terragrunt , terragrunt-version","title":"Supported Managers"},{"location":"modules/manager/#configuring-managers","text":"","title":"Configuring Managers"},{"location":"modules/manager/#file-matching","text":"Most managers have a default fileMatch array. The fileMatch array contains regular expression strings that match against the repository file list.","title":"File Matching"},{"location":"modules/manager/#managers-with-no-default-filematch","text":"Some managers have no default fileMatch regular expression, because they have no filename convention that would let Renovate intelligently filter them. In such a case, the manager will be disabled until you create a fileMatch regular expression, e.g. like the following: { \"kubernetes\": { \"fileMatch\": [\"^config/.*\\\\.yaml$\"] } }","title":"Managers with no default fileMatch"},{"location":"modules/manager/#extending-a-managers-default-filematch","text":"If the default fileMatch regular expression for a manager does not match against one of your relevant files, you can extend the existing regular expression(s) by configuring a manager's fileMatch like in this example: { \"dockerfile\": { \"fileMatch\": [\"does-not-look-like-a-docker-file\"] } }","title":"Extending a manager's default fileMatch"},{"location":"modules/manager/#ignoring-files-that-match-the-default-filematch","text":"Renovate will extend the existing fileMatch , meaning you don't need to include the default regular expressions like Dockerfile in your own array. In other words, the regular expression are \"additive\". If a manager matches a file that you don't want it to, ignore it using the ignorePaths configuration option. Also, if you ever find that Renovate is not matching a file name that you're certain it should, check your preset config isn't the cause of it. The config:base preset ignores common test and example directory names, for example.","title":"Ignoring files that match the default fileMatch"},{"location":"modules/manager/#enabling-and-disabling-managers","text":"","title":"Enabling and disabling managers"},{"location":"modules/manager/#enabling-experimental-managers","text":"Most managers are enabled by default. For those that aren't, typically because they are considered experimental, you can opt-in manually. If there was a manager called some-new-manager you would enable it like this: { \"some-new-manager\": { \"enabled\": true } }","title":"Enabling experimental managers"},{"location":"modules/manager/#disabling-managers","text":"To disable a specific manager like gradle , do this: { \"gradle\": { \"enabled\": false } } To disable all managers within a language like python , do this: { \"python\": { \"enabled\": false } } Only languages declared by a Renovate manager are supported. Please check the list of supported managers .","title":"Disabling managers"},{"location":"modules/manager/#limiting-enabled-managers","text":"Say you only want to use Renovate for JavaScript packages, and to update your Dockerfile, and don't want any other updates. You can use the enabledManagers array, to list the managers you want to use ( npm , dockerfile ): { \"enabledManagers\": [\"npm\", \"dockerfile\"] } Using the enabledManager array disables all other managers, this includes Bundler, Composer, Docker Compose, etc.","title":"Limiting enabled managers"},{"location":"modules/platform/","text":"Renovate Platforms Renovate aims to be platform-neutral, while also taking advantage of good platform-specific features. The currently supported platforms are: Azure DevOps (dev.azure.com) Azure DevOps Server (self-hosted) Bitbucket Cloud Bitbucket Server GitHub (github.com, GitHub Enterprise) GitLab (gitlab.com, self-hosted) Gitea (gitea.com, self-hosted)","title":"Platforms"},{"location":"modules/platform/#renovate-platforms","text":"Renovate aims to be platform-neutral, while also taking advantage of good platform-specific features. The currently supported platforms are: Azure DevOps (dev.azure.com) Azure DevOps Server (self-hosted) Bitbucket Cloud Bitbucket Server GitHub (github.com, GitHub Enterprise) GitLab (gitlab.com, self-hosted) Gitea (gitea.com, self-hosted)","title":"Renovate Platforms"},{"location":"modules/versioning/","text":"Versioning Once Managers have extracted dependencies, and Datasources have located available versions, then Renovate will use a \"Versioning\" scheme to perform sorting and filtering of results. The \"versioning\" is different for each package manager, because different package managers use different versioning schemes. For example, npm uses 1.0.0-beta.1 and pip uses 1.0.0b1 . Configuring Versioning You can manually configure/override the versioning value for a particular dependency. You generally won't need to override the defaults for ecosystems which enforce a strict version scheme like npm . Configuring or overriding the default versioning can be helpful for ecosystems like Docker, where versioning is barely a \"convention\". e.g. { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"pep440\" } ] } The above will override Renovate's default of docker versioning for the python Docker image and instead use pep440 versioning to evaluate versions. Supported Versioning Supported values for versioning are: cargo , composer , docker , git , gradle , hashicorp , hex , ivy , loose , maven , node , npm , nuget , pep440 , poetry , regex , ruby , semver , swift , ubuntu . Cargo Versioning Identifier : cargo References : https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Cargo versioning uses Semantic Versioning 2.0 . Cargo supports ranges in a similar manner to npm, but not identical. The important differences are: Use of commas Multiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5 . We interpret this to mean AND. No exact versions unless using equals = In Cargo, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >=1.2.3 <2.0.0 . So this is like the equivalent of ^1.2.3 in npm. Composer Versioning Identifier : composer References : https://getcomposer.org/doc/articles/versions.md https://packagist.org/packages/composer/semver https://madewithlove.be/tilde-and-caret-constraints/ https://semver.mwl.be Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Composer uses Semver-like versioning, however some package authors may use versions that are not completely valid, e.g. 1.2 instead of 1.2.0 . Composer supports ranges in a similar manner to npm, but not identical. The main difference is with tilde ranges. Tilde ranges with \"short\" versions are different to npm. e.g. ~4 is equivalent to ^4 in npm ~4.1 is equivalent to ^4.1 in npm ~0.4 is equivalent to >=0.4 <1 in npm Docker Versioning Identifier : docker References : https://docs.docker.com/engine/reference/commandline/tag/ Ranges/Constraints: \u274c No range support. Description : Docker doesn't really have versioning , instead it supports \"tags\" and these are usually used by Docker image authors as a form of versioning. This Docker versioning implementation in Renovate is designed to handle the most common conventions used in tagging images. In particular, it treats the text after the first hyphen as a type of platform/compatibility indicator. For example, many images include images with the \"-alpine\" suffix, e.g. the official node Docker image includes tags like 12.15.0-alpine which is not compatible with 12.15.0 or 12.15.0-stretch . This means users only want/expect upgrades to 12.16.0-alpine and not 12.16.0 or 12.16.0-stretch . Similarly, a user with 12.14 expects to be upgraded to 12.15 and not 12.15.0 . What type of versioning is used? It's pretty \"wild west\" for tagging and not always compliant with SemVer. Docker versioning in Renovate should do a best effort to accept and sort SemVer-like versions. Are ranges supported? No. Although a tag like 12.15 might seem like it means 12.15.x , it is a tag of its own and may or may not point to an of the available 12.15.x tags, including 12.15.0 . Are commit hashes supported? No. An image tag that looks like a Git commit hash should be ignored by Renovate. git Versioning Identifier : git References : https://git-scm.com/ Ranges/Constraints: \u274c No range support. Description : Renovate's git versioning is a kind of hack to support git submodule updating. Gradle Versioning Identifier : gradle References : https://docs.gradle.org/current/userguide/single_versions.html#version_ordering Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin Hashicorp Versioning Identifier : hashicorp References : https://www.terraform.io/docs/configuration/terraform.html#specifying-a-required-terraform-version Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Hashicorp versioning syntax is used for Terraform. It is based off Semantic Versioning 2.0 but with a subset of npm's range syntax. Hex Versioning Identifier : hex References : https://hexdocs.pm/elixir/Version.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Hex versioning syntax is used for Elixir and Erlang hex dependencies. It is based on Semantic Versioning 2.0 and supports a subset of npm's range syntax. Ivy Versioning Identifier : ivy References : https://ant.apache.org/ivy/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Loose Versioning Identifier : loose Ranges/Constraints: \u274c No range support. Description : Renovate's \"loose\" versioning was created for cases where no strict versioning is in place. It works like SemVer if SemVer-compliant versions are supplied, but otherwise is \"best effort\". Essentially it just does its best to sort versions and ignore versions that are not sortable. Maven Versioning Identifier : maven References : https://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification https://octopus.com/blog/maven-versioning-explained https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Maven versioning is similar to SemVer but also very different in places. It's specified by Maven itself. Ranges are supported using Maven's special syntax. Node.js Versioning Identifier : node Ranges/Constraints: \u274c No range support. Description : Renovate's Node.js versioning is a wrapper around npm's versioning, except that it makes sure to strip \"v\" prefixes from exact versions when replacing. It is planned to extend it one day to support \"stability\" awareness, because Node.js's version stability does not follow the SemVer approach. npm Versioning Identifier : npm References : https://semver.org/ https://www.npmjs.com/package/semver https://docs.npmjs.com/about-semantic-versioning https://semver.npmjs.com/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : npm versioning is the most well known/widely-used implementation of Semantic Versioning 2.0 . It's important to understand that \"npm\" versioning scheme is not the same as \"semver\" versioning. SemVer's spec does not define ranges at all - so all range/constraint syntax in npm is npm-specific and not part of the spec. NuGet Versioning Identifier : nuget References : https://docs.microsoft.com/en-us/nuget/concepts/package-versioning Ranges/Constraints: \u274c No range support. Description : NuGet versioning matches as closely as possible to the version comparison that NuGet itself uses. NuGet supports SemVer 2.0.0, but permits versions with differing numbers of version parts. Ranges are not yet supported by this versioning, but they are defined in NuGet and could be supported in the future. PEP440 Versioning Identifier : pep440 References : https://www.python.org/dev/peps/pep-0440/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : PEP 440 is defined as part of the Python project, and its versioning is independent of others such as SemVer. Ranges are supported using the syntax defined as part of the PEP440 spec. Poetry Versioning Identifier : poetry References : https://python-poetry.org/docs/versions/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Poetry versioning is a little like a mix of PEP440 and SemVer. Currently Renovate's implementation is based off npm versioning, but it is being migrated to be based off PEP440 to be more compatible with Poetry's behavior. Regular Expression Versioning Identifier : regex Ranges/Constraints: \u274c No range support. Description : Regular Expression Versioning is designed to be like a flexible fallback versioning approach is Renovate's other versioning schemes don't do the job. The regex scheme makes use of Regular Express capture groups. The valid capture groups for regex versioning are: major , minor , and patch : at least one of these must be provided. When determining whether a package has updated, these values will be compared in the standard semantic versioning fashion. If any of these fields are omitted, they will be treated as if they were 0 -- in this way, you can describe versioning schemes with up to three incrementing values. prerelease : this value, if captured, will mark a given release as a prerelease (eg. unstable). If this value is captured and you have configured \"ignoreUnstable\": true , the given release will be skipped. compatibility : this value defines the \"build compatibility\" of a given dependency. A proposed Renovate update will never change the specified compatibility value. For example, if you are pinning to 1.2.3-linux (and linux is captured as the compatibility value), Renovate will not update you to 1.2.4-osx . The compatibility concept was originally introduced for Docker versioning but sometimes package authors may use/misuse suffixes to mean compatibility in other versioning schemes. Here is an example of using regex versioning to correct behavior of the guava Maven package, which misuses suffixes as compatibility indicators: { \"packageRules\": [ { \"matchPackageNames\": [\"com.google.guava:guava\"], \"versioning\": \"regex:^(?<major>\\\\d+)(\\\\.(?<minor>\\\\d+))?(\\\\.(?<patch>\\\\d+))?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling python Docker images, which use both pre-release indicators as well as version suffixes for compatibility: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(?<prerelease>[^.-]+)?(-(?<compatibility>.*))?$\" } ] } Ruby Versioning Identifier : ruby References : https://guides.rubygems.org/patterns/ https://bundler.io/v1.5/gemfile.html https://www.devalot.com/articles/2012/04/gem-versions.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : The RubyGems team urges gem developers to follow the Semantic Versioning standard for their gem\u2019s versions, but it is not enforced. Range syntax is similar to npm's but not identical. The main difference is the use of \"pessimistic\" greater than or equals: ~> Semantic Versioning Identifier : semver References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Semantic Versioning is a strict/independent implementation of Semantic Versioning 2.0 . It has been developed to be used in situations where exact-only SemVer support is needed and not npm's extended semver implementation including ranges. Ranges are not supported, as per the specification. Swift Versioning Identifier : swift References : https://swift.org/package-manager/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Swift versioning was developed to support the Swift Package Manager. It's based on Semantic versioning but includes its own concept of ranges. Ubuntu Versioning Identifier : ubuntu References : https://changelogs.ubuntu.com/meta-release Ranges/Constraints: \u274c No range support.","title":"Versioning"},{"location":"modules/versioning/#versioning","text":"Once Managers have extracted dependencies, and Datasources have located available versions, then Renovate will use a \"Versioning\" scheme to perform sorting and filtering of results. The \"versioning\" is different for each package manager, because different package managers use different versioning schemes. For example, npm uses 1.0.0-beta.1 and pip uses 1.0.0b1 .","title":"Versioning"},{"location":"modules/versioning/#configuring-versioning","text":"You can manually configure/override the versioning value for a particular dependency. You generally won't need to override the defaults for ecosystems which enforce a strict version scheme like npm . Configuring or overriding the default versioning can be helpful for ecosystems like Docker, where versioning is barely a \"convention\". e.g. { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"pep440\" } ] } The above will override Renovate's default of docker versioning for the python Docker image and instead use pep440 versioning to evaluate versions.","title":"Configuring Versioning"},{"location":"modules/versioning/#supported-versioning","text":"Supported values for versioning are: cargo , composer , docker , git , gradle , hashicorp , hex , ivy , loose , maven , node , npm , nuget , pep440 , poetry , regex , ruby , semver , swift , ubuntu .","title":"Supported Versioning"},{"location":"modules/versioning/#cargo-versioning","text":"Identifier : cargo References : https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Cargo versioning uses Semantic Versioning 2.0 . Cargo supports ranges in a similar manner to npm, but not identical. The important differences are: Use of commas Multiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5 . We interpret this to mean AND. No exact versions unless using equals = In Cargo, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >=1.2.3 <2.0.0 . So this is like the equivalent of ^1.2.3 in npm.","title":"Cargo Versioning"},{"location":"modules/versioning/#composer-versioning","text":"Identifier : composer References : https://getcomposer.org/doc/articles/versions.md https://packagist.org/packages/composer/semver https://madewithlove.be/tilde-and-caret-constraints/ https://semver.mwl.be Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Composer uses Semver-like versioning, however some package authors may use versions that are not completely valid, e.g. 1.2 instead of 1.2.0 . Composer supports ranges in a similar manner to npm, but not identical. The main difference is with tilde ranges. Tilde ranges with \"short\" versions are different to npm. e.g. ~4 is equivalent to ^4 in npm ~4.1 is equivalent to ^4.1 in npm ~0.4 is equivalent to >=0.4 <1 in npm","title":"Composer Versioning"},{"location":"modules/versioning/#docker-versioning","text":"Identifier : docker References : https://docs.docker.com/engine/reference/commandline/tag/ Ranges/Constraints: \u274c No range support. Description : Docker doesn't really have versioning , instead it supports \"tags\" and these are usually used by Docker image authors as a form of versioning. This Docker versioning implementation in Renovate is designed to handle the most common conventions used in tagging images. In particular, it treats the text after the first hyphen as a type of platform/compatibility indicator. For example, many images include images with the \"-alpine\" suffix, e.g. the official node Docker image includes tags like 12.15.0-alpine which is not compatible with 12.15.0 or 12.15.0-stretch . This means users only want/expect upgrades to 12.16.0-alpine and not 12.16.0 or 12.16.0-stretch . Similarly, a user with 12.14 expects to be upgraded to 12.15 and not 12.15.0 . What type of versioning is used? It's pretty \"wild west\" for tagging and not always compliant with SemVer. Docker versioning in Renovate should do a best effort to accept and sort SemVer-like versions. Are ranges supported? No. Although a tag like 12.15 might seem like it means 12.15.x , it is a tag of its own and may or may not point to an of the available 12.15.x tags, including 12.15.0 . Are commit hashes supported? No. An image tag that looks like a Git commit hash should be ignored by Renovate.","title":"Docker Versioning"},{"location":"modules/versioning/#git-versioning","text":"Identifier : git References : https://git-scm.com/ Ranges/Constraints: \u274c No range support. Description : Renovate's git versioning is a kind of hack to support git submodule updating.","title":"git Versioning"},{"location":"modules/versioning/#gradle-versioning","text":"Identifier : gradle References : https://docs.gradle.org/current/userguide/single_versions.html#version_ordering Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin","title":"Gradle Versioning"},{"location":"modules/versioning/#hashicorp-versioning","text":"Identifier : hashicorp References : https://www.terraform.io/docs/configuration/terraform.html#specifying-a-required-terraform-version Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Hashicorp versioning syntax is used for Terraform. It is based off Semantic Versioning 2.0 but with a subset of npm's range syntax.","title":"Hashicorp Versioning"},{"location":"modules/versioning/#hex-versioning","text":"Identifier : hex References : https://hexdocs.pm/elixir/Version.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Hex versioning syntax is used for Elixir and Erlang hex dependencies. It is based on Semantic Versioning 2.0 and supports a subset of npm's range syntax.","title":"Hex Versioning"},{"location":"modules/versioning/#ivy-versioning","text":"Identifier : ivy References : https://ant.apache.org/ivy/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace","title":"Ivy Versioning"},{"location":"modules/versioning/#loose-versioning","text":"Identifier : loose Ranges/Constraints: \u274c No range support. Description : Renovate's \"loose\" versioning was created for cases where no strict versioning is in place. It works like SemVer if SemVer-compliant versions are supplied, but otherwise is \"best effort\". Essentially it just does its best to sort versions and ignore versions that are not sortable.","title":"Loose Versioning"},{"location":"modules/versioning/#maven-versioning","text":"Identifier : maven References : https://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification https://octopus.com/blog/maven-versioning-explained https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Maven versioning is similar to SemVer but also very different in places. It's specified by Maven itself. Ranges are supported using Maven's special syntax.","title":"Maven Versioning"},{"location":"modules/versioning/#nodejs-versioning","text":"Identifier : node Ranges/Constraints: \u274c No range support. Description : Renovate's Node.js versioning is a wrapper around npm's versioning, except that it makes sure to strip \"v\" prefixes from exact versions when replacing. It is planned to extend it one day to support \"stability\" awareness, because Node.js's version stability does not follow the SemVer approach.","title":"Node.js Versioning"},{"location":"modules/versioning/#npm-versioning","text":"Identifier : npm References : https://semver.org/ https://www.npmjs.com/package/semver https://docs.npmjs.com/about-semantic-versioning https://semver.npmjs.com/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : npm versioning is the most well known/widely-used implementation of Semantic Versioning 2.0 . It's important to understand that \"npm\" versioning scheme is not the same as \"semver\" versioning. SemVer's spec does not define ranges at all - so all range/constraint syntax in npm is npm-specific and not part of the spec.","title":"npm Versioning"},{"location":"modules/versioning/#nuget-versioning","text":"Identifier : nuget References : https://docs.microsoft.com/en-us/nuget/concepts/package-versioning Ranges/Constraints: \u274c No range support. Description : NuGet versioning matches as closely as possible to the version comparison that NuGet itself uses. NuGet supports SemVer 2.0.0, but permits versions with differing numbers of version parts. Ranges are not yet supported by this versioning, but they are defined in NuGet and could be supported in the future.","title":"NuGet Versioning"},{"location":"modules/versioning/#pep440-versioning","text":"Identifier : pep440 References : https://www.python.org/dev/peps/pep-0440/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : PEP 440 is defined as part of the Python project, and its versioning is independent of others such as SemVer. Ranges are supported using the syntax defined as part of the PEP440 spec.","title":"PEP440 Versioning"},{"location":"modules/versioning/#poetry-versioning","text":"Identifier : poetry References : https://python-poetry.org/docs/versions/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Poetry versioning is a little like a mix of PEP440 and SemVer. Currently Renovate's implementation is based off npm versioning, but it is being migrated to be based off PEP440 to be more compatible with Poetry's behavior.","title":"Poetry Versioning"},{"location":"modules/versioning/#regular-expression-versioning","text":"Identifier : regex Ranges/Constraints: \u274c No range support. Description : Regular Expression Versioning is designed to be like a flexible fallback versioning approach is Renovate's other versioning schemes don't do the job. The regex scheme makes use of Regular Express capture groups. The valid capture groups for regex versioning are: major , minor , and patch : at least one of these must be provided. When determining whether a package has updated, these values will be compared in the standard semantic versioning fashion. If any of these fields are omitted, they will be treated as if they were 0 -- in this way, you can describe versioning schemes with up to three incrementing values. prerelease : this value, if captured, will mark a given release as a prerelease (eg. unstable). If this value is captured and you have configured \"ignoreUnstable\": true , the given release will be skipped. compatibility : this value defines the \"build compatibility\" of a given dependency. A proposed Renovate update will never change the specified compatibility value. For example, if you are pinning to 1.2.3-linux (and linux is captured as the compatibility value), Renovate will not update you to 1.2.4-osx . The compatibility concept was originally introduced for Docker versioning but sometimes package authors may use/misuse suffixes to mean compatibility in other versioning schemes. Here is an example of using regex versioning to correct behavior of the guava Maven package, which misuses suffixes as compatibility indicators: { \"packageRules\": [ { \"matchPackageNames\": [\"com.google.guava:guava\"], \"versioning\": \"regex:^(?<major>\\\\d+)(\\\\.(?<minor>\\\\d+))?(\\\\.(?<patch>\\\\d+))?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling python Docker images, which use both pre-release indicators as well as version suffixes for compatibility: { \"packageRules\": [ { \"matchDatasources\": [\"docker\"], \"matchPackageNames\": [\"python\"], \"versioning\": \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(?<prerelease>[^.-]+)?(-(?<compatibility>.*))?$\" } ] }","title":"Regular Expression Versioning"},{"location":"modules/versioning/#ruby-versioning","text":"Identifier : ruby References : https://guides.rubygems.org/patterns/ https://bundler.io/v1.5/gemfile.html https://www.devalot.com/articles/2012/04/gem-versions.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : The RubyGems team urges gem developers to follow the Semantic Versioning standard for their gem\u2019s versions, but it is not enforced. Range syntax is similar to npm's but not identical. The main difference is the use of \"pessimistic\" greater than or equals: ~>","title":"Ruby Versioning"},{"location":"modules/versioning/#semantic-versioning","text":"Identifier : semver References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Semantic Versioning is a strict/independent implementation of Semantic Versioning 2.0 . It has been developed to be used in situations where exact-only SemVer support is needed and not npm's extended semver implementation including ranges. Ranges are not supported, as per the specification.","title":"Semantic Versioning"},{"location":"modules/versioning/#swift-versioning","text":"Identifier : swift References : https://swift.org/package-manager/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , extend , pin , replace Description : Swift versioning was developed to support the Swift Package Manager. It's based on Semantic versioning but includes its own concept of ranges.","title":"Swift Versioning"},{"location":"modules/versioning/#ubuntu-versioning","text":"Identifier : ubuntu References : https://changelogs.ubuntu.com/meta-release Ranges/Constraints: \u274c No range support.","title":"Ubuntu Versioning"},{"location":"modules/manager/ansible/","text":"Automated Dependency Updates for Ansible Renovate supports updating Ansible dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)tasks/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Supports Docker-type dependency extraction from Ansible configuration files.","title":"Automated Dependency Updates for Ansible"},{"location":"modules/manager/ansible/#automated-dependency-updates-for-ansible","text":"Renovate supports updating Ansible dependencies.","title":"Automated Dependency Updates for Ansible"},{"location":"modules/manager/ansible/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)tasks/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ansible/#additional-information","text":"Supports Docker-type dependency extraction from Ansible configuration files.","title":"Additional Information"},{"location":"modules/manager/ansible-galaxy/","text":"Automated Dependency Updates for Ansible Galaxy Renovate supports updating Ansible Galaxy dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts Ansible Galaxy dependencies from configuration files used by the ansible-galaxy CLI tool.","title":"Automated Dependency Updates for Ansible Galaxy"},{"location":"modules/manager/ansible-galaxy/#automated-dependency-updates-for-ansible-galaxy","text":"Renovate supports updating Ansible Galaxy dependencies.","title":"Automated Dependency Updates for Ansible Galaxy"},{"location":"modules/manager/ansible-galaxy/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ansible-galaxy/#additional-information","text":"Extracts Ansible Galaxy dependencies from configuration files used by the ansible-galaxy CLI tool.","title":"Additional Information"},{"location":"modules/manager/azure-pipelines/","text":"Automated Dependency Updates for Azure Pipelines Renovate supports updating Azure Pipelines dependencies. File Matching By default, Renovate will check any files matching the following regular expression: azure.*pipelines?.*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The azure-pipelines manager extracts container and repository resources from the resources: block. For example: resources: repositories: - type: github name: renovate/renovate ref: refs/heads/master - type: github name: user/repo ref: refs/tags/v0.5.1 containers: - container: linux image: ubuntu:16.04 - container: python image: python:3.7@sha256:3870d35b962a943df72d948580fc66ceaaee1c4fbd205930f32e0f0760eb1077 More about the resources block can be found on the Azure pipelines documentation . Files that are processed by the manager includes: .azure-pipelines/**/*.yaml .azure-pipelines.yaml .azure-pipelines.yml azure-pipelines/**/*.yaml azure-pipelines.yaml azure-pipelines.yml azure-pipeline/**/*.yaml azure-pipeline.yaml azure-pipeline.yml","title":"Automated Dependency Updates for Azure Pipelines"},{"location":"modules/manager/azure-pipelines/#automated-dependency-updates-for-azure-pipelines","text":"Renovate supports updating Azure Pipelines dependencies.","title":"Automated Dependency Updates for Azure Pipelines"},{"location":"modules/manager/azure-pipelines/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: azure.*pipelines?.*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/azure-pipelines/#additional-information","text":"The azure-pipelines manager extracts container and repository resources from the resources: block. For example: resources: repositories: - type: github name: renovate/renovate ref: refs/heads/master - type: github name: user/repo ref: refs/tags/v0.5.1 containers: - container: linux image: ubuntu:16.04 - container: python image: python:3.7@sha256:3870d35b962a943df72d948580fc66ceaaee1c4fbd205930f32e0f0760eb1077 More about the resources block can be found on the Azure pipelines documentation . Files that are processed by the manager includes: .azure-pipelines/**/*.yaml .azure-pipelines.yaml .azure-pipelines.yml azure-pipelines/**/*.yaml azure-pipelines.yaml azure-pipelines.yml azure-pipeline/**/*.yaml azure-pipeline.yaml azure-pipeline.yml","title":"Additional Information"},{"location":"modules/manager/batect/","text":"Automated Dependency Updates for Batect Renovate supports updating Batect dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)batect(-bundle)?\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts all Docker images and Batect bundles from Batect configuration files. For updates to Batect itself, see batect-wrapper . Files searched By default, the manager searches for files called batect.yml or batect-bundle.yml . If you keep your Batect configuration in other files, you'll need to tell Renovate where to find them. Files included in your main configuration file with include don't need to be listed. You do this by creating a \"batect\" object in your renovate.json file. This object should contain a fileMatch array with regular expressions that match the configuration file names. For example: { \"batect\": { \"fileMatch\": [ \"(^|/)batect(-bundle)?\\\\.yml$\", \"(^|/)my-other-batect-file\\\\.yml$\", \"^a-directory/[^/]*\\\\.yml$\" ] } } Bundle versioning This manager assumes that any bundles referenced use tags for versioning, and that these tags use SemVer . The implementation of SemVer is strict - versions must follow the X.Y.Z or vX.Y.Z format. Versions that don't match this format (eg. X.Y ) will be ignored.","title":"Automated Dependency Updates for Batect"},{"location":"modules/manager/batect/#automated-dependency-updates-for-batect","text":"Renovate supports updating Batect dependencies.","title":"Automated Dependency Updates for Batect"},{"location":"modules/manager/batect/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)batect(-bundle)?\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/batect/#additional-information","text":"Extracts all Docker images and Batect bundles from Batect configuration files. For updates to Batect itself, see batect-wrapper .","title":"Additional Information"},{"location":"modules/manager/batect/#files-searched","text":"By default, the manager searches for files called batect.yml or batect-bundle.yml . If you keep your Batect configuration in other files, you'll need to tell Renovate where to find them. Files included in your main configuration file with include don't need to be listed. You do this by creating a \"batect\" object in your renovate.json file. This object should contain a fileMatch array with regular expressions that match the configuration file names. For example: { \"batect\": { \"fileMatch\": [ \"(^|/)batect(-bundle)?\\\\.yml$\", \"(^|/)my-other-batect-file\\\\.yml$\", \"^a-directory/[^/]*\\\\.yml$\" ] } }","title":"Files searched"},{"location":"modules/manager/batect/#bundle-versioning","text":"This manager assumes that any bundles referenced use tags for versioning, and that these tags use SemVer . The implementation of SemVer is strict - versions must follow the X.Y.Z or vX.Y.Z format. Versions that don't match this format (eg. X.Y ) will be ignored.","title":"Bundle versioning"},{"location":"modules/manager/batect-wrapper/","text":"Automated Dependency Updates for Batect Wrapper Renovate supports updating Batect Wrapper dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)batect$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Configuration for Batect wrapper updates. The default configuration will automatically update both batect and batect.cmd , similar to running ./batect --upgrade . See also: Batect image reference updates","title":"Automated Dependency Updates for Batect Wrapper"},{"location":"modules/manager/batect-wrapper/#automated-dependency-updates-for-batect-wrapper","text":"Renovate supports updating Batect Wrapper dependencies.","title":"Automated Dependency Updates for Batect Wrapper"},{"location":"modules/manager/batect-wrapper/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)batect$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/batect-wrapper/#additional-information","text":"Configuration for Batect wrapper updates. The default configuration will automatically update both batect and batect.cmd , similar to running ./batect --upgrade . See also: Batect image reference updates","title":"Additional Information"},{"location":"modules/manager/bazel/","text":"Automated Dependency Updates for Bazel Renovate supports updating Bazel dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: (^|/)WORKSPACE(|\\.bazel)$ \\.bzl$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Bazel is quite unlike most other \"package managers\" that Renovate supports, which usually focus on a particular ecosystem like JavaScript, Ruby or Docker. Instead, Bazel is a build tool so supports a multitude of languages/datasources. Renovate does not support all possible Bazel references, although would like to, and feature requests are welcome.","title":"Automated Dependency Updates for Bazel"},{"location":"modules/manager/bazel/#automated-dependency-updates-for-bazel","text":"Renovate supports updating Bazel dependencies.","title":"Automated Dependency Updates for Bazel"},{"location":"modules/manager/bazel/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/)WORKSPACE(|\\.bazel)$ \\.bzl$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/bazel/#additional-information","text":"Bazel is quite unlike most other \"package managers\" that Renovate supports, which usually focus on a particular ecosystem like JavaScript, Ruby or Docker. Instead, Bazel is a build tool so supports a multitude of languages/datasources. Renovate does not support all possible Bazel references, although would like to, and feature requests are welcome.","title":"Additional Information"},{"location":"modules/manager/buildkite/","text":"Automated Dependency Updates for Buildkite Renovate supports updating Buildkite dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: buildkite\\.ya?ml \\.buildkite/.+\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Used for updating Docker dependencies in Buildkite configuration files.","title":"Automated Dependency Updates for Buildkite"},{"location":"modules/manager/buildkite/#automated-dependency-updates-for-buildkite","text":"Renovate supports updating Buildkite dependencies.","title":"Automated Dependency Updates for Buildkite"},{"location":"modules/manager/buildkite/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: buildkite\\.ya?ml \\.buildkite/.+\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/buildkite/#additional-information","text":"Used for updating Docker dependencies in Buildkite configuration files.","title":"Additional Information"},{"location":"modules/manager/bundler/","text":"Automated Dependency Updates for Bundler Renovate supports updating Bundler dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Gemfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The bundler manager is used to extract dependencies from Gemfile and Gemfile.lock files. Authenticating private registry If you need Bundler to authenticate with a private registry - and it's not the same host as your GitHub/GitLab/etc - then you should do so with hostRules and be sure to set the hostType value to be \"bundler\". e.g. { \"hostRules\": [ { \"hostName\": \"private-registry.company.com\", \"hostType\": \"bundler\", \"token\": \"abc123\" } ] } Important notes regarding the above: hostType=bundler is essential. If the registry is used for multiple package types then you may need multiple hostRules . You cannot leave off hostType . Instead of token , you may also supply username and password instead. If you don't want to commit raw secrets to your repository, either: If self hosting, add the hostRules to your bot's configuration file rather than the repository's configuration file, or If using the hosted WhiteSource Renovate app, make use of the encrypted capability","title":"Automated Dependency Updates for Bundler"},{"location":"modules/manager/bundler/#automated-dependency-updates-for-bundler","text":"Renovate supports updating Bundler dependencies.","title":"Automated Dependency Updates for Bundler"},{"location":"modules/manager/bundler/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Gemfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/bundler/#additional-information","text":"The bundler manager is used to extract dependencies from Gemfile and Gemfile.lock files.","title":"Additional Information"},{"location":"modules/manager/bundler/#authenticating-private-registry","text":"If you need Bundler to authenticate with a private registry - and it's not the same host as your GitHub/GitLab/etc - then you should do so with hostRules and be sure to set the hostType value to be \"bundler\". e.g. { \"hostRules\": [ { \"hostName\": \"private-registry.company.com\", \"hostType\": \"bundler\", \"token\": \"abc123\" } ] } Important notes regarding the above: hostType=bundler is essential. If the registry is used for multiple package types then you may need multiple hostRules . You cannot leave off hostType . Instead of token , you may also supply username and password instead. If you don't want to commit raw secrets to your repository, either: If self hosting, add the hostRules to your bot's configuration file rather than the repository's configuration file, or If using the hosted WhiteSource Renovate app, make use of the encrypted capability","title":"Authenticating private registry"},{"location":"modules/manager/cargo/","text":"Automated Dependency Updates for Cargo Renovate supports updating Cargo dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Cargo.toml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts dependencies from Cargo.toml files, and also updates Cargo.lock files too if found.","title":"Automated Dependency Updates for Cargo"},{"location":"modules/manager/cargo/#automated-dependency-updates-for-cargo","text":"Renovate supports updating Cargo dependencies.","title":"Automated Dependency Updates for Cargo"},{"location":"modules/manager/cargo/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Cargo.toml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cargo/#additional-information","text":"Extracts dependencies from Cargo.toml files, and also updates Cargo.lock files too if found.","title":"Additional Information"},{"location":"modules/manager/cdnurl/","text":"Automated Dependency Updates for Cdnurl Renovate supports updating Cdnurl dependencies. File Matching Because file names for cdnurl cannot be easily determined automatically, Renovate will not attempt to match any cdnurl files by default. For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Important : This manager isn't aware of subresource integrity (SRI) hashes. It will search/replace any matching url it finds, without consideration for things such as script integrity hashes. Use the html manager instead if you need SRI updating. To enable this manager, add the matching files to cdnurl.fileMatch . For example: { \"cdnurl\": { \"fileMatch\": [\"\\\\.html?$\"] } }","title":"Automated Dependency Updates for Cdnurl"},{"location":"modules/manager/cdnurl/#automated-dependency-updates-for-cdnurl","text":"Renovate supports updating Cdnurl dependencies.","title":"Automated Dependency Updates for Cdnurl"},{"location":"modules/manager/cdnurl/#file-matching","text":"Because file names for cdnurl cannot be easily determined automatically, Renovate will not attempt to match any cdnurl files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cdnurl/#additional-information","text":"Important : This manager isn't aware of subresource integrity (SRI) hashes. It will search/replace any matching url it finds, without consideration for things such as script integrity hashes. Use the html manager instead if you need SRI updating. To enable this manager, add the matching files to cdnurl.fileMatch . For example: { \"cdnurl\": { \"fileMatch\": [\"\\\\.html?$\"] } }","title":"Additional Information"},{"location":"modules/manager/circleci/","text":"Automated Dependency Updates for Circleci Renovate supports updating Circleci dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/).circleci/config.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The circleci manager extracts both docker as well as orb datasources from CircleCI config files.","title":"Automated Dependency Updates for Circleci"},{"location":"modules/manager/circleci/#automated-dependency-updates-for-circleci","text":"Renovate supports updating Circleci dependencies.","title":"Automated Dependency Updates for Circleci"},{"location":"modules/manager/circleci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).circleci/config.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/circleci/#additional-information","text":"The circleci manager extracts both docker as well as orb datasources from CircleCI config files.","title":"Additional Information"},{"location":"modules/manager/cloudbuild/","text":"Automated Dependency Updates for Cloudbuild Renovate supports updating Cloudbuild dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)cloudbuild.ya?ml . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The cloudbuild manager extracts docker datasources from Cloud Build config files .","title":"Automated Dependency Updates for Cloudbuild"},{"location":"modules/manager/cloudbuild/#automated-dependency-updates-for-cloudbuild","text":"Renovate supports updating Cloudbuild dependencies.","title":"Automated Dependency Updates for Cloudbuild"},{"location":"modules/manager/cloudbuild/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)cloudbuild.ya?ml . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cloudbuild/#additional-information","text":"The cloudbuild manager extracts docker datasources from Cloud Build config files .","title":"Additional Information"},{"location":"modules/manager/cocoapods/","text":"Automated Dependency Updates for Cocoapods Renovate supports updating Cocoapods dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Podfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The cocoapods manager supports extracting both \"pod\" type references as well as dependencies on GitHub repositories that use versioned tags. Whenever a Podfile is updated, Renovate will also update any accompanying Podfile.lock file. This is done using the cocoapods gem which runs within the Ruby runtime.","title":"Automated Dependency Updates for Cocoapods"},{"location":"modules/manager/cocoapods/#automated-dependency-updates-for-cocoapods","text":"Renovate supports updating Cocoapods dependencies.","title":"Automated Dependency Updates for Cocoapods"},{"location":"modules/manager/cocoapods/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Podfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cocoapods/#additional-information","text":"The cocoapods manager supports extracting both \"pod\" type references as well as dependencies on GitHub repositories that use versioned tags. Whenever a Podfile is updated, Renovate will also update any accompanying Podfile.lock file. This is done using the cocoapods gem which runs within the Ruby runtime.","title":"Additional Information"},{"location":"modules/manager/composer/","text":"Automated Dependency Updates for Composer Renovate supports updating Composer dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)composer.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts dependencies from composer.json files, and keeps the associated composer.lock file updated too.","title":"Automated Dependency Updates for Composer"},{"location":"modules/manager/composer/#automated-dependency-updates-for-composer","text":"Renovate supports updating Composer dependencies.","title":"Automated Dependency Updates for Composer"},{"location":"modules/manager/composer/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)composer.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/composer/#additional-information","text":"Extracts dependencies from composer.json files, and keeps the associated composer.lock file updated too.","title":"Additional Information"},{"location":"modules/manager/deps-edn/","text":"Automated Dependency Updates for Deps Edn Renovate supports updating Deps Edn dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)deps\\.edn$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts Maven dependencies from deps.edn files.","title":"Automated Dependency Updates for Deps Edn"},{"location":"modules/manager/deps-edn/#automated-dependency-updates-for-deps-edn","text":"Renovate supports updating Deps Edn dependencies.","title":"Automated Dependency Updates for Deps Edn"},{"location":"modules/manager/deps-edn/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)deps\\.edn$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/deps-edn/#additional-information","text":"Extracts Maven dependencies from deps.edn files.","title":"Additional Information"},{"location":"modules/manager/docker-compose/","text":"Automated Dependency Updates for Docker Compose Renovate supports updating Docker Compose dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)docker-compose[^/]*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts all Docker images from with Docker Compose YAML files.","title":"Automated Dependency Updates for Docker Compose"},{"location":"modules/manager/docker-compose/#automated-dependency-updates-for-docker-compose","text":"Renovate supports updating Docker Compose dependencies.","title":"Automated Dependency Updates for Docker Compose"},{"location":"modules/manager/docker-compose/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)docker-compose[^/]*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/docker-compose/#additional-information","text":"Extracts all Docker images from with Docker Compose YAML files.","title":"Additional Information"},{"location":"modules/manager/dockerfile/","text":"Automated Dependency Updates for Dockerfile Renovate supports updating Dockerfile dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)Dockerfile$ (^|/)Dockerfile\\.[^/]*$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts all Docker images in a Dockerfile .","title":"Automated Dependency Updates for Dockerfile"},{"location":"modules/manager/dockerfile/#automated-dependency-updates-for-dockerfile","text":"Renovate supports updating Dockerfile dependencies.","title":"Automated Dependency Updates for Dockerfile"},{"location":"modules/manager/dockerfile/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)Dockerfile$ (^|/)Dockerfile\\.[^/]*$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/dockerfile/#additional-information","text":"Extracts all Docker images in a Dockerfile .","title":"Additional Information"},{"location":"modules/manager/droneci/","text":"Automated Dependency Updates for Droneci Renovate supports updating Droneci dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/).drone.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts docker-type dependencies from DroneCI config files.","title":"Automated Dependency Updates for Droneci"},{"location":"modules/manager/droneci/#automated-dependency-updates-for-droneci","text":"Renovate supports updating Droneci dependencies.","title":"Automated Dependency Updates for Droneci"},{"location":"modules/manager/droneci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).drone.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/droneci/#additional-information","text":"Extracts docker-type dependencies from DroneCI config files.","title":"Additional Information"},{"location":"modules/manager/git-submodules/","text":"Automated Dependency Updates for Git Submodules Renovate supports updating Git Submodules dependencies. Enabling Git Submodules functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"git-submodules\": { \"enabled\": true } } If you encounter any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too. File Matching By default, Renovate will check any files matching the following regular expression: (^|/).gitmodules$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Keeps git submodules updated within a repository.","title":"Automated Dependency Updates for Git Submodules"},{"location":"modules/manager/git-submodules/#automated-dependency-updates-for-git-submodules","text":"Renovate supports updating Git Submodules dependencies.","title":"Automated Dependency Updates for Git Submodules"},{"location":"modules/manager/git-submodules/#enabling","text":"Git Submodules functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"git-submodules\": { \"enabled\": true } } If you encounter any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too.","title":"Enabling"},{"location":"modules/manager/git-submodules/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).gitmodules$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/git-submodules/#additional-information","text":"Keeps git submodules updated within a repository.","title":"Additional Information"},{"location":"modules/manager/github-actions/","text":"Automated Dependency Updates for Github Actions Renovate supports updating Github Actions dependencies. File Matching By default, Renovate will check any files matching the following regular expression: ^\\.github\\/workflows\\/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information For security reasons, GitHub has blocked integrations/apps from editing GitHub Actions workflow files in any branch, so this only works on GitHub if using a Personal Access Token instead of using the WhiteSource Renovate app.","title":"Automated Dependency Updates for Github Actions"},{"location":"modules/manager/github-actions/#automated-dependency-updates-for-github-actions","text":"Renovate supports updating Github Actions dependencies.","title":"Automated Dependency Updates for Github Actions"},{"location":"modules/manager/github-actions/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^\\.github\\/workflows\\/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/github-actions/#additional-information","text":"For security reasons, GitHub has blocked integrations/apps from editing GitHub Actions workflow files in any branch, so this only works on GitHub if using a Personal Access Token instead of using the WhiteSource Renovate app.","title":"Additional Information"},{"location":"modules/manager/gitlabci/","text":"Automated Dependency Updates for Gitlabci Renovate supports updating Gitlabci dependencies. File Matching By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts Docker dependencies from gitlab-ci.yml files.","title":"Automated Dependency Updates for Gitlabci"},{"location":"modules/manager/gitlabci/#automated-dependency-updates-for-gitlabci","text":"Renovate supports updating Gitlabci dependencies.","title":"Automated Dependency Updates for Gitlabci"},{"location":"modules/manager/gitlabci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gitlabci/#additional-information","text":"Extracts Docker dependencies from gitlab-ci.yml files.","title":"Additional Information"},{"location":"modules/manager/gitlabci-include/","text":"Automated Dependency Updates for Gitlabci Include Renovate supports updating Gitlabci Include dependencies. File Matching By default, Renovate will check any files matching the following regular expression: ^\\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts \"includes\" dependencies from gitlab-ci.yml files.","title":"Automated Dependency Updates for Gitlabci Include"},{"location":"modules/manager/gitlabci-include/#automated-dependency-updates-for-gitlabci-include","text":"Renovate supports updating Gitlabci Include dependencies.","title":"Automated Dependency Updates for Gitlabci Include"},{"location":"modules/manager/gitlabci-include/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^\\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gitlabci-include/#additional-information","text":"Extracts \"includes\" dependencies from gitlab-ci.yml files.","title":"Additional Information"},{"location":"modules/manager/gomod/","text":"Automated Dependency Updates for Gomod Renovate supports updating Gomod dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)go.mod$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information You might be interested to add \"postUpdateOptions\": [\"gomodTidy\"] to your config if you'd like Renovate to run go mod tidy after every update before raising the PR.","title":"Automated Dependency Updates for Gomod"},{"location":"modules/manager/gomod/#automated-dependency-updates-for-gomod","text":"Renovate supports updating Gomod dependencies.","title":"Automated Dependency Updates for Gomod"},{"location":"modules/manager/gomod/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)go.mod$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gomod/#additional-information","text":"You might be interested to add \"postUpdateOptions\": [\"gomodTidy\"] to your config if you'd like Renovate to run go mod tidy after every update before raising the PR.","title":"Additional Information"},{"location":"modules/manager/gradle/","text":"Automated Dependency Updates for Gradle Renovate supports updating Gradle dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: \\.gradle(\\.kts)?$ (^|/)gradle.properties$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Renovate extracts Gradle dependencies by calling a custom Gradle script. The Gradle binary is then used to extract Maven-type dependencies.","title":"Automated Dependency Updates for Gradle"},{"location":"modules/manager/gradle/#automated-dependency-updates-for-gradle","text":"Renovate supports updating Gradle dependencies.","title":"Automated Dependency Updates for Gradle"},{"location":"modules/manager/gradle/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.gradle(\\.kts)?$ (^|/)gradle.properties$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gradle/#additional-information","text":"Renovate extracts Gradle dependencies by calling a custom Gradle script. The Gradle binary is then used to extract Maven-type dependencies.","title":"Additional Information"},{"location":"modules/manager/gradle-lite/","text":"Automated Dependency Updates for Gradle Lite Renovate supports updating Gradle Lite dependencies. Enabling Gradle Lite functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"gradle-lite\": { \"enabled\": true } } If you encounter any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too. File Matching By default, Renovate will check any files matching any of the following regular expressions: (^|/)gradle.properties$ \\.gradle(\\.kts)?$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information gradle-lite is an an alternate manager for Gradle, and is written in JavaScript. The main benefit of gradle-lite is that it doesn't need to invoke the gradle tool from and command line in order to extract dependencies. To enable gradle-lite : { \"extends\": [\":enableGradleLite\"] } To disable the original gradle manager if gradle-lite satisfies all requirements: { \"extends\": [\":switchToGradleLite\"] } Feedback for this manager would be welcome as we would like to switch it to be the default manager for Gradle soon.","title":"Automated Dependency Updates for Gradle Lite"},{"location":"modules/manager/gradle-lite/#automated-dependency-updates-for-gradle-lite","text":"Renovate supports updating Gradle Lite dependencies.","title":"Automated Dependency Updates for Gradle Lite"},{"location":"modules/manager/gradle-lite/#enabling","text":"Gradle Lite functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"gradle-lite\": { \"enabled\": true } } If you encounter any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too.","title":"Enabling"},{"location":"modules/manager/gradle-lite/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/)gradle.properties$ \\.gradle(\\.kts)?$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gradle-lite/#additional-information","text":"gradle-lite is an an alternate manager for Gradle, and is written in JavaScript. The main benefit of gradle-lite is that it doesn't need to invoke the gradle tool from and command line in order to extract dependencies. To enable gradle-lite : { \"extends\": [\":enableGradleLite\"] } To disable the original gradle manager if gradle-lite satisfies all requirements: { \"extends\": [\":switchToGradleLite\"] } Feedback for this manager would be welcome as we would like to switch it to be the default manager for Gradle soon.","title":"Additional Information"},{"location":"modules/manager/gradle-wrapper/","text":"Automated Dependency Updates for Gradle Wrapper Renovate supports updating Gradle Wrapper dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)gradle/wrapper/gradle-wrapper.properties$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Configuration for Gradle Wrapper updates. Changes here affect how Renovate updates the version of gradle in the wrapper, not how it uses the wrapper.","title":"Automated Dependency Updates for Gradle Wrapper"},{"location":"modules/manager/gradle-wrapper/#automated-dependency-updates-for-gradle-wrapper","text":"Renovate supports updating Gradle Wrapper dependencies.","title":"Automated Dependency Updates for Gradle Wrapper"},{"location":"modules/manager/gradle-wrapper/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)gradle/wrapper/gradle-wrapper.properties$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gradle-wrapper/#additional-information","text":"Configuration for Gradle Wrapper updates. Changes here affect how Renovate updates the version of gradle in the wrapper, not how it uses the wrapper.","title":"Additional Information"},{"location":"modules/manager/helm-requirements/","text":"Automated Dependency Updates for Helm Requirements Renovate supports updating Helm Requirements dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Renovate supports updating Helm Chart references within requirements.yaml files. If your Helm charts make use of Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them.","title":"Automated Dependency Updates for Helm Requirements"},{"location":"modules/manager/helm-requirements/#automated-dependency-updates-for-helm-requirements","text":"Renovate supports updating Helm Requirements dependencies.","title":"Automated Dependency Updates for Helm Requirements"},{"location":"modules/manager/helm-requirements/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helm-requirements/#additional-information","text":"Renovate supports updating Helm Chart references within requirements.yaml files. If your Helm charts make use of Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them.","title":"Additional Information"},{"location":"modules/manager/helm-values/","text":"Automated Dependency Updates for Helm Values Renovate supports updating Helm Values dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)values.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Renovate supports updating of Docker dependencies within Helm Chart values.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in most of the Helm charts: image: repository: 'some-docker/dependency' tag: v1.0.0 registry: registry.example.com # optional key, will default to \"docker.io\" coreImage: registry: docker.io repository: bitnami/harbor-core tag: 2.1.3-debian-10-r38","title":"Automated Dependency Updates for Helm Values"},{"location":"modules/manager/helm-values/#automated-dependency-updates-for-helm-values","text":"Renovate supports updating Helm Values dependencies.","title":"Automated Dependency Updates for Helm Values"},{"location":"modules/manager/helm-values/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)values.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helm-values/#additional-information","text":"Renovate supports updating of Docker dependencies within Helm Chart values.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in most of the Helm charts: image: repository: 'some-docker/dependency' tag: v1.0.0 registry: registry.example.com # optional key, will default to \"docker.io\" coreImage: registry: docker.io repository: bitnami/harbor-core tag: 2.1.3-debian-10-r38","title":"Additional Information"},{"location":"modules/manager/helmfile/","text":"Automated Dependency Updates for Helmfile Renovate supports updating Helmfile dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)helmfile.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Checks helmfile.yaml files and extracts dependencies for the helm datasource.","title":"Automated Dependency Updates for Helmfile"},{"location":"modules/manager/helmfile/#automated-dependency-updates-for-helmfile","text":"Renovate supports updating Helmfile dependencies.","title":"Automated Dependency Updates for Helmfile"},{"location":"modules/manager/helmfile/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)helmfile.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helmfile/#additional-information","text":"Checks helmfile.yaml files and extracts dependencies for the helm datasource.","title":"Additional Information"},{"location":"modules/manager/helmv3/","text":"Automated Dependency Updates for Helmv3 Renovate supports updating Helmv3 dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Chart.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Renovate supports updating Helm Chart references within requirements.yaml (Helm v2) and Chart.yaml (Helm v3) files. If your Helm charts make use of Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them.","title":"Automated Dependency Updates for Helmv3"},{"location":"modules/manager/helmv3/#automated-dependency-updates-for-helmv3","text":"Renovate supports updating Helmv3 dependencies.","title":"Automated Dependency Updates for Helmv3"},{"location":"modules/manager/helmv3/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Chart.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helmv3/#additional-information","text":"Renovate supports updating Helm Chart references within requirements.yaml (Helm v2) and Chart.yaml (Helm v3) files. If your Helm charts make use of Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them.","title":"Additional Information"},{"location":"modules/manager/homebrew/","text":"Automated Dependency Updates for Homebrew Renovate supports updating Homebrew dependencies. File Matching By default, Renovate will check any files matching the following regular expression: ^Formula/[^/]+[.]rb$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information","title":"Automated Dependency Updates for Homebrew"},{"location":"modules/manager/homebrew/#automated-dependency-updates-for-homebrew","text":"Renovate supports updating Homebrew dependencies.","title":"Automated Dependency Updates for Homebrew"},{"location":"modules/manager/homebrew/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^Formula/[^/]+[.]rb$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/homebrew/#additional-information","text":"","title":"Additional Information"},{"location":"modules/manager/html/","text":"Automated Dependency Updates for Html Renovate supports updating Html dependencies. File Matching By default, Renovate will check any files matching the following regular expression: \\.html?$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The html manager extracts scripts and CSS includes pointing to cdnjs. It differs from the cdnjs manager in that it detects if an integrity hash is already present and updates it too if found.","title":"Automated Dependency Updates for Html"},{"location":"modules/manager/html/#automated-dependency-updates-for-html","text":"Renovate supports updating Html dependencies.","title":"Automated Dependency Updates for Html"},{"location":"modules/manager/html/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.html?$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/html/#additional-information","text":"The html manager extracts scripts and CSS includes pointing to cdnjs. It differs from the cdnjs manager in that it detects if an integrity hash is already present and updates it too if found.","title":"Additional Information"},{"location":"modules/manager/jenkins/","text":"Automated Dependency Updates for Jenkins Renovate supports updating Jenkins dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)plugins\\.txt . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The Jenkins manager supports the following format of the plugin list: plugin1:1.2.3 plugin2:4.5 # this is a comment # this line is ignored # Renovate will not upgrade the following dependency: plugin3:7.8.9 # renovate:ignore There's no strict specification on the name of the files, but usually it's plugins.txt","title":"Automated Dependency Updates for Jenkins"},{"location":"modules/manager/jenkins/#automated-dependency-updates-for-jenkins","text":"Renovate supports updating Jenkins dependencies.","title":"Automated Dependency Updates for Jenkins"},{"location":"modules/manager/jenkins/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)plugins\\.txt . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/jenkins/#additional-information","text":"The Jenkins manager supports the following format of the plugin list: plugin1:1.2.3 plugin2:4.5 # this is a comment # this line is ignored # Renovate will not upgrade the following dependency: plugin3:7.8.9 # renovate:ignore There's no strict specification on the name of the files, but usually it's plugins.txt","title":"Additional Information"},{"location":"modules/manager/kubernetes/","text":"Automated Dependency Updates for Kubernetes Renovate supports updating Kubernetes dependencies. File Matching Because file names for kubernetes cannot be easily determined automatically, Renovate will not attempt to match any kubernetes files by default. For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The kubernetes manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for Kubernetes YAML files and we don't want to check every single *.yaml file in repositories just in case any of them contain Kubernetes definitions. If most .yaml files in your repository are Kubernetes ones, then you could add this to your config: { \"kubernetes\": { \"fileMatch\": [\"\\\\.yaml$\"] } } If instead you have them all inside a k8s/ directory, you would add this: { \"kubernetes\": { \"fileMatch\": [\"k8s/.+\\\\.yaml$\"] } } Or if it's just a single file then something like this: { \"kubernetes\": { \"fileMatch\": [\"^config/k8s\\\\.yaml$\"] } }","title":"Automated Dependency Updates for Kubernetes"},{"location":"modules/manager/kubernetes/#automated-dependency-updates-for-kubernetes","text":"Renovate supports updating Kubernetes dependencies.","title":"Automated Dependency Updates for Kubernetes"},{"location":"modules/manager/kubernetes/#file-matching","text":"Because file names for kubernetes cannot be easily determined automatically, Renovate will not attempt to match any kubernetes files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/kubernetes/#additional-information","text":"The kubernetes manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for Kubernetes YAML files and we don't want to check every single *.yaml file in repositories just in case any of them contain Kubernetes definitions. If most .yaml files in your repository are Kubernetes ones, then you could add this to your config: { \"kubernetes\": { \"fileMatch\": [\"\\\\.yaml$\"] } } If instead you have them all inside a k8s/ directory, you would add this: { \"kubernetes\": { \"fileMatch\": [\"k8s/.+\\\\.yaml$\"] } } Or if it's just a single file then something like this: { \"kubernetes\": { \"fileMatch\": [\"^config/k8s\\\\.yaml$\"] } }","title":"Additional Information"},{"location":"modules/manager/kustomize/","text":"Automated Dependency Updates for Kustomize Renovate supports updating Kustomize dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)kustomization\\.yaml . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This package will manage two parts of the kustomization.yaml file: remote bases image tags How It Works Renovate will search each repository for any kustomization.yaml files. Existing dependencies will be extracted from remote bases & image tags Renovate will resolve the dependency's source repository and check for SemVer tags if found. If an update was found, Renovate will update kustomization.yaml Limitations Needs to have kind: Kustomization defined Currently this hasn't been tested using HTTPS to fetch the repos The image tags are limited to the following formats: - name: image/name newTag: v0.0.1 or - newTag: v0.0.1 name: image/name","title":"Automated Dependency Updates for Kustomize"},{"location":"modules/manager/kustomize/#automated-dependency-updates-for-kustomize","text":"Renovate supports updating Kustomize dependencies.","title":"Automated Dependency Updates for Kustomize"},{"location":"modules/manager/kustomize/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)kustomization\\.yaml . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/kustomize/#additional-information","text":"This package will manage two parts of the kustomization.yaml file: remote bases image tags How It Works Renovate will search each repository for any kustomization.yaml files. Existing dependencies will be extracted from remote bases & image tags Renovate will resolve the dependency's source repository and check for SemVer tags if found. If an update was found, Renovate will update kustomization.yaml Limitations Needs to have kind: Kustomization defined Currently this hasn't been tested using HTTPS to fetch the repos The image tags are limited to the following formats: - name: image/name newTag: v0.0.1 or - newTag: v0.0.1 name: image/name","title":"Additional Information"},{"location":"modules/manager/leiningen/","text":"Automated Dependency Updates for Leiningen Renovate supports updating Leiningen dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)project\\.clj$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts Maven-type dependencies.","title":"Automated Dependency Updates for Leiningen"},{"location":"modules/manager/leiningen/#automated-dependency-updates-for-leiningen","text":"Renovate supports updating Leiningen dependencies.","title":"Automated Dependency Updates for Leiningen"},{"location":"modules/manager/leiningen/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)project\\.clj$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/leiningen/#additional-information","text":"Extracts Maven-type dependencies.","title":"Additional Information"},{"location":"modules/manager/maven/","text":"Automated Dependency Updates for Maven Renovate supports updating Maven dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: \\.pom\\.xml$ (^|/)pom\\.xml$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The maven manager focuses on extracting dependencies from pom.xml . It uses the official Maven versioning scheme.","title":"Automated Dependency Updates for Maven"},{"location":"modules/manager/maven/#automated-dependency-updates-for-maven","text":"Renovate supports updating Maven dependencies.","title":"Automated Dependency Updates for Maven"},{"location":"modules/manager/maven/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.pom\\.xml$ (^|/)pom\\.xml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/maven/#additional-information","text":"The maven manager focuses on extracting dependencies from pom.xml . It uses the official Maven versioning scheme.","title":"Additional Information"},{"location":"modules/manager/meteor/","text":"Automated Dependency Updates for Meteor Renovate supports updating Meteor dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)package.js$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information","title":"Automated Dependency Updates for Meteor"},{"location":"modules/manager/meteor/#automated-dependency-updates-for-meteor","text":"Renovate supports updating Meteor dependencies.","title":"Automated Dependency Updates for Meteor"},{"location":"modules/manager/meteor/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)package.js$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/meteor/#additional-information","text":"","title":"Additional Information"},{"location":"modules/manager/mix/","text":"Automated Dependency Updates for Mix Renovate supports updating Mix dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)mix\\.exs$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The mix manager extracts dependencies for the hex datasource and uses Renovate's implementation of Hex SemVer to evaluate updates. The mix package manager itself is also used to keep the lock file up-to-date.","title":"Automated Dependency Updates for Mix"},{"location":"modules/manager/mix/#automated-dependency-updates-for-mix","text":"Renovate supports updating Mix dependencies.","title":"Automated Dependency Updates for Mix"},{"location":"modules/manager/mix/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)mix\\.exs$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/mix/#additional-information","text":"The mix manager extracts dependencies for the hex datasource and uses Renovate's implementation of Hex SemVer to evaluate updates. The mix package manager itself is also used to keep the lock file up-to-date.","title":"Additional Information"},{"location":"modules/manager/nodenv/","text":"Automated Dependency Updates for Nodenv Renovate supports updating Nodenv dependencies. File Matching By default, Renovate will check any files matching the following regular expression: ^.node-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Simply keeps the .node-version file updated.","title":"Automated Dependency Updates for Nodenv"},{"location":"modules/manager/nodenv/#automated-dependency-updates-for-nodenv","text":"Renovate supports updating Nodenv dependencies.","title":"Automated Dependency Updates for Nodenv"},{"location":"modules/manager/nodenv/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^.node-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nodenv/#additional-information","text":"Simply keeps the .node-version file updated.","title":"Additional Information"},{"location":"modules/manager/npm/","text":"Automated Dependency Updates for Npm Renovate supports updating Npm dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)package.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The following depTypes are currently supported by the npm manager : dependencies devDependencies optionalDependencies peerDependencies engines : Renovate will update any node , npm and yarn version specified under engines . volta : Renovate will update any node and yarn version specified under volta .","title":"Automated Dependency Updates for Npm"},{"location":"modules/manager/npm/#automated-dependency-updates-for-npm","text":"Renovate supports updating Npm dependencies.","title":"Automated Dependency Updates for Npm"},{"location":"modules/manager/npm/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)package.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/npm/#additional-information","text":"The following depTypes are currently supported by the npm manager : dependencies devDependencies optionalDependencies peerDependencies engines : Renovate will update any node , npm and yarn version specified under engines . volta : Renovate will update any node and yarn version specified under volta .","title":"Additional Information"},{"location":"modules/manager/nuget/","text":"Automated Dependency Updates for Nuget Renovate supports updating Nuget dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: \\.(?:cs|fs|vb)proj$ \\.(?:props|targets)$ \\.config\\/dotnet-tools\\.json$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information The nuget configuration object is used to control settings for the NuGet package manager. The NuGet package manager supports SDK-style .csproj / .fsproj / .vbproj format, as described here . This means that .NET Core projects are all supported but any .NET Framework projects need to be updated to the new .csproj / .fsproj / .vbproj format in order to be detected and supported by Renovate.","title":"Automated Dependency Updates for Nuget"},{"location":"modules/manager/nuget/#automated-dependency-updates-for-nuget","text":"Renovate supports updating Nuget dependencies.","title":"Automated Dependency Updates for Nuget"},{"location":"modules/manager/nuget/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.(?:cs|fs|vb)proj$ \\.(?:props|targets)$ \\.config\\/dotnet-tools\\.json$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nuget/#additional-information","text":"The nuget configuration object is used to control settings for the NuGet package manager. The NuGet package manager supports SDK-style .csproj / .fsproj / .vbproj format, as described here . This means that .NET Core projects are all supported but any .NET Framework projects need to be updated to the new .csproj / .fsproj / .vbproj format in order to be detected and supported by Renovate.","title":"Additional Information"},{"location":"modules/manager/nvm/","text":"Automated Dependency Updates for Nvm Renovate supports updating Nvm dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)\\.nvmrc$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Simply keeps the .nvmrc file updated.","title":"Automated Dependency Updates for Nvm"},{"location":"modules/manager/nvm/#automated-dependency-updates-for-nvm","text":"Renovate supports updating Nvm dependencies.","title":"Automated Dependency Updates for Nvm"},{"location":"modules/manager/nvm/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.nvmrc$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nvm/#additional-information","text":"Simply keeps the .nvmrc file updated.","title":"Additional Information"},{"location":"modules/manager/pip_requirements/","text":"Automated Dependency Updates for Pip_requirements Renovate supports updating Pip_requirements dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)requirements.(txt|pip)$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Supports requirements.txt and requirements.pip files. The default file pattern is fairly flexible in an attempt to catch similarly named ones too but may be extended/changed.","title":"Automated Dependency Updates for Pip_requirements"},{"location":"modules/manager/pip_requirements/#automated-dependency-updates-for-pip_requirements","text":"Renovate supports updating Pip_requirements dependencies.","title":"Automated Dependency Updates for Pip_requirements"},{"location":"modules/manager/pip_requirements/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)requirements.(txt|pip)$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pip_requirements/#additional-information","text":"Supports requirements.txt and requirements.pip files. The default file pattern is fairly flexible in an attempt to catch similarly named ones too but may be extended/changed.","title":"Additional Information"},{"location":"modules/manager/pip_setup/","text":"Automated Dependency Updates for Pip_setup Renovate supports updating Pip_setup dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)setup.py$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information setup.py files are parsed by calling out to python and then using a mock to detect imported modules.","title":"Automated Dependency Updates for Pip_setup"},{"location":"modules/manager/pip_setup/#automated-dependency-updates-for-pip_setup","text":"Renovate supports updating Pip_setup dependencies.","title":"Automated Dependency Updates for Pip_setup"},{"location":"modules/manager/pip_setup/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)setup.py$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pip_setup/#additional-information","text":"setup.py files are parsed by calling out to python and then using a mock to detect imported modules.","title":"Additional Information"},{"location":"modules/manager/pipenv/","text":"Automated Dependency Updates for Pipenv Renovate supports updating Pipenv dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Pipfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Pipenv.lock updating is supported.","title":"Automated Dependency Updates for Pipenv"},{"location":"modules/manager/pipenv/#automated-dependency-updates-for-pipenv","text":"Renovate supports updating Pipenv dependencies.","title":"Automated Dependency Updates for Pipenv"},{"location":"modules/manager/pipenv/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Pipfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pipenv/#additional-information","text":"Pipenv.lock updating is supported.","title":"Additional Information"},{"location":"modules/manager/poetry/","text":"Automated Dependency Updates for Poetry Renovate supports updating Poetry dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)pyproject\\.toml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Both Poetry 0.x and 1.x versions are supported. Whenever the pyproject.toml file is updated, the Poetry lock file will be checked for updates as well.","title":"Automated Dependency Updates for Poetry"},{"location":"modules/manager/poetry/#automated-dependency-updates-for-poetry","text":"Renovate supports updating Poetry dependencies.","title":"Automated Dependency Updates for Poetry"},{"location":"modules/manager/poetry/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)pyproject\\.toml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/poetry/#additional-information","text":"Both Poetry 0.x and 1.x versions are supported. Whenever the pyproject.toml file is updated, the Poetry lock file will be checked for updates as well.","title":"Additional Information"},{"location":"modules/manager/pre-commit/","text":"Automated Dependency Updates for Pre Commit Renovate supports updating Pre Commit dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)\\.pre-commit-config\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Renovate supports updating of Git dependencies within pre-commit configuration .pre-commit-config.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in typical pre-commit files: repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v1.0.0 hooks: - id: some-hook-id","title":"Automated Dependency Updates for Pre Commit"},{"location":"modules/manager/pre-commit/#automated-dependency-updates-for-pre-commit","text":"Renovate supports updating Pre Commit dependencies.","title":"Automated Dependency Updates for Pre Commit"},{"location":"modules/manager/pre-commit/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.pre-commit-config\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pre-commit/#additional-information","text":"Renovate supports updating of Git dependencies within pre-commit configuration .pre-commit-config.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in typical pre-commit files: repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v1.0.0 hooks: - id: some-hook-id","title":"Additional Information"},{"location":"modules/manager/pub/","text":"Automated Dependency Updates for Pub Renovate supports updating Pub dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)pubspec\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This manager is used to keep pubspec files up-to-date.","title":"Automated Dependency Updates for Pub"},{"location":"modules/manager/pub/#automated-dependency-updates-for-pub","text":"Renovate supports updating Pub dependencies.","title":"Automated Dependency Updates for Pub"},{"location":"modules/manager/pub/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)pubspec\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pub/#additional-information","text":"This manager is used to keep pubspec files up-to-date.","title":"Additional Information"},{"location":"modules/manager/regex/","text":"Custom Manager Support using Regex The regex manager is designed to allow users to manually configure Renovate for how to find dependencies that aren't detected by the built-in package managers. This manager is unique in Renovate in that: It is configurable via regex named capture groups Through the use of the regexManagers config, multiple \"regex managers\" can be created for the same repository. Required Fields The first two required fields are fileMatch and matchStrings . fileMatch works the same as any manager, while matchStrings is a regexManagers concept and is used for configuring a regular expression with named capture groups. In order for Renovate to look up a dependency and decide about updates, it then needs the following information about each dependency: The dependency's name Which datasource to look up (e.g. npm, Docker, GitHub tags, etc) Which version scheme to apply (defaults to semver , but also may be other values like pep440 ) Configuration-wise, it works like this: You must capture the currentValue of the dependency in a named capture group You must have either a depName capture group or a depNameTemplate config field You can optionally have a lookupName capture group or a lookupNameTemplate if it differs from depName You must have either a datasource capture group or a datasourceTemplate config field You can optionally have a versioning capture group or a versioningTemplate config field. If neither are present, semver will be used as the default You can optionally have an extractVersion capture group or an extractVersionTemplate config field You can optionally have a currentDigest capture group. You can optionally have a registryUrl capture group or a registryUrlTemplate config field If it's a valid URL, it will be converted to the registryUrls field as a single-length array. Regular Expression Capture Groups To be fully effective with the regex manager, you will need to understand regular expressions and named capture groups, although sometimes enough examples can compensate for lack of experience. Consider this Dockerfile : FROM node:12 ENV YARN_VERSION=1.19.1 RUN curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version ${YARN_VERSION} You would need to capture the currentValue using a named capture group, like so: ENV YARN_VERSION=(?<currentValue>.*?)\\n . If you're looking for an online regex testing tool that supports capture groups, try https://regex101.com/ . Configuration templates In many cases, named capture groups alone won't be enough and you'll need to configure Renovate with additional information about how to look up a dependency. Continuing the above example with Yarn, here is the full config: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [\"ENV YARN_VERSION=(?<currentValue>.*?)\\n\"], \"depNameTemplate\": \"yarn\", \"datasourceTemplate\": \"npm\" } ] } Advanced Capture Let's say that your Dockerfile has many ENV variables you want to keep updated and you prefer not to write one regexManagers rule per variable. Instead you could enhance your Dockerfile like the following: ARG IMAGE=node:12@sha256:6e5264cd4cfaefd7174b2bc10c7f9a1c2b99d98d127fc57a802d264da9fb43bd FROM ${IMAGE} # renovate: datasource=github-tags depName=nodejs/node versioning=node ENV NODE_VERSION=10.19.0 # renovate: datasource=github-releases depName=composer/composer ENV COMPOSER_VERSION=1.9.3 # renovate: datasource=docker depName=docker versioning=docker ENV DOCKER_VERSION=19.03.1 # renovate: datasource=npm depName=yarn ENV YARN_VERSION=1.19.1 The above (obviously not a complete Dockerfile , but abbreviated for this example), could then be supported accordingly: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\": \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" }, { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"ARG IMAGE=(?<depName>.*?):(?<currentValue>.*?)@(?<currentDigest>sha256:[a-f0-9]+)s\" ], \"datasourceTemplate\": \"docker\" } ] } In the above the versioningTemplate is not actually necessary because Renovate already defaults to semver versioning, but it has been included to help illustrate why we call these fields templates . They are named this way because they are compiled using Handlebars and so can be composed from values you collect in named capture groups. You will usually want to use the tripe brace {{{ }}} template (e.v. {{{versioning}}} to be safe because Handlebars escapes special characters by default with double braces. By adding the comments to the Dockerfile , you can see that instead of four separate regexManagers being required, there is now only one - and the Dockerfile itself is now somewhat better documented too. The syntax we used there is completely arbitrary and you may choose your own instead if you prefer - just be sure to update your matchStrings regex.","title":"Custom Manager Support using Regex"},{"location":"modules/manager/regex/#custom-manager-support-using-regex","text":"The regex manager is designed to allow users to manually configure Renovate for how to find dependencies that aren't detected by the built-in package managers. This manager is unique in Renovate in that: It is configurable via regex named capture groups Through the use of the regexManagers config, multiple \"regex managers\" can be created for the same repository.","title":"Custom Manager Support using Regex"},{"location":"modules/manager/regex/#required-fields","text":"The first two required fields are fileMatch and matchStrings . fileMatch works the same as any manager, while matchStrings is a regexManagers concept and is used for configuring a regular expression with named capture groups. In order for Renovate to look up a dependency and decide about updates, it then needs the following information about each dependency: The dependency's name Which datasource to look up (e.g. npm, Docker, GitHub tags, etc) Which version scheme to apply (defaults to semver , but also may be other values like pep440 ) Configuration-wise, it works like this: You must capture the currentValue of the dependency in a named capture group You must have either a depName capture group or a depNameTemplate config field You can optionally have a lookupName capture group or a lookupNameTemplate if it differs from depName You must have either a datasource capture group or a datasourceTemplate config field You can optionally have a versioning capture group or a versioningTemplate config field. If neither are present, semver will be used as the default You can optionally have an extractVersion capture group or an extractVersionTemplate config field You can optionally have a currentDigest capture group. You can optionally have a registryUrl capture group or a registryUrlTemplate config field If it's a valid URL, it will be converted to the registryUrls field as a single-length array.","title":"Required Fields"},{"location":"modules/manager/regex/#regular-expression-capture-groups","text":"To be fully effective with the regex manager, you will need to understand regular expressions and named capture groups, although sometimes enough examples can compensate for lack of experience. Consider this Dockerfile : FROM node:12 ENV YARN_VERSION=1.19.1 RUN curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version ${YARN_VERSION} You would need to capture the currentValue using a named capture group, like so: ENV YARN_VERSION=(?<currentValue>.*?)\\n . If you're looking for an online regex testing tool that supports capture groups, try https://regex101.com/ .","title":"Regular Expression Capture Groups"},{"location":"modules/manager/regex/#configuration-templates","text":"In many cases, named capture groups alone won't be enough and you'll need to configure Renovate with additional information about how to look up a dependency. Continuing the above example with Yarn, here is the full config: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [\"ENV YARN_VERSION=(?<currentValue>.*?)\\n\"], \"depNameTemplate\": \"yarn\", \"datasourceTemplate\": \"npm\" } ] }","title":"Configuration templates"},{"location":"modules/manager/regex/#advanced-capture","text":"Let's say that your Dockerfile has many ENV variables you want to keep updated and you prefer not to write one regexManagers rule per variable. Instead you could enhance your Dockerfile like the following: ARG IMAGE=node:12@sha256:6e5264cd4cfaefd7174b2bc10c7f9a1c2b99d98d127fc57a802d264da9fb43bd FROM ${IMAGE} # renovate: datasource=github-tags depName=nodejs/node versioning=node ENV NODE_VERSION=10.19.0 # renovate: datasource=github-releases depName=composer/composer ENV COMPOSER_VERSION=1.9.3 # renovate: datasource=docker depName=docker versioning=docker ENV DOCKER_VERSION=19.03.1 # renovate: datasource=npm depName=yarn ENV YARN_VERSION=1.19.1 The above (obviously not a complete Dockerfile , but abbreviated for this example), could then be supported accordingly: { \"regexManagers\": [ { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\": \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" }, { \"fileMatch\": [\"^Dockerfile$\"], \"matchStrings\": [ \"ARG IMAGE=(?<depName>.*?):(?<currentValue>.*?)@(?<currentDigest>sha256:[a-f0-9]+)s\" ], \"datasourceTemplate\": \"docker\" } ] } In the above the versioningTemplate is not actually necessary because Renovate already defaults to semver versioning, but it has been included to help illustrate why we call these fields templates . They are named this way because they are compiled using Handlebars and so can be composed from values you collect in named capture groups. You will usually want to use the tripe brace {{{ }}} template (e.v. {{{versioning}}} to be safe because Handlebars escapes special characters by default with double braces. By adding the comments to the Dockerfile , you can see that instead of four separate regexManagers being required, there is now only one - and the Dockerfile itself is now somewhat better documented too. The syntax we used there is completely arbitrary and you may choose your own instead if you prefer - just be sure to update your matchStrings regex.","title":"Advanced Capture"},{"location":"modules/manager/ruby-version/","text":"Automated Dependency Updates for Ruby Version Renovate supports updating Ruby Version dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)\\.ruby-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This will maintain .ruby-version files. Available versions will be determined from the official Ruby downloads page.","title":"Automated Dependency Updates for Ruby Version"},{"location":"modules/manager/ruby-version/#automated-dependency-updates-for-ruby-version","text":"Renovate supports updating Ruby Version dependencies.","title":"Automated Dependency Updates for Ruby Version"},{"location":"modules/manager/ruby-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.ruby-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ruby-version/#additional-information","text":"This will maintain .ruby-version files. Available versions will be determined from the official Ruby downloads page.","title":"Additional Information"},{"location":"modules/manager/sbt/","text":"Automated Dependency Updates for Sbt Renovate supports updating Sbt dependencies. File Matching By default, Renovate will check any files matching any of the following regular expressions: \\.sbt$ project/[^/]*.scala$ For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Extracts Maven artifact dependencies for SBT.","title":"Automated Dependency Updates for Sbt"},{"location":"modules/manager/sbt/#automated-dependency-updates-for-sbt","text":"Renovate supports updating Sbt dependencies.","title":"Automated Dependency Updates for Sbt"},{"location":"modules/manager/sbt/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.sbt$ project/[^/]*.scala$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/sbt/#additional-information","text":"Extracts Maven artifact dependencies for SBT.","title":"Additional Information"},{"location":"modules/manager/setup-cfg/","text":"Automated Dependency Updates for Setup Cfg Renovate supports updating Setup Cfg dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)setup\\.cfg$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Updates dependencies for Python setup.cfg files.","title":"Automated Dependency Updates for Setup Cfg"},{"location":"modules/manager/setup-cfg/#automated-dependency-updates-for-setup-cfg","text":"Renovate supports updating Setup Cfg dependencies.","title":"Automated Dependency Updates for Setup Cfg"},{"location":"modules/manager/setup-cfg/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)setup\\.cfg$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/setup-cfg/#additional-information","text":"Updates dependencies for Python setup.cfg files.","title":"Additional Information"},{"location":"modules/manager/swift/","text":"Automated Dependency Updates for Swift Renovate supports updating Swift dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)Package\\.swift . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Anything other than .exact(<...>) will be treated as range with respect to Swift specific. Because of this, some PR descriptions will look like from: <...> => <...> . Examples: package(name: \"<...>\", from: \"1.2.3\") // => from: \"2.0.0\" package(name: \"<...>\", \"1.2.3\"...) // => \"2.0.0\"... package(name: \"<...>\", \"1.2.3\"...\"1.3.0\") // => \"1.2.3\"...\"2.0.0\" package(name: \"<...>\", \"1.2.3\"..<\"1.3.0\") // => \"1.2.3\"..<\"2.0.0\" package(name: \"<...>\", ...\"1.2.3\") // => ...\"2.0.0\" package(name: \"<...>\", ..<\"1.2.3\") // => ..<\"2.0.0\"","title":"Automated Dependency Updates for Swift"},{"location":"modules/manager/swift/#automated-dependency-updates-for-swift","text":"Renovate supports updating Swift dependencies.","title":"Automated Dependency Updates for Swift"},{"location":"modules/manager/swift/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Package\\.swift . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/swift/#additional-information","text":"Anything other than .exact(<...>) will be treated as range with respect to Swift specific. Because of this, some PR descriptions will look like from: <...> => <...> . Examples: package(name: \"<...>\", from: \"1.2.3\") // => from: \"2.0.0\" package(name: \"<...>\", \"1.2.3\"...) // => \"2.0.0\"... package(name: \"<...>\", \"1.2.3\"...\"1.3.0\") // => \"1.2.3\"...\"2.0.0\" package(name: \"<...>\", \"1.2.3\"..<\"1.3.0\") // => \"1.2.3\"..<\"2.0.0\" package(name: \"<...>\", ...\"1.2.3\") // => ...\"2.0.0\" package(name: \"<...>\", ..<\"1.2.3\") // => ..<\"2.0.0\"","title":"Additional Information"},{"location":"modules/manager/terraform/","text":"Automated Dependency Updates for Terraform Renovate supports updating Terraform dependencies. File Matching By default, Renovate will check any files matching the following regular expression: \\.tf$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Currently Terraform support is limited to Terraform registry sources and github sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . Fixed versions like the following will receive a PR whenever there is a newer version available: module \"consul\" { source = \"hashicorp/consul/aws\" version = \"0.0.5\" servers = 3 } The following range constraints are also supported: >= 1.2.0 : version 1.2.0 or newer <= 1.2.0 : version 1.2.0 or older ~> 1.2.0 : any non-beta version >= 1.2.0 and < 1.3.0, e.g. 1.2.X ~> 1.2 : any non-beta version >= 1.2.0 and < 2.0.0, e.g. 1.X.Y >= 1.0.0 , <= 2.0.0`: any version between 1.0.0 and 2.0.0 inclusive","title":"Automated Dependency Updates for Terraform"},{"location":"modules/manager/terraform/#automated-dependency-updates-for-terraform","text":"Renovate supports updating Terraform dependencies.","title":"Automated Dependency Updates for Terraform"},{"location":"modules/manager/terraform/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.tf$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terraform/#additional-information","text":"Currently Terraform support is limited to Terraform registry sources and github sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . Fixed versions like the following will receive a PR whenever there is a newer version available: module \"consul\" { source = \"hashicorp/consul/aws\" version = \"0.0.5\" servers = 3 } The following range constraints are also supported: >= 1.2.0 : version 1.2.0 or newer <= 1.2.0 : version 1.2.0 or older ~> 1.2.0 : any non-beta version >= 1.2.0 and < 1.3.0, e.g. 1.2.X ~> 1.2 : any non-beta version >= 1.2.0 and < 2.0.0, e.g. 1.X.Y >= 1.0.0 , <= 2.0.0`: any version between 1.0.0 and 2.0.0 inclusive","title":"Additional Information"},{"location":"modules/manager/terraform-version/","text":"Automated Dependency Updates for Terraform Version Renovate supports updating Terraform Version dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)\\.terraform-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This will maintain .terraform-version files. Available versions will be determined from the official Terraform downloads page.","title":"Automated Dependency Updates for Terraform Version"},{"location":"modules/manager/terraform-version/#automated-dependency-updates-for-terraform-version","text":"Renovate supports updating Terraform Version dependencies.","title":"Automated Dependency Updates for Terraform Version"},{"location":"modules/manager/terraform-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.terraform-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terraform-version/#additional-information","text":"This will maintain .terraform-version files. Available versions will be determined from the official Terraform downloads page.","title":"Additional Information"},{"location":"modules/manager/terragrunt/","text":"Automated Dependency Updates for Terragrunt Renovate supports updating Terragrunt dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)terragrunt\\.hcl$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information Currently by default, Terragrunt support is limited to Terraform registry sources and GitHub sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . You can create a custom versioning config to support non-SemVer references. For example, if you want to reference a tag like module-v1.2.5 , a block like this would work: \"terraform\": { \"versioning\": \"regex:^((?<compatibility>.*)-v|v*)(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)$\" } Pinned Terragrunt dependencies like the following will receive a PR whenever there is a newer version available: terraform { source = \"github.com/hashicorp/example?ref=v1.0.0\" }","title":"Automated Dependency Updates for Terragrunt"},{"location":"modules/manager/terragrunt/#automated-dependency-updates-for-terragrunt","text":"Renovate supports updating Terragrunt dependencies.","title":"Automated Dependency Updates for Terragrunt"},{"location":"modules/manager/terragrunt/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)terragrunt\\.hcl$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terragrunt/#additional-information","text":"Currently by default, Terragrunt support is limited to Terraform registry sources and GitHub sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . You can create a custom versioning config to support non-SemVer references. For example, if you want to reference a tag like module-v1.2.5 , a block like this would work: \"terraform\": { \"versioning\": \"regex:^((?<compatibility>.*)-v|v*)(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)$\" } Pinned Terragrunt dependencies like the following will receive a PR whenever there is a newer version available: terraform { source = \"github.com/hashicorp/example?ref=v1.0.0\" }","title":"Additional Information"},{"location":"modules/manager/terragrunt-version/","text":"Automated Dependency Updates for Terragrunt Version Renovate supports updating Terragrunt Version dependencies. File Matching By default, Renovate will check any files matching the following regular expression: (^|/)\\.terragrunt-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This will maintain .terragrunt-version files. Available versions will be determined from gruntwork-io/terragrunt GitHub releases.","title":"Automated Dependency Updates for Terragrunt Version"},{"location":"modules/manager/terragrunt-version/#automated-dependency-updates-for-terragrunt-version","text":"Renovate supports updating Terragrunt Version dependencies.","title":"Automated Dependency Updates for Terragrunt Version"},{"location":"modules/manager/terragrunt-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.terragrunt-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terragrunt-version/#additional-information","text":"This will maintain .terragrunt-version files. Available versions will be determined from gruntwork-io/terragrunt GitHub releases.","title":"Additional Information"},{"location":"modules/manager/travis/","text":"Automated Dependency Updates for Travis Renovate supports updating Travis dependencies. File Matching By default, Renovate will check any files matching the following regular expression: ^.travis.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Additional Information This manager is intended to keep Travis config files ( .travis.yml ) up-to-date. Currently it manages only the node_js section of files only.","title":"Automated Dependency Updates for Travis"},{"location":"modules/manager/travis/#automated-dependency-updates-for-travis","text":"Renovate supports updating Travis dependencies.","title":"Automated Dependency Updates for Travis"},{"location":"modules/manager/travis/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^.travis.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/travis/#additional-information","text":"This manager is intended to keep Travis config files ( .travis.yml ) up-to-date. Currently it manages only the node_js section of files only.","title":"Additional Information"}]}